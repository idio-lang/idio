#! /usr/bin/env idio

#*

Generating C API code so that we can make C "calls" from Idio is a
complex business.  The Idio C code we're looking to create is
reasonably well structured meaning we should be able to generate much
of the scaffolding for the Idio-into-C API call.  The outputs from
this script should be copied and edited into their final form.

Bootstrap

The one exception are the generated files for libc which is used to
compile Idio itself.  The C header and Idio file are required to be
generated per platform (to give us the correct mappings from typedefs
to C base_types).  We should ensure that whilst these files may
contain extraneous information (about unused structs etc., see below)
they are at least usable verbatim without further editing.

In case you are wondering, there is a build-bootstrap version of the
generated files for libc (from some sample platform) which can be used
to create a nominal instance of an Idio executable -- yes, the sizes
of several typedef'd entities will be slightly wrong, as they probably
have been before this code was written!  There will be some compiler
warnings about implicit constant conversions.

That nominal executable can be used to run this script to generate
files for libc with correct mappings for this platform which can be
used in a recompile of the Idio executable with a corrected set of
typedef mappings.

Output Ordering

The outputs are generated in the order seen in the objdump output.
These are generally backward referencing (ie. a type is defined before
it is used) but far from necessarily so.  (There appears to be a
peculiarity where the "subprograms" (function calls) in main() are
generated in reverse order.  That could be a transient effect.)

However, the ordering will be inconsistent between platforms (and/or
versions of the compiler and objdump itself).  Running diff on the
generated C header files from two platforms is a fruitless exercise.

The Generated Code is Incomplete I

Not all platforms produce subprogram entries for function calls in
main() in the source file.  This isn't (quite) as bad as at first
blush.  You only need one platform (I have used a Fedora system using
gcc 10) to generate these subprogram entities for libc as the whole
point of the C API is that it is the same across all platforms --
otherwise, what's the point?

Therefore, with one platform's useful output we can re-work the
generated C code (.c) into a complete finished Idio-into-C API that is
portably correct for all other platforms.

However, the generated C header and Idio files are bespoke to each
platform.  A 64-bit Fedora platform might define a cascade of pid_t
--> __pid_t --> int but a 32-bit SunOS platform might define pid_t -->
long.

The C API should be using pid_t and have no knowledge of ints or longs
but we require both the C header file and Idio files to ensure the
mapping is correct for this platform.

The Generated Code is Incomplete II

Most of the C API code is rote: there are so many arguments, each with
a different type and the value returned is yet another type.  The C
code and associated Idio code for this should be largely automatic.

It *cannot* be complete, though, as there is no possible way to infer
any failure modes of the C API call itself.  System and libc calls,
for example, often, but far from always, return -1 on error.  The
generated code uses that as an example -- and as a hint that you need
to edit it.

In summary, you *must* revisit the output of this command.  It is not
even contemplated to be ready to go.

    THE GENERATED CODE WILL BE INCORRECT.

C API Behaviour

Many system calls request that a struct is allocated and passed to the
call to be filled in.  Here, we cannot expect the user to have created
such a structure (certainly, *we* provide no mechanism) however the
semantic of many of those calls is subtle.  Barring errors, the
Idio-to-C semantic expectation is that the structure is created on
behalf of the caller and returned (the fields of which to be accessed
later).

Here, then, although the C API requires a struct to be passed, the
Idio interface would not.  The generated code will need to be altered
to remove the nominal structure pointer input parameter, allocate a
structure and, barring errors, return an Idio-encapsulated pointer to
the allocated structure for future reference.

Other APIs maintain arguments that are deprecated and are not expected
to have values passed.  Clearly there's no way for this generator code
to identify that.

Missing typdefs

Many C APIs use an internal/intermediate type.  The more common
effects of this are that, unless you explicitly create C variables
using the types, you might only see, say, __pid_t rather than pid_t.
That's because the C API's implementation is defined using __pid_t and
pid_t is typedef'd as a convenience for the user -- irrespective of
the nominal C API.

Idio Re-imagining of C

In some cases, for example, write(2), the third argument, size_t
count, is redundant as all Idio elements know their own size.
write(2) is interesting as there isn't a concept of a "const void
*buf", the entity to be written, anyway.  The chances are this would
be replaced with an Idio string.

Many C APIs use parameters which are constants (F_SETFD) or the
bitwise inclusive-or of several constants (O_WRONLY | O_CREAT |
O_TRUNC).  It may be more idiosyncratic to pass symbols or lists of
symbols.  Calling C bitwise operators is possible but assumptions are
made about the underlying C base_type (C/uint).

#define

For *anything* that involves a #define there is abolsutely nothing to
be done.  There are no artifacts of the CPP left in the object code.

A example of that is for stat(2).  The traditional struct stat
suggests there is a time_t st_mtime field.  In more recent systems,
struct stat has the nanosecond resolution struct timespec st_mtim
together with a:

#define st_mtime st_mtim.tv_sec

to ensure that existing code continues to compile without issue.

objdump, and therefore we, do not see the #define.  We only have the
true st_mtim field.

Of course, being aware of this, there's nothing to prevent us
reworking the generated code to allow both fields to exist as well.

(That's slightly trickier to handle in the libc bootstrap case.  TBD.)

Portability

There are portability issues as well.  Fedora defines an enumerated
type for getrlimit(2) resources, RLIMIT_CPU etc. from which we can
create and export Idio values.  However, a portable set of RLIMIT_*
values probably requires continued use if #ifdef CPP wrappers around a
cross-platform super-set of possible names.

(Again, for libc bootstrap we have a problem.)

enumeration_type definitions

Notice that enumeration types can exist in the objdump output even if
they are not otherwise referenced.

  typedef enum {one, two} num_t;

If num_t is not used we will still see the (anonymous) enumeration
type.

You may need to instantiate an instance of a typedef'd enum to get the
association.

structures and unions

Careful!  All structures and unions used are lifted out to the top
level even if a structure is only used inside another structure or
union and vice versa etc..

So, only iterate over the ones we use (variables) and the ones used by
subprograms (which might not be available in this system's objdump
output -- but which *should* be portable(-ish) from any system which
does make it available...).

All structures (and unions) have two variants generated: a -ref and a
-set!.  However, most system calls, for example, are effectively
read-only so the -set! variant is entirely redundant.  No-one expects
to be setting any element of a stat(2)'s struct stat for any useful
purpose...wait, do they?

That said, some APIs request or allocate a structure that is opaque.
stdio(3)'s FILE and regex(7)'s regex_t are examples where we simply
have no business poking about inside the structure.  However, as FILE
and regex_t are used as arguments to APIs we will have the structure
accessors generated.  

There's a choice here, Simply delete the structure references --
noting you will want to carefully remove related references in the C
header and Idio api files.  Given that we are not (meant to be)
familiar with the contents of those types, which related references
should be removed becomes an interesting exercise.  The code should
drop out a similar decl_file comment in the other files which should
help.

For libc, which is used by Idio itself (leading to the infernal
bootstrap problem) I've chosen to maintain hand-crafted
implementations of tricksome API calls.  For example, I've stopped
using FILE entities (and therefore fileno(3)) and the regex(7) code
can be just the library calls (and no structures).  As it happens, the
regcomp(3)/regexec(3) calls are amenable to passing symbols in place
of the original C macros and so the generated code would have been
mostly rewritten anyway.

Names

There are going to be many names floating about: we have the original
C API names (pid_t, say); the Idio-C API names for function name
construction (pid_t, again but a C "unsigned long" becomes a "ulong"
in Idio function names, say); Idio API names (pid_t?); Idio "direct"
names (libc/pid_t and C/int), etc..

Let's start with the library name.  libc is easy enough but
libpcre2-posix causes us some problems in C as pcre2-posix is not a
valid identifier.

pcre2-posix			i-module-name
pcre2_posix			c-module-name

Next, consider pid_t from libc where, obviously(?) the raw names are
C-safe (and therefore Idio-safe) but we want to combine them into
various names -- here, the variable elements are in {}s:

{pid_t}				i-type-alias
{pid_t}?			i-pred-name

    i-type-alias is a symbol (ultimately) mapping to a C base_type,
    'int, 'long, etc., and can be used to construct a C integral type
    from an Idio integer: (C/integer-> 1 libc/pid_t)

{libc}/{pid_t}			i-direct-type-name	- used in comments
{libc}/{pid_t}?			i-direct-pred-name

{pid_t}				c-type-name
IDIO_TYPE_C_{libc}_{pid_t}	idio-c-macro-type
idio_{libc}_{pid_t}		c-type-constructor
IDIO_C_TYPE_{libc}_{pid_t}	c-type-accessor		- starts in upper-case!
idio_isa_{libc}_{pid_t}		c-type-predicate

There's a complication with base_types which are defined in the C module:

{int}				i-type-alias		- referenced in comments
{int}?				i-pred-name

C/{int}				i-direct-type-name	- used in comments
C/{int}?			i-direct-pred-name

{int}				c-type-name
IDIO_TYPE_C_TYPE_{INT}		idio-c-macro-type
idio_C_{int}			c-type-constructor
IDIO_C_TYPE_{int}		c-type-accessor		- starts in upper-case!
idio_isa_C_{int}		c-type-predicate

In addition there is an i-c-type-name which is the Idio-ish C type
name for something.  The primary usage is for handling C entities that
would need allocating on the heap (pointers, arrays, structs, unions)
all of which become the Idio C type, pointer.

Eventually, all library-specific types will map to a C type, for
example, on one system:

typedef int __pid_t
typedef __pid_t pid_t

This will result in:

* libc-api.idio

export (
	__pid_t
	__pid_t?
	pid_t
	pid_t?
)

__pid_t                            := 'int
define __pid_t?                       C/int?

pid_t                              := __pid_t
define pid_t?                         __pid_t?

* libc-api.h

#define idio_libc___pid_t                   idio_C_int
#define IDIO_C_TYPE_libc___pid_t            IDIO_C_TYPE_int
#define idio_isa_libc___pid_t               idio_isa_C_int

#define idio_libc_pid_t                     idio_libc___pid_t
#define IDIO_C_TYPE_libc_pid_t              IDIO_C_TYPE_libc___pid_t
#define idio_isa_libc_pid_t	            idio_isa_libc___pid_t

*#

ext-dirs := #n
for-each (function (d) {
	    (regex-case
	     d
	     (".*/ext$" {
	       if (d? r.0) {
		 ext-dirs = pair r.0 ext-dirs
	       }
	     })
	     ("(.*)/lib/idio" {
	       ed := sprintf "%s/ext" r.1
	       if (d? ed) {
		 ext-dirs = pair ed ext-dirs
	       }
	     }))
}) (split-string IDIOLIB ":")

define (find-ext-dir lib-n) {
  loop :+ function (ed*) {
	    if (null? ed*) #n {
	      ed := ph ed*
	      d := append-string ed "/" lib-n
	      if (d? d) {
		d
	      } {
		loop (pt ed*)
	      }
	    }
  }

  loop ext-dirs
}

define (C-identifier word) {
  collect-output echo word | sed -e "s/[^[:alnum:]]/_/g"
}

define (Idio-identifier word) {
  collect-output echo word | sed -e "s/[^[:alnum:]_]/-/g"
}

for-each (function (lib-n) {
	    lib-dn := find-ext-dir lib-n
	    if (d? lib-dn) {
	      api-dn := sprintf "%s/api" lib-dn

	      api-bn := sprintf "%s-api" lib-n
	      api-c-fn := sprintf "%s/%s.c" api-dn api-bn
	      if (r? api-c-fn) {
		printf "working on %s\n" lib-n
		api-o-fn := sprintf "%s/%s.o" api-dn api-bn
		if (e? api-o-fn) {
		  delete-file api-o-fn
		}

		pointer-size := 0
		base-id := #f
		all-ids := (make-hash)
		lnt := #f		; line number table
		dir-a := make-array 1
		file-a := make-array 1
		filenames := make-array 1

		define (filename df) {
		  (cond
		   ((string? df) df)
		   ((integer? df) {
		     if (df lt (array-length filenames)) {
		       array-ref filenames df
		     } {
		       sprintf "!!! filename #%s !!!" df
		     }
		   })
		   (else {
		     eprintf "df is not expected: %s\n" df
		     sprintf "!!! unexpected filename %s !!!" df
		   }))
		}

		;; We want the .debug_info and .debug_line sections
		;; from the DWARF in the object file (ELF or Mach-O) .

		;; Most systems have objdump doing something useful
		;; (albeit sometimes without the finesse of -Wil).
		;; Mac OS X+ does have an objdump (but it will only print
		;; out the .debug_frame section (with the slightly
		;; confusing --dwarf=frames flag) .

		;; Mac OS X+ does have dwarfdump (and --debug-info and
		;; --debug-line options, yay!, although in 10.5 it
		;; uses TAG_ rather than DW_TAG_ and in 10.15 it
		;; expands out decl_file anyway so --debug-line is
		;; possibly redundant) but the output is similarly
		;; different to objdump.  Hence these two variations
		;; on a theme of reading object files.

		(cond-expand
		 (uname/sysname/Darwin {
		   cwd := PWD
		   (unwind-protect {
		     libc/chdir lib-dn
		     make -C api-dn api-o-fn
		   } {
		     libc/chdir cwd
		   })

		   if (not (f? api-o-fn)) {
		     eprintf "failed to compile %s\n" api-o-fn
		     exit 1
		   }

		   oph := pipe-from dwarfdump --debug-info --debug-line api-o-fn
		   p-depth := 0

		   define (dwarfdump-loop depth DIE) {
		     if (eof? oph) DIE {
		       (regex-case (read-line oph)
				   ("(0x[[:xdigit:]]+):([[:space:]]+)(DW_)?TAG_([[:alnum:]_]+)" {
				     id := r.1
				     ;; there's no formal declaration
				     ;; of nesting depth other than
				     ;; the relative indent of the
				     ;; elements!
				     c-depth := string-length r.2
				     tag := string->symbol r.4

				     ;; new DIE
				     new-DIE := (make-hash)
				     hash-set! new-DIE 'tag tag
				     hash-set! new-DIE 'id id
				     hash-set! all-ids id new-DIE

				     if (and (not base-id)
					     (eq? tag 'compile_unit)) {
					       base-id = id
					       hash-set! new-DIE '__parent new-DIE
					       p-depth = c-depth
					       dwarfdump-loop c-depth new-DIE
					     } {

					       parent := hash-ref DIE '__parent
					       ; new-DIE is a sibling of DIE unless...
					       if (c-depth gt depth) {
						 ; new-DIE is a child of DIE
						 parent = DIE
					       }
					       ; or dwarfdump hasn't dropped out the Abbrev 0
					       if (c-depth lt depth) {
						 if (eqv? c-depth p-depth) {
						   parent = hash-ref all-ids base-id
						 }
					       }

					       ; parent should have an array of tag'd entries
					       a := hash-ref parent tag #f
					       if (not a) {
						 a = #[]
						 hash-set! parent tag a
					       }

					       array-push! a new-DIE

					       hash-set! new-DIE '__parent parent
					       dwarfdump-loop c-depth new-DIE
					     }
				   })
				   ("(0x[[:xdigit:]]+):([[:space:]]+)NULL" {
				     dwarfdump-loop (depth - 1) (hash-ref DIE '__parent)
				   })
				   (
				     ;;                DW_AT_type      (0x00000037 "int")
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+\\((0x[[:xdigit:]]+)\\ \"[^\"]+\")" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;; Darwin 9.8.0
				     ;;                AT_type( {0x00000413} ( const char ) )
				     "[[:space:]]+AT_([^[:space:]]+)\\( {(0x[[:xdigit:]]+)} \\( ([^\\)]+) \\) \\)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;;                DW_AT_name      ("int")
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+\\(\"([^\"]+)\"\\)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;; Darwin 9.8.0
				     ;;                AT_name( "int" )
				     "[[:space:]]+AT_([^[:space:]]+)\\( \"([^\"]+)\" \\)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;;                DW_AT_byte_size (0x04)
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+\\(0x([[:xdigit:]]+)\\)" {
				       hash-set! DIE (string->symbol r.1) (read-number r.2 16)
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;; Darwin 9.8.0
				     ;;                AT_byte_size( 0x04 )
				     "[[:space:]]+AT_([^[:space:]]+)\\( 0x([[:xdigit:]]+) \\)" {
				       hash-set! DIE (string->symbol r.1) (read-number r.2 16)
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;;                DW_AT_frame_base        (DW_OP_reg6 RBP)
				     ;;                DW_AT_decl_line (53)
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+\\(([^)]+)\\)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;; darwin 9.8.0
				     ;;                AT_decl_file( "/usr/include/i386/_types.h" )
				     ;;                AT_decl_line( 53 )
				     "[[:space:]]+AT_([^[:space:]]+)\\( ([^)]+) \\)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       dwarfdump-loop depth DIE
				     })
				   ("The Directory Table" {
				     lnt = 'dir
				     dwarfdump-loop depth DIE
				   })
				   ("The File Name Table" {
				     lnt = 'file
				     dwarfdump-loop depth DIE
				   })
				   ("Line Number Statements" {
				     lnt = #f
				     dwarfdump-loop depth DIE
				   })
				   (
				     ;;   3     3       0       0       types.h
				     ;;   5     4       0       0       types.h
				     "[[:digit:]]+[[:space:]]+([[:digit:]]+)[[:space:]]+[[:digit:]]+[[:space:]]+[[:digit:]]+[[:space:]]+(.+)$" {
				       if (eq? lnt 'file) {
					 dir-n :=
					 array-push! file-a r.2
					 array-push! filenames (append-string (array-ref dir-a (read-number r.1))
									      "/"
									      r.2)
				       }
				       dwarfdump-loop depth DIE
				     })
				   (
				     ;; Darwin 9.8.0
				     ;;   file_names[  8]    4 0x00000000 0x00000000 resource.h
				     "file_names\\[[[:space:]]*[[:digit:]]+\\][[:space:]]+([[:digit:]]+)[[:space:]]+[[:xdigit:]]+[[:space:]]+[[:xdigit:]]+[[:space:]]+(.+)$" {
				       if (eq? lnt 'file) {
					 dir-n :=
					 array-push! file-a r.2
					 array-push! filenames (append-string (array-ref dir-a (read-number r.1))
									      "/"
									      r.2)
				       }
				       dwarfdump-loop depth DIE
				     })
				   (
				     ; Darwin 9.8.0
				     ;;   include_directories[  4] = '/usr/include/sys'
				     "(/.+)'$" {
				       if (eq? lnt 'dir) {
					 array-push! dir-a r.1
				       }
				       dwarfdump-loop depth DIE
				     })
				   ("Pointer Size:[[:space:]]+([[:digit:]]+)" {
				     pointer-size = read-number r.1
				     dwarfdump-loop depth DIE
				   })
				   (else {
				     dwarfdump-loop depth DIE
				   }))
		     }
		   }

		   dummy-DIE := (make-hash)
		   hash-set! dummy-DIE '__parent dummy-DIE
		   dwarfdump-loop -1 dummy-DIE
		   })
		 (else {
		   objdump-flags := "-Wil"
		   cwd := PWD
		   (unwind-protect {
		     libc/chdir lib-dn
		     (cond-expand
		      ((or uname/sysname/FreeBSD
			   uname/sysname/OpenBSD) {
			gmake -C api-dn api-o-fn
			objdump-flags = "-W"
		      })
		      (uname/sysname/SunOS {
			make -C api-dn api-o-fn
			objdump-flags = "-W"
		      })
		      (else {
			make -C api-dn api-o-fn
		      }))
		   } {
		     libc/chdir cwd
		   })

		   if (not (f? api-o-fn)) {
		     eprintf "failed to compile %s\n" api-o-fn
		     exit 1
		   }

		   oph := pipe-from objdump objdump-flags api-o-fn

		   define (objdump-loop depth DIE) {
		     if (eof? oph) DIE {
		       (regex-case (read-line oph)
				   ("<([[:xdigit:]]+)><([[:xdigit:]]+)>: Abbrev Number: ([[:digit:]]+) \\(DW_TAG_([^)]+)\\)" {
				     c-depth := read-number r.1
				     id := r.2
				     tag := string->symbol r.4

				     ;; new DIE
				     new-DIE := (make-hash)
				     hash-set! new-DIE 'tag tag
				     hash-set! new-DIE 'id id
				     hash-set! all-ids id new-DIE

				     (case c-depth
					   ((0) {
					     ; bootstrap - self-referential
					     base-id = id
					     hash-set! new-DIE '__parent new-DIE
					     objdump-loop c-depth new-DIE
					   })
					   (else {
					     parent := hash-ref DIE '__parent
					     if (equal? r.3 "0") {
					       ; end of siblings - continue with parent
					       objdump-loop (depth - 1) parent
					     } {
					       ; new-DIE is a sibling of DIE unless...
					       if (c-depth gt depth) {
						 ; new-DIE is a child of DIE
						 parent = DIE
					       }
					       ; or objdump hasn't dropped out the Abbrev 0
					       if (c-depth lt depth) {
						 if (eqv? c-depth 1) {
						   parent = hash-ref all-ids base-id
						 } {
						   printf "NOTICE: %d -> %d from 0x%s %s\n" depth c-depth (hash-ref DIE 'id) (hash-ref DIE 'tag)
						 }
					       }

					       ; parent should have an array of tag'd entries
					       a := hash-ref parent tag #f
					       if (not a) {
						 a = #[]
						 hash-set! parent tag a
					       }

					       array-push! a new-DIE

					       hash-set! new-DIE '__parent parent
					       objdump-loop c-depth new-DIE
					     }
					   }))
				   })
				   ;; XXX FreeBSD-10 is prone to trailing TABs
				   ;; OpenBSD-6 doesn't have the leading <id>

				   (
				     ;;     <3c>   DW_AT_byte_size   : 4
				     ;;     <3d>   DW_AT_encoding    : 7        (unsigned)
				     "<[[:xdigit:]]+>[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]*: ([[:digit:]]+)" {
				       hash-set! DIE (string->symbol r.1) (read-number r.2)
				       objdump-loop depth DIE
				     })
				   (
				     ;; OpenBSD-6
				     ;;     DW_AT_byte_size   : 4
				     ;;     DW_AT_encoding    : 7        (unsigned)
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]*: ([[:digit:]]+)" {
				       hash-set! DIE (string->symbol r.1) (read-number r.2)
				       objdump-loop depth DIE
				     })
				   (
				     ;;     <3e>   DW_AT_name        : (indirect string, offset: 0x187): unsigned int
				     "<[[:xdigit:]]+>[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: \\(indirect string, offset: 0x[[:xdigit:]]+\\): ([^\t]+)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   (
				     ;;     <6c>   DW_AT_type        : <0x65>
				     "<[[:xdigit:]]+>[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: <0x([[:xdigit:]]+)>" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   (
				     ;; FreeBSD-10 -- no 0x
				     ;;     <6c>   DW_AT_type        : <65>
				     "<[[:xdigit:]]+>[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: <([[:xdigit:]]+)>" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   (
				     ;; OpenBSD-6
				     ;;     DW_AT_type        : <65>
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: <([[:xdigit:]]+)>" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   (
				     ;;    <5a>   DW_AT_name        : int
				     "<[[:xdigit:]]+>[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: ([^\t]+)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   (
				     ;; OpenBSD-6
				     ;;    DW_AT_name        : int
				     "[[:space:]]+DW_AT_([^[:space:]]+)[[:space:]]+: ([^\t]+)" {
				       hash-set! DIE (string->symbol r.1) r.2
				       objdump-loop depth DIE
				     })
				   ("Abbrev Number: 0" {
				     objdump-loop (depth - 1) (hash-ref DIE '__parent)
				   })
				   ("The Directory Table" {
				     lnt = 'dir
				     objdump-loop depth DIE
				   })
				   ("The File Name Table" {
				     lnt = 'file
				     objdump-loop depth DIE
				   })
				   ("Line Number Statements" {
				     lnt = #f
				     objdump-loop depth DIE
				   })
				   (
				     ;; objdump 2.35.1 fc34?
				     ;;  Entry Dir     Name
				     ;;  2     2       (indirect line string, offset: 0x15d): types.h
				     ;;  3     3       (indirect line string, offset: 0x165): types.h

				     "([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]]+\\([^\\)]+\\):[[:space:]]+(.+)$" {
				       if (eq? lnt 'file) {
					 file-n := read-number r.1
					 dir-n := read-number r.2
					 array-set! file-a file-n r.3
					 array-set! filenames file-n (append-string (array-ref dir-a dir-n)
										    "/"
										    r.3)
				       }
				       objdump-loop depth DIE
				     })
				   (
				     ;; objdump 2.35.1 fc34?
				     ;;  3     (indirect line string, offset: 0xbd): /usr/include/sys

				     "([[:digit:]]+)[[:space:]]+\\([^\\)]+\\):[[:space:]]+(/.+)$" {
				       if (eq? lnt 'dir) {
					 array-set! dir-a (read-number r.1) r.2
				       }
				       objdump-loop depth DIE
				     })
				   (
				     ;;   Entry Dir     Time    Size    Name
				     ;;   3     3       0       0       types.h
				     ;;   5     4       0       0       types.h
				     "[[:digit:]]+[[:space:]]+([[:digit:]]+)[[:space:]]+[[:digit:]]+[[:space:]]+[[:digit:]]+[[:space:]]+(.+)$" {
				       if (eq? lnt 'file) {
					 array-push! file-a r.2

					 ; FreeBSD clang version 11
					 ; generates a directory table
                                         ; entry of 0 (which
                                         ; obviously(?) doesn't
                                         ; exist).
					 dir-n := "."
					 dir-i := read-number r.1
					 if (dir-i gt 0) {
					   dir-n = array-ref dir-a dir-i
					 }
					 array-push! filenames (append-string dir-n
									      "/"
									      r.2)
				       }
				       objdump-loop depth DIE
				     })
				   (
				     ;;   3     /usr/include/sys
				     ;;   /usr/include/sys
				     "(/.+)$" {
				       if (eq? lnt 'dir) {
					 array-push! dir-a r.1
				       }
				       objdump-loop depth DIE
				     })
				   ("Pointer Size:[[:space:]]+([[:digit:]]+)" {
				     pointer-size = read-number r.1
				     objdump-loop depth DIE
				   })
				   (else {
				     ;printf "? %s\n" r
				     objdump-loop depth DIE
				   }))
		     }
		   }

		   objdump-loop -1 #n
		   }))

		if (not base-id) {
		  eprintf "ERROR: %s: no DW_TAG_compile_unit in %s?\n" ARGV0 api-o-fn
		  exit 1
		}

		gen-dn := sprintf "%s/gen" lib-dn
		rm -rf gen-dn
		mkdir gen-dn

		i-module-name := lib-n
		c-module-name := C-identifier lib-n

		errors-dn := sprintf "%s/%s-errors" gen-dn i-module-name
		if (not (d? errors-dn)) {
		  mkdir errors-dn
		}

		tc-count := 0
		errors-fn := sprintf "%s/test-%s-error.idio" gen-dn i-module-name
		errors-fh := open-output-file errors-fn
		hprintf errors-fh #S{
;;
;; test-${i-module-name}-error.idio
;;

module tests/${i-module-name}
import ${i-module-name}

${i-module-name}-error0 := Tests

#*

We have a bunch of test cases which should provoke a
^rt-${i-module-name}-error, ^system-error or ^rt-parameter-error.

So we can write a load function which will wrapper the actual load
with a trap for (^rt-${i-module-name}-error ...) and compare the
message strings.

*#

${i-module-name}-error-load := {
  n := 0

  function (filename msg & args) {
    if (not (string? filename)) (error 'load "not a string" filename)

    load-k := #n

    n = n + 1

    exp-tests := 1
    if (pair? args) {
      exp-tests = 3
    \}

    ;eprintf "loading #%%s %%s looking for %%s\\n" n filename msg
    trap (^rt-${i-module-name}-error
	  ^system-error
	  ^rt-parameter-error) (function (c) {
				  ;eprintf "${i-module-name}-error #%%s: %%s %%s\\n" n msg c.location
				  test c.message msg

				  if (not (string=? c.message msg)) {
				    condition-report (append-string "${i-module-name}-error-load: " filename) c (current-error-handle)
				  \}

				  if (system-error? c) {
				    tested := #f
				    if (pair? args) {
				      test (system-error-errno c) (ph args)
				      if (pair? (pt args)) {
					test (system-error-function c) (pht args)
					tested = #t
				      \}
				    \}

				    if (not tested) {
				      condition-report (append-string "${i-module-name}-error-load: " filename) c (current-error-handle)
				    \}
				  \}

				  load-k '${i-module-name}-error
	  \}) {
	    call/cc (function (k) {
		       load-k = k
		       t0 := Tests
		       (symbol-value 'load 'Idio) filename
		       if (not (equal? Tests (t0 + exp-tests))) {
			 eprintf "${i-module-name}-error #%%s: %%s did not generate \\"%%s\\"\\n" n filename msg
			 Errors = Errors + 1
			 Tests = t0 + exp-tests
		       \}
	    \})
	  \}
  \}
\}

}

		define (base-type? id) {
		  if id {
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((base_type enumeration_type) {
			      #t
			    })
			    ((restrict_type const_type) {
			      base-type? (hash-ref DIE 'type #f)
			    })
			    (else {
			      #f
			    }))
		    } {
		      eprintf "base-type? %s\n" id
		      #f
		    }
		    } #f
		}

		define (pointer-type? id) {
		  if id {
		    name := 'void		; implied default?
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      pointer-type? (hash-ref DIE 'type #f)
			    })
			    ((pointer_type) {
			      #t
			    })
			    (else #f))
		    } {
		      sprintf "pointer-DIE-0x%s" id
		    }
		    } #f
		}

		define (structure-type? id) {
		  if id {
		    name := 'void		; implied default?
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      structure-type? (hash-ref DIE 'type #f)
			    })
			    ((structure_type) {
			      #t
			    })
			    (else #f))
		    } {
		      sprintf "structure-DIE-0x%s" id
		    }
		    } #f
		}

		define (alloc-required? id) {
		  if id {
		    name := 'void		; implied default?
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      alloc-required? (hash-ref DIE 'type #f)
			    })
			    ((pointer_type array_type structure_type union_type) {
			      #t
			    })
			    (else #f))
		    } {
		      sprintf "pointer-DIE-0x%s" id
		    }
		    } #f
		}

		;; what kind of C thing do we allocate
		define (alloc-type id) {
		  if id {
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type enumeration_type) {
			      alloc-type (hash-ref DIE 'type #f)
			    })
			    ((pointer_type) {
			      t := alloc-type (hash-ref DIE 'type #f)
			      if t {
				append-string t "*"
			      } {
				t
			      }
			    })
			    ((array_type) {
			      t := alloc-type (hash-ref DIE 'type #f)
			      if t {
				append-string t "[]"
			      } {
				t
			      }
			    })
			    ((structure_type) {
			      struct-name := hash-ref DIE 'name #f
			      if (not struct-name) {
				#f
			      } {
				append-string "struct " struct-name
			      }
			    })
			    ((union_type) {
			      union-name := hash-ref DIE 'name #f
			      if (not union-name) {
				#f
			      } {
				append-string "union " union-name
			      }
			    })
			    ((typedef base_type) {
			      hash-ref DIE 'name #f
			    })
			    (else {
			      ;eprintf "no alloc-type for %s %s\n" id (hash-ref DIE 'type #f)
			      #f
			    }))
		    } {
		      eprintf "alloc-type no DIE 0x%s!" id
		      exit 1
		    }
		  } {
		    "void"
		  }
		}

		define (c-type id) {
		  if id {
		    name := "void"		; implied default?
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      c-type (hash-ref DIE 'type #f)
			    })
			    ((pointer_type) {
			      append-string (c-type (hash-ref DIE 'type #f)) "*"
			    })
			    ((subroutine_type) {
			      "(*)"
			    })
			    ((array_type) {
			      append-string (c-type (hash-ref DIE 'type #f)) "[]"
			    })
			    ((structure_type) {
			      struct-name := hash-ref DIE 'name #f
			      if struct-name {
				append-string "struct " struct-name
			      } {
				;eprintf "c-type anonymous struct 0x%s\n" id
				"struct {}"
			      }
			    })
			    ((union_type) {
			      union-name := hash-ref DIE 'name #f
			      if union-name {
				append-string "union " union-name
			      } {
				;eprintf "c-type anonymous union 0x%s\n" id
				"union {}"
			      }
			    })
			    ((enumeration_type) {
			      c-type (hash-ref DIE 'type #f)
			    })
			    ((typedef) {
			      hash-ref DIE 'name #f
			    })
			    ((base_type) {
			      hash-ref DIE 'name #f
			    })
			    (else {
			      eprintf "c-type 0x%s!\n" id
			      exit 1
			    }))
		    } {
		      eprintf "c-type no DIE 0x%s!\n" id
		      exit 1
		    }
		  } {
		    "void"
		  }
		}

		;; differs from c-type in that we want just the
		;; (compressed) Idio C API name
		define (idio-c-type-name id) {
		  if id {
		    name := "void"		; implied default?
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      idio-c-type-name (hash-ref DIE 'type #f)
			    })
			    ((pointer_type) {
			      append-string (idio-c-type-name (hash-ref DIE 'type #f)) "*"
			    })
			    ((subroutine_type) {
			      "(*)"
			    })
			    ((array_type) {
			      append-string (idio-c-type-name (hash-ref DIE 'type #f)) "[]"
			    })
			    ((structure_type) {
			      "pointer"
			    })
			    ((union_type) {
			      "pointer"
			    })
			    ((enumeration_type) {
			      idio-c-type-name (hash-ref DIE 'type #f)
			    })
			    ((typedef) {
			      hash-ref DIE 'name #f
			    })
			    ((base_type) {
			      (case (hash-ref DIE 'name "base_type-name")
				    (("char")			 "char")
				    (("signed char")		 "schar")
				    (("unsigned char")		 "uchar")
				    (("short int" "short")	 "short")
				    (("short unsigned int"
				      "unsigned short")		 "ushort")
				    (("int")			 "int")
				    (("unsigned int")		 "uint")
				    (("long int")		 "long")
				    (("long unsigned int")	 "ulong")
				    (("long long int")		 "longlong")
				    (("long long unsigned int")	 "ulonglong")
				    (("float")			 "float")
				    (("double")			 "double")
				    (("long double")		 "longdouble")
				    (else {
				      eprintf "idio-c-type-name: unexpected base type: '%s'\n" (hash-ref DIE 'name "base_type-name")
				      exit 1
				    }))
			    })
			    (else {
			      eprintf "idio-c-type-name 0x%s!\n" id
			      exit 1
			    }))
		    } {
		      eprintf "idio-c-type-name no DIE 0x%s!\n" id
		      exit 1
		    }
		  } {
		    "void"
		  }
		}

		;; we're looking to generate the likes of
		;; IDIO_TYPE_C_INT from gc.h
		define (idio-c-type-MACRO-NAME id) {
		  if id {
		    name := "VOID"	; might cause a crash...
		    DIE := hash-ref all-ids id #f
		    if DIE {
		      (case (hash-ref DIE 'tag #f)
			    ((restrict_type const_type) {
			      idio-c-type-name (hash-ref DIE 'type #f)
			    })
			    ((pointer_type) {
			      append-string (idio-c-type-name (hash-ref DIE 'type #f)) "*"
			    })
			    ((subroutine_type) {
			      "(*)"
			    })
			    ((array_type) {
			      append-string (idio-c-type-name (hash-ref DIE 'type #f)) "[]"
			    })
			    ((structure_type) {
			      "pointer"
			    })
			    ((union_type) {
			      "pointer"
			    })
			    ((enumeration_type) {
			      idio-c-type-name (hash-ref DIE 'type #f)
			    })
			    ((typedef) {
			      hash-ref DIE 'name #f
			    })
			    ((base_type) {
			      (case (hash-ref DIE 'name "base_type-name")
				    (("char")			 "CHAR")
				    (("signed char")		 "SCHAR")
				    (("unsigned char")		 "UCHAR")
				    (("short int" "short")	 "SHORT")
				    (("short unsigned int"
				      "unsigned short")		 "USHORT")
				    (("int")			 "INT")
				    (("unsigned int")		 "UINT")
				    (("long int")		 "LONG")
				    (("long unsigned int")	 "ULONG")
				    (("long long int")		 "LONGLONG")
				    (("long long unsigned int")	 "ULONGLONG")
				    (("float")			 "FLOAT")
				    (("double")			 "DOUBLE")
				    (("long double")		 "LONGDOUBLE")
				    (else {
				      eprintf "idio-c-type-MACRO-NAME: unexpected base type: '%s'\n" (hash-ref DIE 'name "base_type-name")
				      exit 1
				    }))
			    })
			    (else {
			      eprintf "idio-c-type-MACRO-NAME 0x%s: base_types only!\n" id
			      exit 1
			    }))
		    } {
		      eprintf "idio-c-type-MACRO_NAME no DIE 0x%s!\n" id
		      exit 1
		    }
		  } {
		    "void"
		  }
		}

		define (get/create DIE elem & alt) {
		  if DIE {
		    v := hash-ref DIE elem #f
		    if v v {
		      id := hash-ref DIE 'id #f
		      name := hash-ref DIE 'name #f
		      (case elem
			    ((i-type-alias) {
			      ;; pid_t
			      ;; uint
			      (cond
			       ((alloc-required? id) {
				 v = "C/pointer"
			       })
			       ((base-type? id) {
				 v = append-string "'" (idio-c-type-name id)
			       })
			       (else {
				 if name {
				   v = name
				 } {
				   v = "void"
				 }
			       }))
			    })
			    ((i-direct-type-name) {
			      ;; libc/pid_t
			      ;; C/uint
			      (cond
			       ((alloc-required? id) {
				 v = "C/pointer"
			       })
			       ((base-type? id) {
				 v = append-string "C/" (idio-c-type-name id)
			       })
			       (else {
				 if name {
				   v = append-string i-module-name "/" name
				 }
			       }))
			    })
			    ((i-pred-name) {
			      ;; pid_t?
			      ;; uint?
			      if name {
				v = append-string name "?"
			      }
			    })
			    ((i-direct-pred-name) {
			      ;; libc/pid_t?
			      ;; C/uint?
			      (cond
			       ((alloc-required? id) {
				 v = "C/pointer?"
			       })
			       ((base-type? id) {
				 v = append-string "C/" (idio-c-type-name id) "?"
			       })
			       (else {
				 if name {
				   v = append-string i-module-name "/" name "?"
				 }
			       }))
			    })
			    ((c-type-name) {
			      v = c-type id
			    })
			    ((i-c-type-name) {
			      v = idio-c-type-name id
			    })
			    ((c-alloc-type-name) {
			      v = alloc-type id
			      if (not v) {
				v = "void" ; __sigaction_handler
			      }
			    })
			    ((idio-c-macro-type) {
			      ;; IDIO_TYPE_C_libc_pid_t
			      ;; IDIO_TYPE_C_uint
			      (cond
			       ((alloc-required? id) {
				 v = "IDIO_TYPE_C_POINTER"
			       })
			       ((base-type? id) {
				 v = append-string "IDIO_TYPE_C_" (idio-c-type-MACRO-NAME id)
			       })
			       (else {
				 if name {
				   v = append-string "IDIO_TYPE_C_" c-module-name "_" name
				 }
			       }))
			    })
			    ((c-type-constructor) {
			      ;; idio_libc_pid_t
			      ;; idio_C_uint
			      (cond
			       ((alloc-required? id) {
				 v = "idio_C_pointer_free_me"
			       })
			       ((base-type? id) {
				 v = append-string "idio_C_" (idio-c-type-name id)
			       })
			       (else {
				 if name {
				   v = append-string "idio_" c-module-name "_" name
				 }
			       }))
			    })
			    ((c-type-accessor) {
			      ;; IDIO_C_TYPE_libc_pid_t
			      ;; IDIO_C_TYPE_uint
			      (cond
			       ((alloc-required? id) {
				 v = "IDIO_C_POINTER_P"
			       })
			       ((base-type? id) {
				 v = append-string "IDIO_C_TYPE_" (idio-c-type-name id)
			       })
			       (else {
				 if name {
				   v = append-string "IDIO_C_TYPE_" c-module-name "_" name
				 }
			       }))
			    })
			    ((c-type-predicate) {
			      ;; idio_isa_libc_pid_t
			      ;; idio_isa_C_uint
			      (cond
			       ((alloc-required? id) {
				 v = "idio_isa_C_pointer"
			       })
			       ((base-type? id) {
				 v = append-string "idio_isa_C_" (idio-c-type-name id)
			       })
			       (else {
				 if name {
				   v = append-string "idio_isa_" c-module-name "_" name
				 }
			       }))
			    })
			    (else {
			      eprintf "unexpected elem %s\n" elem
			      exit 1
			    }))

		      if v {
			hash-set! DIE elem v
			v
		      } {
			eprintf "get/create no value for %s 0x%s\n" elem id
			exit 1
		      }

		    }
		  } {
		    eprintf "get/create no DIE for %s\n" elem
		    exit 1
		  }
		}

		PROGNAME := ARGV0
		(regex-case PROGNAME
			    ("([^/]+)$" {
			      PROGNAME = r.1
			    }))
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;
		;; file headers

		api-h-bn := sprintf "%s.h" api-bn
		api-h-fn := sprintf "%s/%s" gen-dn api-h-bn
		api-h-fh := open-output-file api-h-fn

		api-h-define := collect-output echo api-h-bn | sed -e "s/[^[:alnum:]]/_/g" | tr "[[:lower:]]" "[[:upper:]]"

		hprintf api-h-fh #S{
/*
 * ${api-h-bn}
 *
 *
 * This file was generated by ${PROGNAME} on a ${libc/idio-uname.sysname} ${libc/idio-uname.release} ${libc/idio-uname.machine} system
 */

#ifndef ${api-h-define}
#define ${api-h-define}

}

		api-c-bn := sprintf "%s.c" api-bn
		api-c-fn := sprintf "%s/%s" gen-dn api-c-bn
		api-c-fh := open-output-file api-c-fn

		hprintf api-c-fh #S{
/*
 * ${api-c-bn}
 *
 *
 * This file was generated by ${PROGNAME} on a ${libc/idio-uname.sysname} ${libc/idio-uname.release} ${libc/idio-uname.machine} system
 */

#define _GNU_SOURCE

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/times.h>
#include <sys/utsname.h>
#include <sys/wait.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <ffi.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "gc.h"
#include "idio.h"

#include "c-type.h"
#include "error.h"
#include "evaluate.h"
#include "fixnum.h"
#include "handle.h"
#include "hash.h"
#include "idio-string.h"
#include "job-control.h"
#include "libc-wrap.h"
#include "module.h"
#include "pair.h"
#include "path.h"
#include "string-handle.h"
#include "symbol.h"
#include "util.h"
#include "vm.h"

#include "libc-api.h"

}

		api-i-bn := sprintf "%s.idio" api-bn
		api-i-fn := sprintf "%s/%s" gen-dn api-i-bn
		api-i-fh := open-output-file api-i-fn

		hprintf api-i-fh #S{

;;
;; ${api-i-bn}
;;
;; This file was generated by ${PROGNAME} on a ${libc/idio-uname.sysname} ${libc/idio-uname.release} ${libc/idio-uname.machine} system
;;

}

		base-DIE := hash-ref all-ids base-id #f
		used-ids := (make-hash)
		used-types-a := #[]
		used-enumeration-types-a := #[]
		used-structure-types := #[]
		used-union-types := #[]

		used-symbols := (make-hash)

		define (add-DIE id) {
		  if (and id
			  (not (hash-exists? used-ids id))) {
			    DIE := hash-ref all-ids id #f
			    if DIE {
			      (case (hash-ref DIE 'tag #f)
				    ((restrict_type const_type) {
				      add-DIE (hash-ref DIE 'type #f)
				    })
				    ((pointer_type) {
				      add-DIE (hash-ref DIE 'type #f)
				    })
				    ((typedef) {
				      add-DIE (hash-ref DIE 'type #f)
				      hash-set! used-ids id DIE
				      array-push! used-types-a DIE
				    })
				    ((structure_type) {
				      hash-set! used-ids id DIE
				      array-push! used-structure-types DIE

				      members := hash-ref DIE 'member #f
				      if members {
					m* := array->list members
					for-each (function (member) {
						    add-DIE (hash-ref member 'type #f)
					}) m*
					hash-set! DIE 'members m*
				      } {
					hash-set! DIE 'members #n
				      }
				    })
				    ((union_type) {
				      hash-set! used-ids id DIE
				      array-push! used-union-types DIE

				      members := hash-ref DIE 'member #f
				      if members {
					m* := array->list members
					for-each (function (member) {
						    add-DIE (hash-ref member 'type #f)
					}) m*
					hash-set! DIE 'members m*
				      } else {
					hash-set! DIE 'members #n
				      }
				    })
				    ((array_type) {
				      add-DIE (hash-ref DIE 'type #f)
				    })
				    ((enumeration_type) {
				      hash-set! used-ids id DIE
				      array-push! used-enumeration-types-a DIE

				      enumerators := hash-ref DIE 'enumerator #f
				      if enumerators {
					e* := array->list enumerators
					hash-set! DIE 'enumerators e*
				      } {
					hash-set! DIE 'enumerators #n
				      }
				    }))
			    }
			  }
		}

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;
		;; discover all used types

		subprograms := hash-ref base-DIE 'subprogram #f
		if subprograms {

		  define (variables DIE) {
		    variables := hash-ref DIE 'variable #f
		    if variables {
		      v* := array->list variables
		      for-each (function (DIE) {
				  add-DIE (hash-ref DIE 'type #f)
		      }) v*
		      hash-set! DIE 'variables v*
		    } else {
		      hash-set! DIE 'variables #n
		    }
		  }

		  define (lexical-blocks DIE) {
		    lexical_blocks := hash-ref DIE 'lexical_block #f
		    if lexical_blocks {
		      lb* := array->list lexical_blocks
		      for-each (function (DIE) {
				  variables DIE
				  lexical-blocks DIE
		      }) lb*
		      hash-set! DIE 'lexical_blocks lb*
		    } else {
		      hash-set! DIE 'lexical_blocks #n
		    }
		  }

		  for-each (function (DIE) {
			      DIE-name := hash-ref DIE 'name #f
			      if (not (equal? DIE-name "main")) {
				add-DIE (hash-ref DIE 'type #f)

				formal_parameters := hash-ref DIE 'formal_parameter #f
				if formal_parameters {
				  fp* := array->list formal_parameters
				  for-each (function (DIE) {
					      add-DIE (hash-ref DIE 'type #f)
				  }) fp*
				  hash-set! DIE 'formal_parameters fp*
				} {
				  hash-set! DIE 'formal_parameters #n
				}
			      }

			      ;; immediate variables -- distinguishing
			      ;; main from any other subprograms
			      variables DIE

			      ;; lexical blocks
			      lexical-blocks DIE
		  }) (array->list subprograms)
		} {
		  printf "no subprograms\n"
		}

		;; we walk over arrays several times to convert to a
		;; list once
		used-types := array->list used-types-a
		used-enumeration-types := array->list used-enumeration-types-a

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;
		;; base_types information in C header

		base-types := hash-ref base-DIE 'base_type #f
		if base-types {
		  hprintf api-h-fh #S{
/*
 * For reference, this system/API uses these base_types:
 *
}
		  for-each (function (DIE) {
			      DIE-name := hash-ref DIE 'name #f
			      DIE-bytes := hash-ref DIE 'byte_size #f
			      hprintf api-h-fh " * %-30s %2s bytes\n" DIE-name DIE-bytes
		  }) (array->list base-types)
		  hprintf api-h-fh #S{
 *
 * Pointer size                    ${pointer-size} bytes
*/

}
		} {
		  printf "no base types\n"
		}

		exporting := #t

		if (or (pair? used-types)
		       (pair? used-enumeration-types)) {

			 ;; Idio exports
			 hprintf api-i-fh #S{
export \(
}
			 exporting = #t
		       }

		if (pair? used-types) {

		  prev-file := #f
		  for-each (function (DIE) {
			      DIE-type-id := hash-ref DIE 'type #f
			      if (not (alloc-required? DIE-type-id)) {
				decl-file := hash-ref DIE 'decl_file #f
				if (and decl-file
					(not (equal? decl-file prev-file))) {
					  hprintf api-i-fh "\n\t;; %s\n" (filename decl-file)
					  prev-file = decl-file
				}
				;; Idio C type constructor alias
				hprintf api-i-fh "\t%s\n" (get/create DIE 'i-type-alias)
				;; Idio predicate
				hprintf api-i-fh "\t%s\n" (get/create DIE 'i-pred-name)
			      }
		  }) used-types

		}

		if (pair? used-enumeration-types) {

		    for-each (function (DIE) {
				decl-file := hash-ref DIE 'decl_file #f
				if decl-file {
				  hprintf api-i-fh "\n\t;; %s\n" (filename decl-file)
				}
				DIE-name := hash-ref DIE 'name #f
				if DIE-name {
				  hprintf api-i-fh "\t;; enum %s\n" DIE-name
				}
				for-each (function (DIE) {
					    DIE-name := hash-ref DIE 'name #f
					    ;; Idio name
					    ;;
					    ;; NB commented out
					    ;; (problems with
					    ;; bootstrap)
					    hprintf api-i-fh "\t;%s\n" DIE-name
				}) (hash-ref DIE 'enumerators #n)
		    }) used-enumeration-types

		} {
		  printf "no enumeration_types\n"
		}

		if exporting {
		  hprintf api-i-fh #S{
\)
}
		}

		if (pair? used-types) {

		  ;; handy USER-supplied argument type assertion --
		  ;; we'll #define the cascade of idio_isa_libx_y
		  ;; names in a moment which should eventually resolve
		  ;; into an idio_isa_C_z name.
		  hprintf api-h-fh #S{
#define IDIO_USER_${c-module-name}_TYPE_ASSERT(t,x)	\{						\\
	if (! idio_isa_${c-module-name}_ ## t (x)) \{						\\
	    idio_error_param_type_C ("${i-module-name}/" #t, x, __FILE__, __func__, __LINE__);	\\
	\}										\\
    \}

}

		  ;; We want to generate a mapping from us to the next
		  ;; type down the chain, commonly:
		  ;;
		  ;; pid_t --> __pid_t --> int/long
		  ;;
		  ;; We don't want to do that for anything we need to
		  ;; allocate (pointers, structures, unions etc.).
		  ;;
		  ;; Careful, though.  Some of these have no 'type
		  ;; (ie. are void) and we can skip those.

		  prev-file := #f
		  for-each (function (DIE) {
			      DIE-type-id := hash-ref DIE 'type #f
			      DIE-type-DIE := #f
			      if DIE-type-id {
				DIE-type-DIE = hash-ref all-ids DIE-type-id #f
			      }
			      if DIE-type-DIE {
				if (alloc-required? DIE-type-id) {
				  DIE-name := hash-ref DIE 'name #f
				  DIE-type-name := c-type DIE-type-id
				  printf "%-30s -> %s*\n" DIE-name DIE-type-name
				} {
				  printing := #f
				  decl-file := hash-ref DIE 'decl_file #f
				  if (and decl-file
					  (not (equal? decl-file prev-file))) {
					    hprintf api-i-fh "\n;; %s\n" (filename decl-file)
					    prev-file = decl-file
					    printing = #t
					  }
				  ;; Idio alias for C type construction
				  hprintf api-i-fh "%-34s := %s\n" (get/create DIE 'i-type-alias) (get/create DIE-type-DIE 'i-type-alias)

				  ;; Idio predicate
				  hprintf api-i-fh "define %-30s %s\n" (get/create DIE 'i-pred-name) (get/create DIE-type-DIE 'i-direct-pred-name)
				  ;; blank line!
				  hprintf api-i-fh "\n"

				  ;; C header
				  if printing {
				    hprintf api-h-fh "/* %s */\n" (filename decl-file)
				  }
				  ; Idio C MACRO TYPE
				  hprintf api-h-fh "#define %-35s %s\n" (get/create DIE 'idio-c-macro-type) (get/create DIE-type-DIE 'idio-c-macro-type)
				  ; constructor
				  hprintf api-h-fh "#define %-35s %s\n" (get/create DIE 'c-type-constructor) (get/create DIE-type-DIE 'c-type-constructor)
				  ; accessor
				  hprintf api-h-fh "#define %-35s %s\n" (get/create DIE 'c-type-accessor) (get/create DIE-type-DIE 'c-type-accessor)
				  ; predicate
				  hprintf api-h-fh "#define %-35s %s\n" (get/create DIE 'c-type-predicate) (get/create DIE-type-DIE 'c-type-predicate)
				  ;; blank line!
				  hprintf api-h-fh "\n"
				}
			      }
		  }) used-types

		} {
		  printf "no typedefs\n"
		}

		if used-structure-types {

		  ;; setter commentary
		  hprintf api-i-fh #S{

;; These function? tests are primarily for the libc API where the C
;; file is fixed and edited from the generated code.  ${PROGNAME}
;; doesn't know how it has been edited other than to check that the
;; primitives exist.
;;		    
;; It should do no harm for other APIs.

}

		  for-each (function (struct) {
			      struct-name := "struct"

			      struct-name := hash-ref struct 'name #f
			      member* := hash-ref struct 'members #n

			      ;; informational comment
			      hprintf api-c-fh "\n/*\n"
			      decl-file := hash-ref struct 'decl_file #f
			      if decl-file {
				hprintf api-c-fh "\t%s\n\n" (filename decl-file)
			      }
			      hprintf api-c-fh "\tstruct"

			      if struct-name {
				hprintf api-c-fh " %s\n" struct-name
			      }
			      hprintf api-c-fh "\t{\n"

			      for-each (function (member) {
					  member-type-id := hash-ref member 'type #f
					  member-type-name := c-type member-type-id
					  if member-type-name {
					    member-name := hash-ref member 'name #f
					    if member-name {
					      hprintf api-c-fh "\t  %-20s %s;\n" member-type-name member-name
					    } {
					      hprintf api-c-fh "\t  %-20s -anon-;\n" member-type-name
					    }
					  }
			      }) member*

			      hprintf api-c-fh "\t};\n*/\n\n"


			      if struct-name {
				struct-idio-id := Idio-identifier struct-name
				struct-c-id := sprintf "%s_struct_%s" c-module-name struct-name

				;; symbols for accessors

				if (pair? member*) {
				  if decl-file {
				    hprintf api-h-fh "\n/* %s */\n" (filename decl-file)
				  }
				  hprintf api-h-fh "extern IDIO_C_STRUCT_IDENT_DECL (%s);\n" struct-c-id
				  hprintf api-c-fh "IDIO_C_STRUCT_IDENT_DECL (%s);\n" struct-c-id
				  for-each (function (member) {
					      member-type-id := hash-ref member 'type #f
					      member-type-name := idio-c-type-name member-type-id
					      if member-type-name {
						member-name := hash-ref member 'name #f
						if member-name {
						  if (not (hash-exists? used-symbols member-name)) {
						    ;; use #f here and upgrade to #t later
						    hash-set! used-symbols member-name #f
						    hprintf api-h-fh "extern IDIO_SYMBOL_DECL (%s);\n" member-name
						    hprintf api-c-fh "IDIO_SYMBOL_DECL (%s);\n" member-name
						  } {
						    hprintf api-h-fh "/* %s already declared */\n" member-name
						    hprintf api-c-fh "/* %s already declared */\n" member-name
						  }
						}
					      }
				  }) member*

				  var := sprintf "%s" struct-name
				  varp := sprintf "%sp" var

				  ;; -ref
				  hprintf api-c-fh #S{
IDIO_DEFINE_PRIMITIVE2_DS ("struct-${struct-idio-id}-ref", ${c-module-name}_struct_${struct-name}_ref, (IDIO ${var}, IDIO member), "${var} member", "\\
in C, ${var}->member			\\n\\
					\\n\\
:param ${var}: C struct ${struct-name}	\\n\\
:type ${var}: C/pointer		\\n\\
:param member: C struct member		\\n\\
:type member: symbol			\\n\\
:return: ${struct-name}->member		\\n\\
:rtype:	varies on member		\\n\\
")
\{
    IDIO_ASSERT (${var});
    IDIO_ASSERT (member);
}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-ref-bad-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-ref #t #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

				  hprintf api-c-fh #S{
    /*
     * Test Case: ${tc-bn}
     *
     * ${tc-test}
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, ${var});
    if (idio_CSI_${struct-c-id} != IDIO_C_TYPE_POINTER_PTYPE (${struct-name})) \{}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-ref-invalid-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-ref libc/NULL #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "struct-${struct-idio-id}-ref ${struct-name}='#<C/*>' a C/pointer is not a C struct ${struct-name}"}

				  hprintf api-c-fh #S{
	/*
	 * Test Case: ${tc-bn}
	 *
	 * ${tc-test}
	 */
	idio_error_param_value_msg ("struct-${struct-idio-id}-ref", "${struct-name}", ${var}, "C struct ${struct-name}", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    \}}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-ref-bad-member-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-ref v #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "member should be a symbol"}

				  hprintf api-c-fh #S{

    /*
     * Test Case: ${tc-bn}
     *
     * ${tc-test}
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    struct ${struct-name} *${varp} = IDIO_C_TYPE_POINTER_P (${var});
}


				  first := #t
				  for-each (function (member) {
					      member-type-id := hash-ref member 'type #f
					      member-type-DIE := hash-ref all-ids member-type-id #f
					      member-c-type-name := get/create member-type-DIE 'c-type-name
					      if member-c-type-name {
						member-name := hash-ref member 'name #f
						if member-name {
						  if first {
						    first = #f
						    hprintf api-c-fh "    "
						  } {
						    hprintf api-c-fh " else "
						  }

						  if (alloc-required? member-type-id) {
						    member-alloc-name := get/create member-type-DIE 'c-alloc-type-name
						    if member-alloc-name {
						      (regex-case member-alloc-name
								  ("(.*)\\[]" {
								    hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
        /*
         * WARNING:
         * ${member-c-type-name} ${member-name}
         *
         * sizeof (${varp}->${member-name}) is probably incorrect
         *
         * check the API
         */
        size_t alen = sizeof (${varp}->${member-name});
        ${r.1} *rp = (${r.1} *) idio_alloc (alen);
        memcpy ((void *) rp, (void *) &${varp}->${member-name}, alen);
    \}}
								  })
								  (".*\\*" {
								    hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
        /*
         * WARNING:
         * ${member-c-type-name} ${member-name}
         *
         * sizeof (${varp}->${member-name}) is dubious
         *
         * check the API
         */
        size_t slen = sizeof (${varp}->${member-name});
        ${member-alloc-name} rp = (${member-alloc-name}) idio_alloc (slen);
        memcpy ((void *) rp, (void *) &${varp}->${member-name}, slen);
    \}}
								  })
								  (else {
								    hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
        ${member-c-type-name} *rp = (${member-c-type-name} *) idio_alloc (sizeof (${member-c-type-name}));
        memcpy ((void *) rp, (void *) &${varp}->${member-name}, sizeof (${member-c-type-name}));
}
								    if (structure-type? member-type-id) {
								      hprintf api-c-fh #S{
        return idio_C_pointer_type (idio_CSI_${c-module-name}_${C-identifier member-c-type-name}, rp);
}
								    } {
								      hprintf api-c-fh #S{
        return idio_C_pointer_free_me (rp);
}
								    }
								    hprintf api-c-fh #S{
    \}}
								  }))
						    } {
						      hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
#error ${member-c-type-name} ${member-name} is not handled
    \}}
						    }
						  } {
						    constructor := get/create member-type-DIE 'c-type-constructor
						    hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
        return ${constructor} (${varp}->${member-name});
    \}}
						  }
						}
					      }
				  }) member*

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-ref-invalid-member.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-ref v 'not-likely}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "struct-${struct-idio-id}-ref member='notlikely': should be a C struct ${struct-name} member"}

				  hprintf api-c-fh #S{ else \{
	/*
	 * Test Case: ${tc-bn}
	 *
	 * ${tc-test}
	 */
        idio_error_param_value_msg ("struct-${struct-idio-id}-ref", "member", member, "C struct ${struct-name} member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    \}}


				  hprintf api-c-fh #S{

    return idio_S_notreached;
\}
}

				  ;; -set!
				  hprintf api-c-fh #S{
IDIO_DEFINE_PRIMITIVE3_DS ("struct-${struct-idio-id}-set!", ${c-module-name}_struct_${struct-name}_set, (IDIO ${var}, IDIO member, IDIO val), "${var} member val", "\\
in C, ${var}->member = val		\\n\\
					\\n\\
:param ${var}: C struct ${struct-name}	\\n\\
:type ${var}: C/pointer		\\n\\
:param member: C struct member		\\n\\
:type member: symbol			\\n\\
:param val: C/type val			\\n\\
:type val: varies on member		\\n\\
:return: ${struct-name}->member		\\n\\
:rtype:	varies on member		\\n\\
")
\{
    IDIO_ASSERT (${var});
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);

}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-set-bad-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-set! #t #t #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

				  hprintf api-c-fh #S{
    /*
     * Test Case: ${tc-bn}
     *
     * ${tc-test}
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, ${var});
    if (idio_CSI_${struct-c-id} != IDIO_C_TYPE_POINTER_PTYPE (${struct-name})) \{}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-set-invalid-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-set! libc/NULL #t #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "struct-${struct-idio-id}-set! ${struct-name}='#<C/*>' a C/pointer is not a C struct ${struct-name}"}

				  hprintf api-c-fh #S{
	/*
	 * Test Case: ${tc-bn}
	 *
	 * ${tc-test}
	 */
	idio_error_param_value_exp ("struct-${struct-idio-id}-set!", "${struct-name}", ${var}, "C struct ${struct-name}", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    \}
}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-set-bad-member-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-set! v #t #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "member should be a symbol"}

				  hprintf api-c-fh #S{
    /*
     * Test Case: ${tc-bn}
     *
     * ${tc-test}
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    struct ${struct-name} *${varp} = IDIO_C_TYPE_POINTER_P (${var});
}

				  hprintf errors-fh "\n"

				  first := #t
				  for-each (function (member) {
					      member-type-id := hash-ref member 'type #f
					      member-type-DIE := hash-ref all-ids member-type-id #f
					      member-c-type-name := get/create member-type-DIE 'c-type-name
					      member-i-c-type-name := get/create member-type-DIE 'i-c-type-name
					      if member-c-type-name {
						member-name := hash-ref member 'name #f
						if member-name {
						  if first {
						    first = #f
						    hprintf api-c-fh "    "
						  } {
						    hprintf api-c-fh " else "
						  }

						  mod-name := c-module-name
						  if (base-type? member-type-id) {
						    mod-name = "C"
						  }

						  tc-count = tc-count + 1
						  tc-bn := sprintf "%s-errors/struct-%s-set-%s-bad-value-type.idio" i-module-name struct-idio-id member-name
						  tc-fn := sprintf "%s/%s" gen-dn tc-bn
						  tc-fh := open-output-file tc-fn
						  tc-test := #S{struct-${struct-idio-id}-set! v '${member-name} #t}
						  hprintf tc-fh #S{
${tc-test}
}
						  close-handle tc-fh

						  hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
       /*
	* Test Case: ${tc-bn}
	*
	* ${tc-test}
	*/}

						  if (alloc-required? member-type-id) {
						    member-alloc-name := get/create member-type-DIE 'c-alloc-type-name
						    if member-alloc-name {

						      (regex-case member-alloc-name
								  ("(.*)\\[]" {
								    hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

								    hprintf api-c-fh #S{
	IDIO_USER_C_TYPE_ASSERT (pointer, val);

        /*
         * WARNING:
         * ${member-c-type-name} ${member-name}
         *
         * sizeof (${varp}->${member-name}) is possibly incorrect
         *
         * check the API
         */
        ${r.1} *valp = IDIO_C_TYPE_POINTER_P (${val});
        size_t alen = sizeof (${varp}->${member-name});
        memcpy ((void *) &${varp}->${member-name}, (void *) valp, alen);
        return idio_S_unspec;
    \}}
								  })
								  ("(.*)\\*" {
								    hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

								    hprintf api-c-fh #S{
	IDIO_USER_C_TYPE_ASSERT (pointer, val);

        /*
         * WARNING:
         * ${member-c-type-name} ${member-name}
         *
         * sizeof (${varp}->${member-name}) is dubious
         *
         * check the API
         */
        ${member-alloc-name} valp = IDIO_C_TYPE_POINTER_P (${val});
        size_t slen = sizeof (${varp}->${member-name});
        memcpy ((void *) &${varp}->${member-name}, (void *) valp, slen);
        return idio_S_unspec;
    \}}
								  })
								  (else {
								    hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

								    hprintf api-c-fh #S{
	IDIO_USER_C_TYPE_ASSERT (pointer, val);

        ${member-c-type-name} *valp = IDIO_C_TYPE_POINTER_P (${val});
        memcpy ((void *) &${varp}->${member-name}, (void *) valp, sizeof (${member-c-type-name}));
        return idio_S_unspec;
    \}}
								  }))
						    } {
						      hprintf api-c-fh #S{
#error ${member-c-type-name} ${member-name} is not handled
    \}}
						    }
						  } {
						    accessor := get/create member-type-DIE 'c-type-accessor
								    hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a ${mod-name}/${member-i-c-type-name}"}

						    hprintf api-c-fh #S{
	IDIO_USER_${mod-name}_TYPE_ASSERT (${member-i-c-type-name}, val);

        ${varp}->${member-name} = ${accessor} (val);
        return idio_S_unspec;
    \}}
						  }
						}
					      }
				  }) member*

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-set-invalid-member.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-set! v 'not-likely #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				    hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "struct-${struct-idio-id}-set! member='notlikely': should be a C struct ${struct-name} member"}

				  hprintf api-c-fh #S{ else \{
	/*
	 * Test Case: ${tc-bn}
	 *
	 * ${tc-test}
	 */
        idio_error_param_value_exp ("struct-${struct-idio-id}-set!", "member", member, "C struct ${struct-name} member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    \}}

				  hprintf api-c-fh #S{

    return idio_S_notreached;
\}
}

				  ;; C _as_string
				  hprintf api-h-fh #S{
IDIO idio_${struct-c-id}_as_string (struct ${struct-name} *${varp});
}
				  hprintf api-c-fh #S{
IDIO idio_${struct-c-id}_as_string (struct ${struct-name} *${varp})
\{
    IDIO_C_ASSERT (${varp});
}

				  hprintf api-c-fh #S{
    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI ${c-module-name}/struct-${struct-idio-id}", CSI_sh);
}


				  first := #t
				  for-each (function (member) {
					      member-type-id := hash-ref member 'type #f
					      member-type-DIE := hash-ref all-ids member-type-id #f
					      member-c-type-name := get/create member-type-DIE 'c-type-name
					      if member-c-type-name {
						member-name := hash-ref member 'name #f
						if member-name {
						  if first {
						    first = #f
						  hprintf api-c-fh #S{
    char buf[BUFSIZ];
    char *fmt;
}
						  }

						  hprintf api-c-fh #S{
    idio_display_C (" ${member-name}:", CSI_sh);
}

						  if (alloc-required? member-type-id) {
						    member-type-id := hash-ref member 'type #f
						    member-alloc-name := get/create member-type-DIE 'c-alloc-type-name
						    if member-alloc-name {
						      (regex-case member-alloc-name
								  ("(.*)\\[]" {
								    (case member-alloc-name
									  (("char[]") {
									    hprintf api-c-fh #S{
    idio_display_C (${varp}->${member-name}, CSI_sh);
}
									  })
									  (else {
									    hprintf api-c-fh #S{
    idio_display_C ("<<1${member-c-type-name}>>", CSI_sh);
}
									  }))
								  })
								  (".*\\*" {
								    (case member-alloc-name
									  (("char*") {
									    hprintf api-c-fh #S{
    idio_display_C (${varp}->${member-name}, CSI_sh);
}
									  })
									  (else {
									    hprintf api-c-fh #S{
    idio_display_C ("<<2${member-c-type-name}>>", CSI_sh);
}
									  }))
								  })
								  (else {
								    (case member-alloc-name
									  (("XXX") {
									    hprintf api-c-fh #S{
    idio_display_C (${varp}->${member-name}, CSI_sh);
}
									  })
									  (else {
									    (cond
									     ((structure-type? member-type-id) {
									       hprintf api-c-fh #S{
    idio_display (idio_${c-module-name}_${C-identifier member-c-type-name}_as_string (&(${varp}->${member-name})), CSI_sh);
}
									     })
									     (else {
									       hprintf api-c-fh #S{
    idio_display (idio_${c-module-name}_${C-identifier member-c-type-name}_as_string (${varp}->${member-name}), CSI_sh);
}
									     }))
									  }))
								  }))
						    } {
						      hprintf api-c-fh #S{if (idio_S_${member-name} == member) \{
#error ${member-c-type-name} ${member-name} is not handled
    \}}
						    }
						  } {
						    (case member-alloc-name
							  (("XXX") {
							    hprintf api-c-fh #S{
    idio_display_C (${varp}->${member-name}, CSI_sh);
}
							  })
							  (else {
							    member-idio-c-macro-type := get/create member-type-DIE 'idio-c-macro-type
							    hprintf api-c-fh #S{
    fmt = idio_C_type_format_string (${member-idio-c-macro-type});
    idio_snprintf (buf, BUFSIZ, fmt, ${varp}->${member-name});
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);
}
							  }))
						  }
						}
					      }
				  }) member*

				  hprintf api-c-fh #S{
    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
\}
}

				  ;; Idio -as-string
				  hprintf api-c-fh #S{
IDIO_DEFINE_PRIMITIVE1_DS ("struct-${struct-idio-id}-as-string", ${c-module-name}_struct_${struct-name}_as_string, (IDIO ${var}), "${var}", "\\
:param ${var}: C struct ${struct-name}	\\n\\
:type ${var}: C/pointer			\\n\\
:return: string				\\n\\
:rtype:	string				\\n\\
")
\{
    IDIO_ASSERT (${var});
}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-as-string-bad-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-as-string #t}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

				  hprintf api-c-fh #S{
    /*
     * Test Case: ${tc-bn}
     *
     * ${tc-test}
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, ${var});
    if (idio_CSI_${struct-c-id} != IDIO_C_TYPE_POINTER_PTYPE (${struct-name})) \{}

				  tc-count = tc-count + 1
				  tc-bn := sprintf "%s-errors/struct-%s-as-string-invalid-pointer-type.idio" i-module-name struct-idio-id
				  tc-fn := sprintf "%s/%s" gen-dn tc-bn
				  tc-fh := open-output-file tc-fn
				  tc-test := #S{struct-${struct-idio-id}-as-string libc/NULL}
				  hprintf tc-fh #S{
${tc-test}
}
				  close-handle tc-fh

				  hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "struct-${struct-idio-id}-as-string ${struct-name}='#<C/*>' a C/pointer is not a C struct ${struct-name}"}

				  hprintf api-c-fh #S{
	/*
	 * Test Case: ${tc-bn}
	 *
	 * ${tc-test}
	 */
	idio_error_param_value_exp ("struct-${struct-idio-id}-as-string", "${struct-name}", ${var}, "C struct ${struct-name}", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    \}
}

				  hprintf api-c-fh #S{
    return idio_${c-module-name}_struct_${struct-name}_as_string (IDIO_C_TYPE_POINTER_P (${var}));
\}
}

				  ;; setter
				  hprintf api-i-fh #S{
if (and (function? struct-${struct-idio-id}-ref)
        (function? struct-${struct-idio-id}-set!)) {
  set! (setter struct-${struct-idio-id}-ref)	struct-${struct-idio-id}-set!
\}
}
				}
			      }


				    hprintf errors-fh "\n"

		  }


					    ) (array->list used-structure-types)
		} {
		  printf "no structure_types\n"
		}

		if used-union-types {
		    for-each (function (union) {
				union-name := hash-ref union 'name #f
				if union-name {
				  printf "union"
				  printf " %s" union-name
				  printf " {\n"
				  members := hash-ref union 'member #f
				  if members {
				    for-each (function (union) {
						union-type-id := hash-ref union 'type #f
						union-type-name := idio-c-type-name union-type-id
						if union-type-name {
						  union-name := hash-ref union 'name #f
						  printf "  %-20s %s\n" union-type-name union-name
						}
				    }) (array->list members)
				  }
				  printf "};\n"
				}
		    }) (array->list used-union-types)

		} {
		  printf "no union_types\n"
		}

		if subprograms {

		  for-each (function (sp) {
			      sp-name := hash-ref sp 'name #f
			      sp-type-id := hash-ref sp 'type #f
			      sp-type-DIE := hash-ref all-ids sp-type-id #f
			      sp-c-type-name := "void"
			      sp-c-type-constructor := #f
			      sp-i-direct-type-name := "void"
			      if sp-type-DIE {
				sp-c-type-name = get/create sp-type-DIE 'c-type-name
				sp-c-type-constructor = get/create sp-type-DIE 'c-type-constructor
				sp-i-direct-type-name = get/create sp-type-DIE 'i-direct-type-name
			      }

			      if (not (equal? sp-name "main")) {
				formal_parameters := hash-ref sp 'formal_parameter #f
				fpc := 0
				fp* := #n
				i-arg-name* := #n
				if formal_parameters {
				  fpc = array-length formal_parameters
				  fp* = array->list formal_parameters
				  hash-set! sp 'formal_parameters fp*

				  pc := 0
				  i-arg-name* = map (function (fp) {
						       pc = pc + 1
						       hash-ref fp 'name (sprintf "arg%d" pc)
				  }) fp*
				}

				c-arg-name* := map (function (arg) #S{C_${arg}}) i-arg-name*
				comma-sep-fp* := join-string ", " (map (function (arg) #S{IDIO ${arg}}) i-arg-name*)
				comma-sep-arg* := join-string ", " i-arg-name*
				comma-sep-c-arg* := join-string ", " c-arg-name*
				space-sep-arg* := join-string " " i-arg-name*

				hprintf api-c-fh #S{
IDIO_DEFINE_PRIMITIVE${fpc}_DS ("${sp-name}", ${lib-n}_${sp-name}, (${comma-sep-fp*}), \"${space-sep-arg*}\", \"\\
in C: ${sp-name} \(${comma-sep-arg*})		\\n\\
}

				hprintf api-c-fh #S{a wrapper to libc ${sp-name}()		\\n\\
					\\n\\}

				pc := 1
				for-each (function (fp) {
					    fp-type-id := hash-ref fp 'type #f
					    fp-type-DIE := hash-ref all-ids fp-type-id
					    fp-type-name := get/create fp-type-DIE 'i-direct-type-name
					    if fp-type-name {
					      fp-name := hash-ref fp 'name (sprintf "arg%d" pc)
					      hprintf api-c-fh #S{
:param ${fp-name}: 				\\n\\
:type ${fp-name}: ${fp-type-name}			\\n\\}
					    }
					    pc = pc + 1
				}) fp*

				hprintf api-c-fh #S{
:return:				\\n\\
:rtype: ${sp-i-direct-type-name}	\\n\\
\"\)
\{
}

				for-each (function (i-arg-name) {
					    hprintf api-c-fh #S{    IDIO_ASSERT (${i-arg-name});
}
				}) i-arg-name*

				dummy-args := ""
				for-each (function (i-arg-name) {
					    dummy-args = append-string dummy-args "#t "
				}) i-arg-name*
				dummy-args = strip-string dummy-args " " 'right

				pc := 1
				for-each (function (fp) {
					    fp-type-id := hash-ref fp 'type #f
					    fp-type-DIE := hash-ref all-ids fp-type-id #f
					    fp-c-type-name := get/create fp-type-DIE 'c-type-name
					    fp-c-type-accessor := get/create fp-type-DIE 'c-type-accessor
					    fp-i-c-type-name := get/create fp-type-DIE 'i-c-type-name
					    if fp-i-c-type-name {
					      fp-name := hash-ref fp 'name (sprintf "arg%d" pc)
					      mod-name := c-module-name
					      if (base-type? fp-type-id) {
						mod-name = "C"
					      }

					      tc-count = tc-count + 1
					      tc-bn := sprintf "%s-errors/%s-bad-%s-type.idio" i-module-name sp-name fp-name
					      tc-fn := sprintf "%s/%s" gen-dn tc-bn
					      tc-fh := open-output-file tc-fn
					      tc-test := #S{${sp-name} ${dummy-args}}
					      hprintf tc-fh #S{
${tc-test}
}
					      close-handle tc-fh

					      hprintf api-c-fh #S{
   /*
    * Test Case: ${tc-bn}
    *
    * ${tc-test}
    */}

					      if (alloc-required? fp-type-id) {
						hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a C/pointer"}

						hprintf api-c-fh #S{
    IDIO_USER_C_TYPE_ASSERT (pointer, ${fp-name});
    ${fp-c-type-name} C_${fp-name} = IDIO_C_TYPE_POINTER_P (${fp-name});
}
					      } {
						hprintf errors-fh #S{
${i-module-name}-error-load "${tc-bn}" "bad parameter type: '#t' a CONSTANT_IDIO is not a ${mod-name}/${fp-i-c-type-name}"}

						hprintf api-c-fh #S{
    IDIO_USER_${mod-name}_TYPE_ASSERT (${fp-i-c-type-name}, ${fp-name});
    ${fp-c-type-name} C_${fp-name} = ${fp-c-type-accessor} (${fp-name});
}
					      }
					    }
					    pc = pc + 1
				}) fp*

				;; make the API call!
				if (equal? sp-c-type-name "void") {
				  hprintf api-c-fh #S{
    ${sp-name} \(${comma-sep-c-arg*}\);
}
				} {
				  hprintf api-c-fh #S{
    ${sp-c-type-name} ${sp-name}_r = ${sp-name} \(${comma-sep-c-arg*}\);

    /* check for errors */
    if (-1 == ${sp-name}_r) \{
        idio_error_system_errno ("${sp-name}", idio_S_nil, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    \}

}
				}

				hprintf api-c-fh #S{
    /*
     * WARNING: this is probably an incorrect return
     */}

				(cond
				 ((equal? sp-c-type-name "void") {
				   hprintf api-c-fh #S{
    return idio_S_unspec;
}
				 })
				 ((pointer-type? sp-type-id) {
				   hprintf api-c-fh #S{
    return idio_C_pointer_free_me (${sp-name}_r);
}
				 })
				 (else {
				   hprintf api-c-fh #S{
    return ${sp-c-type-constructor} (${sp-name}_r);
}
				 }))

				hprintf api-c-fh #S{
\}
}
			      }

			      hprintf errors-fh "\n"

		  }) (array->list subprograms)

		  ;; C add_primitives
		  hprintf api-h-fh #S{
void idio_${c-module-name}_api_add_primitives ();
}

	      hprintf api-c-fh #S{
void idio_${c-module-name}_api_add_primitives ()
\{
}

		  if used-structure-types {
		    hprintf api-c-fh #S{    IDIO iuvas = idio_module_symbol_value (idio_util_value_as_string,
					   idio_Idio_module,
					   idio_S_nil);
}

		    for-each (function (struct) {
				struct-name := "struct"

				struct-name := hash-ref struct 'name #f
				if struct-name {
				  hprintf api-c-fh #S{
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_${c-module-name}_module, ${c-module-name}_struct_${struct-name}_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_${c-module-name}_struct_${struct-name},
		   idio_module_symbol_value (idio_symbols_C_intern ("struct-${struct-name}-as-string"),
								   idio_${c-module-name}_module,
								   idio_S_nil));
}
				}
		    }) (array->list used-structure-types)
		  }

		  for-each (function (sp) {
			      sp-name := hash-ref sp 'name #f
			      if (not (equal? sp-name "main")) {
				hprintf api-c-fh #S{    IDIO_EXPORT_MODULE_PRIMITIVE (idio_${c-module-name}_module, ${lib-n}_${sp-name});
}
			      }
		  }) (array->list subprograms)
		  
		  hprintf api-c-fh #S{
\}
}

		}

		;;; C idio_init
		hprintf api-h-fh #S{
void idio_init_${c-module-name}_api ();
}
		hprintf api-c-fh #S{
void idio_init_${c-module-name}_api ()
\{
}

		if (pair? used-enumeration-types) {

		  for-each (function (enum) {
			      decl-file := hash-ref enum 'decl_file #f
 			      if decl-file {
				hprintf api-c-fh "\n    /* %s */\n" (filename decl-file)
			      }
			      enum-name := hash-ref enum 'name #f
			      if enum-name {
				hprintf api-c-fh #S{    /* enum ${enum-name} */
#ifdef ${enum-name}
}
			      }
			      enum-type-id := hash-ref enum 'type #f
			      enum-type-name := idio-c-type-name enum-type-id
			      if enum-type-name {
				for-each (function (etor) {
					    etor-name := hash-ref etor 'name #f
					    ;; C name export
					    hprintf api-c-fh #S{    idio_module_export_symbol_value (idio_symbols_C_intern ("${etor-name}"), idio_C_${enum-type-name} (${etor-name}), idio_${c-module-name}_module);
}
				}) (hash-ref enum 'enumerators #n)

				if enum-name {
				hprintf api-c-fh #S{#endif	/* ${enum-name} */
}
				}
			      }
		  }) used-enumeration-types

		} {
		  printf "no enumeration_types\n"
		}

		if used-structure-types {
		  hprintf api-c-fh "\n    IDIO fgvi;\n" struct-c-id
		  for-each (function (struct) {
			      struct-name := hash-ref struct 'name #f

			      if struct-name {
				struct-c-id := sprintf "%s_struct_%s" c-module-name struct-name
				members := hash-ref struct 'member #f
				if members {
				  decl-file := hash-ref struct 'decl_file #f
 				  if decl-file {
				    hprintf api-c-fh "\n    /* %s */\n" (filename decl-file)
				  }
				  for-each (function (member) {
					      member-name := hash-ref member 'name #f
					      if member-name {
						if (not (hash-ref used-symbols member-name #t)) {
						  hash-set! used-symbols member-name #t
						  hprintf api-c-fh "    IDIO_SYMBOL_DEF (\"%s\", %s);\n" member-name member-name
						} {
						  hprintf api-c-fh "    /* %s already declared */\n" member-name
						}
					      }
				  }) (array->list members)
				}
				hprintf api-c-fh #S{
    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_${c-module-name}_module, ${c-module-name}_struct_${struct-name}_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct ${struct-name}", ${c-module-name}_struct_${struct-name}, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_${c-module-name}_module, ${c-module-name}_struct_${struct-name}_set);
}
			      }
		  }) (array->list used-structure-types)
		} {
		  printf "no structure_types\n"
		}


		hprintf api-c-fh #S{
\}
}

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;
		;; end of file statements

		hprintf api-h-fh #S{
#endif /* ${api-h-define} */
}

		hprintf errors-fh #S{

;; all done?
Tests? (${i-module-name}-error0 + ${tc-count})
}

		close-handle api-c-fh
		close-handle api-h-fh
		close-handle api-i-fh

	      }
	    }
}) (array->list ARGV)

;Local Variables:
;mode: Idio
;buffer-file-coding-system: utf-8-unix
;End:
