;;
;; Copyright (c) 2021-2022 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-expect.idio
;;

module tests/expect

import expect

expect-0 := Tests

exp-log-user #f
exp-timeout = 10

;; EOF in clauses
spawn auto-exit

(exp-case
 (:eof {
   test #t #t
 }))

(exp-wait)

;; EOF in exp-case-before
(exp-case-before
 (:eof {
   test #t #t
 }))

spawn auto-exit

(exp-case)

(exp-wait)

(exp-case-before)

;; EOF in exp-case-after
(exp-case-after
 (:eof {
   test #t #t
 }))

spawn auto-exit

(exp-case)

(exp-wait)

;; XXX leave :eof in exp-case-after for a "free" test when the spawned
;; process exits -- assuming we can exp-continue

;; read from program
spawn auto-exit -o 1

(exp-case
 (:re "wrote line ([[:digit:]]) to stdout" {
   test r.1 .1 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program using variables
spawn auto-exit -o 1

re := "wrote line ([[:digit:]]) to stdout"
(exp-case
 (:re re {
   test r.1 .1 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program with a timeout
spawn auto-exit -o 2 -s 2
exp-timeout = 1

;; XXX there is a race condition here in that it is possible to get
;; two 1s :timeout matches waiting for the program to output lines 2s
;; apart.  We can work around this by stopping after the first
;; :timeout and reverting to the more common timeout of 10s.

;; Nobody said this would be Art.

(exp-case
 ("wrote line 1 to stdout" {
   test #t #t
   (exp-continue)
 })
 (:timeout {
   test #t #t
 }))

exp-timeout = 10

(exp-case
 ("wrote line 2 to stdout" {
   test #t #t
   (exp-continue)
 })
 (:timeout {
   ;; shouldn't get here
   test "unexpected timeout clause" #t
 }))

(exp-wait)

;; write to a program: here, -v will report the line back to us
spawn auto-exit -r 3 -v

exp-send "hello" :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "1"
   test r.2 .1 "hello"
   ;(exp-continue)
 }))

exp-send "world" :slow #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "2"
   test r.2 .1 "world"
   ;(exp-continue)
 }))

exp-send "hello world" :human #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "3"
   test r.2 .1 "hello world"
   (exp-continue)
 }))

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-case return value

spawn auto-exit -o 10

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test #t #t
 }))

test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; dynamic scope before and after tests
;;
;; same before and after at the top-level

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test #t #t
 }))

{
  ;; new before and after on the inside
  (exp-case-before
   ("wrote" 'match-inside-before))

  (exp-case-after
   ("wrote" 'match-inside-after)
   (:eof {
     test #t #t
   }))

  test (exp-case
	("wrote" 'match-case)) 'match-inside-before

  (exp-case-before)

  test (exp-case
	("wrote" 'match-case)) 'match-case

  test (exp-case) 'match-inside-after
}

;; check we have reverted to top-level
test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-close/exp-wait mid-session -- exp-wait should be identical to
;; exp-close

;; exp-close before we start
spawn echo "foo"
(exp-close)
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-close mid-session
spawn echo "foo"
(exp-case
 ("f" (exp-close)))
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-wait before we start
spawn echo "foo"
(exp-wait)
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-wait mid-session
spawn echo "foo"
(exp-case
 ("f" (exp-wait)))
test (exp-case (:eof #t)) #f
(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-wait with blocked processes -- we expect[sic] to have exp-wait
;; return in these examples though in general YMMV

;; NB. read something to ensure the spawned process has actually
;; started

;; auto-exit blocking on stdin
spawn auto-exit -o 1 -r 1
(exp-case ("stdout" #t))
(exp-wait)

;; blocking on stdout (assuming the terminal hasn't buffered
;; everything)

;; This was originally the equivalent of "PAGER=cat man bash" but
;; OpenBSD's man(1) seemed to do something weird that I don't have the
;; skills to debug.  In the meanwhile, the basic premise for the test
;; is the spawned process blocking on stdout because of a lot of data
;; for which "cat file" suffices.  The contents of file?  man bash, of
;; course.
man bash > testfile
spawn cat testfile
(exp-case ("." #t))
(exp-wait)
rm testfile

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; spawn-id is a list
spawn-id = #n

;; a list of one spawn-id
spawn echo "foo"
(exp-case
 ("o" {
   test prefix "f"
 }))
(exp-wait)

;; a list of two spawn-ids -- we'll plod through one step at a time
spawn-id = #n

spawn echo "foo"
spawn echo "bar"

;; exp-case will cause a single read from each spawned process --
;; hopefully the terminal can buffer the four output characters from
;; each echo

;; match something from one of them -- which one depends on operating
;; system scheduling
(exp-case
 ("oo" {
   test prefix "f"
 })
 ("ar" {
   test prefix "b"
 }))

;; match the other using the same clauses
(exp-case
 ("oo" {
   test prefix "f"
 })
 ("ar" {
   test prefix "b"
 }))

;; At this point, we shouldn't have required a second read from the
;; terminal for either process as both of the previous matches could
;; be satisfied from the initial read.  Consequently, we will not have
;; generated any End of File indications.  Let's force the issue.

;; get both EOF
(exp-case
 (:eof {
   test #t #t				; twice
 }))

(exp-wait)

;; a list of two spawn-ids -- this time we'll crash through everything
;; at once by calling exp-continue
spawn-id = #n

spawn echo "foo"
spawn echo "bar"

;; madness...
(exp-case
 ("oo" {
   test prefix "f"			; once
   (exp-continue)
 })
 ("ar" {
   test prefix "b"			; once
   (exp-continue)
 })
 (:eof {
   test #t #t				; twice

   ;; No (exp-continue) as we'll be called twice for these simple
   ;; processes.  Hopefully.
 }))

(exp-wait)

;; What if we forget to clear spawn-id?  Let's run through the same
;; again with the previous spawn-ids still in the list.
spawn echo "foo"
spawn echo "bar"

;; madness...
(exp-case
 ("oo" {
   test prefix "f"			; once
   (exp-continue)
 })
 ("ar" {
   test prefix "b"			; once
   (exp-continue)
 })
 (:eof {
   test #t #t				; twice

   ;; No (exp-continue) as we'll be called twice for these simple
   ;; processes.  Hopefully.
 }))

(exp-wait)

;; What if the spawned processes do not, conveniently, end at the same
;; time?
spawn-id = #n

spawn echo "foo"
spawn auto-exit -r 1

(exp-case
 (:eof {
   test #t #t				; once for the echo
 }))

;; send a message to auto-exit, at the head of the list
exp-send "hello" :cr #t :spawn-id (ph spawn-id)

(exp-case
 (:eof {
   test #t #t				; once for auto-exit
 }))

(exp-wait)

;; normal spawn-id behaviour resumes
spawn-id = #f

;; all done?
Tests? (expect-0 + 46)

;Local Variables:
;mode: Idio
;coding: utf-8-unix
;End:
