;;
;; Copyright (c) 2021-2022 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-expect.idio
;;

module tests/expect

import expect

expect-0 := Tests

exp-log-user #f
exp-timeout = 10

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; EOF in clauses
spawn auto-exit

(exp-case
 (:eof {
   test 'eof 'eof
 }))

(exp-wait)

;; EOF in exp-case-before
(exp-case-before
 (:eof {
   test 'eof-before 'eof-before
 }))

spawn auto-exit

(exp-case)

(exp-wait)

(exp-case-before)

;; EOF in exp-case-after
(exp-case-after
 (:eof {
   test 'eof-after 'eof-after
 }))

spawn auto-exit

(exp-case)

(exp-wait)

;; XXX leave :eof in exp-case-after for a "free" test when the spawned
;; process exits -- assuming we can exp-continue

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; read from program
spawn auto-exit -o 1

(exp-case
 (:re "wrote line ([[:digit:]]) to stdout" {
   test r.1 .0 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program using variables
spawn auto-exit -o 1

re := "wrote line ([[:digit:]]) to stdout"
(exp-case
 (:re re {
   test r.1 .0 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program with a timeout
spawn auto-exit -o 2 -s 2
exp-timeout = 1

;; XXX there is a race condition here in that it is possible to get
;; two 1s :timeout matches waiting for the program to output lines 2s
;; apart.  We can work around this by stopping after the first
;; :timeout and reverting to the more common timeout of 10s.

;; Nobody said this would be Art.

(exp-case
 ("wrote line 1 to stdout" {
   test 'line1 'line1
   (exp-continue)
 })
 (:timeout {
   test 'timeout 'timeout
 }))

exp-timeout = 10

(exp-case
 ("wrote line 2 to stdout" {
   test 'line2 'line2
   (exp-continue)
 })
 (:timeout {
   ;; shouldn't get here
   test "unexpected timeout clause" #t
 }))

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; write to a program: here, -v will report the line back to us
spawn auto-exit -r 3 -v

exp-send "hello" :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .0 "1"
   test r.2 .0 "hello"
   ;(exp-continue)
 }))

exp-send "world" :slow #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .0 "2"
   test r.2 .0 "world"
   ;(exp-continue)
 }))

exp-send "hello world" :human #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .0 "3"
   test r.2 .0 "hello world"
   (exp-continue)
 }))

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-case return value

spawn auto-exit -o 10

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test 'eof-after 'eof-after
 }))

test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; dynamic scope before and after tests
;;
;; same before and after at the top-level

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test 'eof-after 'eof-after
 }))

{
  ;; new before and after on the inside
  (exp-case-before
   ("wrote" 'match-inside-before))

  (exp-case-after
   ("wrote" 'match-inside-after)
   (:eof {
     test 'eof-after 'eof-after
   }))

  test (exp-case
	("wrote" 'match-case)) 'match-inside-before

  (exp-case-before)

  test (exp-case
	("wrote" 'match-case)) 'match-case

  test (exp-case) 'match-inside-after
}

;; check we have reverted to top-level
test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

(exp-wait)

;; revert exp-case-after to its "free" test
(exp-case-after
 (:eof {
   test 'eof-after 'eof-after
 }))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-close/exp-wait mid-session -- exp-wait should be identical to
;; exp-close

;; exp-close before we start
spawn echo "foo"
(exp-close)
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-close mid-session
spawn echo "foo"
(exp-case
 ("f" (exp-close)))
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-wait before we start
spawn echo "foo"
(exp-wait)
test (exp-case (:eof #t)) #f
(exp-wait)

;; exp-wait mid-session
spawn echo "foo"
(exp-case
 ("f" (exp-wait)))
test (exp-case (:eof #t)) #f
(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-wait with blocked processes -- we expect[sic] to have exp-wait
;; return in these examples though in general YMMV

;; NB. read something to ensure the spawned process has actually
;; started

;; auto-exit blocking on stdin
spawn auto-exit -o 1 -r 1
(exp-case ("stdout" #t))
(exp-wait)

;; blocking on stdout (assuming the terminal hasn't buffered
;; everything)

;; This was originally the equivalent of "PAGER=cat man bash" but
;; OpenBSD's man(1) seemed to do something weird that I don't have the
;; skills to debug.  In the meanwhile, the basic premise for the test
;; is the spawned process blocking on stdout because of a lot of data
;; for which "cat file" suffices.  The contents of file?  It was "man
;; bash" until I realised that man was doing strange things even on
;; sensible systems (and truncating the output because it was being
;; run in a tty and therefore interactive...)  let alone that NetBSD
;; didn't have the man page on my MANPATH.
;;
;; So, a large file, big enough to block a tty's buffer?
;; utils/Unicode/UnicodeData.txt is 1.8MB, that should do.
cp (append-string IDIO-UTILS-DIR "/Unicode/UnicodeData.txt") testfile

spawn cat testfile
(exp-case (:re "." #t))
(exp-wait)

;; Tease the read-poll function in exp-case-poll (which uses a chunk
;; size of 1024 for libc/read) by reading a little below and a little
;; above that number -- we might get an EIO if things go wrong.
;;
;; We have to be careful here as we only want exactly n output bytes
;; to the tty and no extraneous blether from, say, dd, which will also
;; appear in the tty output.
;;
;; Original: More importantly, why do we centre on 1003 +/- 1 when
;; we're looking for 1024 output chars?  Why, ttys or, rather,
;; termios(3), of course.  The tty has ONLCR enabled by default which
;; means the newlines in the input file (being cat'ed to the terminal)
;; are translated to CR-NL, in other words an extra character per
;; line.  The 1003 bytes we read from the input file contain the first
;; 21 lines and therefore an extra 21 chars taking us to 1024.
;;
;; Ideally, we should disable onlcr.
define (seq c r) {
  l := #n
  (do
   ((i (c - r) (i + 1)))
   ((i gt (c + r)) (reverse! l))
  (l = pair i l))
}

;; dd is, by default, a bit chatty about what it has done which is all
;; well and good but we don't know what it is about to say and because
;; that chat also appears in the terminal it messes withour test.  So,
;; where possible, shut dd up.
;;
;; Where it is not possible, the test is pointless.
dd-args := #f
(cond-expand
 ("release/OpenIndiana"
  ;; We're a bit stuffed, here, as there is no argument to stop dd
  ;; printing stats and IO redirection isn't picked up (as we're not
  ;; spawning a shell...)
  #t)
 ("uname/sysname/NetBSD" {
   dd-args = "msgfmt=quiet"
 })
 ("uname/sysname/Darwin" {
   ;; Newer macOS support status=none, older (Mac OS X 10.15.7) does
   ;; not.  We can take a look at sw_vers
   ph := pipe-from sw_vers
   line-loop :+ function () {
     if (eof? ph) #n {
       (regex-case
	(read-line ph)
	("ProductVersion:[[:space:]]+([[:digit:]]+)\\." {
	  PV := read-number r.1
	  if (PV gt 10) {
	    dd-args = "status=none"
	  }
	}))
       (line-loop)
     }
   }
   (line-loop)
   close-handle ph
 })
 (else {
   dd-args = "status=none"
 }))

if dd-args {
  for size in (seq 1003 1) {
    spawn dd (sprintf "if=%s" testfile) bs=1 (sprintf "count=%d" size) dd-args
    (exp-case
     ("0" #t))
    (exp-wait)
  }

  rm testfile
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; spawn-id is a list
spawn-id = #n

;; a list of one spawn-id
spawn echo "FOO"
(exp-case
 ("O" {
   test prefix "F"
 }))
(exp-wait)

;; a list of two spawn-ids -- we'll plod through one step at a time
spawn-id = #n

spawn echo "foo"
spawn echo "bar"

(exp-spawn-sync)

;; exp-case will cause a single read from each spawned process --
;; hopefully the terminal can buffer the four output characters from
;; each echo

;; match something from one of them -- which one depends on operating
;; system scheduling
(exp-case
 ("oo" {
   test prefix "f"
 })
 ("ar" {
   test prefix "b"
 }))

;; match the other using the same clauses
(exp-case
 ("oo" {
   test prefix "f"
 })
 ("ar" {
   test prefix "b"
 }))

;; At this point, we shouldn't have required a second read from the
;; terminal for either process as both of the previous matches could
;; be satisfied from the initial read.  Consequently, we will not have
;; generated any End of File indications.  Let's force the issue.

;; get both EOF
(exp-case
 (:eof {
   test 'eof*2 'eof*2				; twice
 }))

(exp-wait)

;; a list of two spawn-ids -- this time we'll crash through everything
;; at once by calling exp-continue
spawn-id = #n

spawn echo "abc"
spawn echo "def"

(exp-spawn-sync)

;; madness...
(exp-case
 ("bc" {
   test prefix "a"			; once
   (exp-continue)
 })
 ("ef" {
   test prefix "d"			; once
   (exp-continue)
 })
 (:eof {
   test 'eof 'eof			; twice

   ;; No (exp-continue) as we'll be called twice for these simple
   ;; processes.  Hopefully.
 }))

(exp-wait)

;; What if we forget to clear spawn-id?  Let's run through the same
;; again with the previous spawn-ids still in the list.
spawn echo "ijk"
spawn echo "lmn"

(exp-spawn-sync)

;; madness...
(exp-case
 ("jk" {
   test prefix "i"			; once
   (exp-continue)
 })
 ("mn" {
   test prefix "l"			; once
   (exp-continue)
 })
 (:eof {
   test 'eof 'eof			; twice

   ;; No (exp-continue) as we'll be called twice for these simple
   ;; processes.  Hopefully.
 }))

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; What if the spawned processes do not, conveniently, end at the same
;; time?
spawn-id = #n

spawn echo "foo"
spawn auto-exit -r 1

;; XXX the spawn-sync timeout will be hit for the auto-exit because it
;; isn't ever going to be ready to write something out.  Knowing that,
;; we won't wait for it and we can just sync on the previous sids.
exp-spawn-sync (pt spawn-id)

(exp-case
 (:eof {
   test 'eof 'eof			; once for the echo
 }))

;; send a message to auto-exit, at the head of the list
exp-send "hello" :cr #t :spawn-id (ph spawn-id)

(exp-case
 (:eof {
   test 'eof 'eof			; once for auto-exit
 }))

(exp-wait)

;; normal spawn-id behaviour resumes
spawn-id = #f

;; all done?
Tests? (expect-0 + 46)

(exp-case-before)
(exp-case-after)

;Local Variables:
;mode: Idio
;coding: utf-8-unix
;End:
