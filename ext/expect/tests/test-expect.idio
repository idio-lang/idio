;;
;; Copyright (c) 2021-2022 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; test-expect.idio
;;

module tests/expect

import expect

expect-0 := Tests

exp-log-user #f
exp-timeout = 10

;; EOF in clauses
spawn auto-exit

(exp-case
 (:eof {
   test #t #t
 }))

(exp-wait)

;; EOF in exp-case-before
(exp-case-before
 (:eof {
   test #t #t
 }))

spawn auto-exit

(exp-case)

(exp-wait)

(exp-case-before)

;; EOF in exp-case-after
(exp-case-after
 (:eof {
   test #t #t
 }))

spawn auto-exit

(exp-case)

(exp-wait)

;; XXX leave :eof in exp-case-after for a "free" test when the spawned
;; process exits -- assuming we can exp-continue

;; read from program
spawn auto-exit -o 1

(exp-case
 (:re "wrote line ([[:digit:]]) to stdout" {
   test r.1 .1 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program using variables
spawn auto-exit -o 1

re := "wrote line ([[:digit:]]) to stdout"
(exp-case
 (:re re {
   test r.1 .1 "1"
   (exp-continue)
 }))

(exp-wait)

;; read from program with a timeout
spawn auto-exit -o 2 -s 2
exp-timeout = 1

;; XXX there is a race condition here in that it is possible to get
;; two 1s :timeout matches waiting for the program to output lines 2s
;; apart.  We can work around this by stopping after the first
;; :timeout and reverting to the more common timeout of 10s.

;; Nobody said this would be Art.

(exp-case
 ("wrote line 1 to stdout" {
   test #t #t
   (exp-continue)
 })
 (:timeout {
   test #t #t
 }))

exp-timeout = 10

(exp-case
 ("wrote line 2 to stdout" {
   test #t #t
   (exp-continue)
 })
 (:timeout {
   ;; shouldn't get here
   test "unexpected timeout clause" #t
 }))

(exp-wait)

;; write to a program: here, -v will report the line back to us
spawn auto-exit -r 3 -v

exp-send "hello" :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "1"
   test r.2 .1 "hello"
   ;(exp-continue)
 }))

exp-send "world" :slow #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "2"
   test r.2 .1 "world"
   ;(exp-continue)
 }))

exp-send "hello world" :human #t :cr #t

(exp-case
 (:re "read #([[:digit:]]) '(.*)'" {
   test r.1 .1 "3"
   test r.2 .1 "hello world"
   (exp-continue)
 }))

(exp-wait)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; exp-case return value

spawn auto-exit -o 10

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test #t #t
 }))

test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; dynamic scope before and after tests
;;
;; same before and after at the top-level

(exp-case-before
 ("wrote" 'match-before))

(exp-case-after
 ("wrote" 'match-after)
 (:eof {
   test #t #t
 }))

{
  ;; new before and after on the inside
  (exp-case-before
   ("wrote" 'match-inside-before))

  (exp-case-after
   ("wrote" 'match-inside-after)
   (:eof {
     test #t #t
   }))

  test (exp-case
	("wrote" 'match-case)) 'match-inside-before

  (exp-case-before)

  test (exp-case
	("wrote" 'match-case)) 'match-case

  test (exp-case) 'match-inside-after
}

;; check we have reverted to top-level
test (exp-case
      ("wrote" 'match-case)) 'match-before

(exp-case-before)

test (exp-case
      ("wrote" 'match-case)) 'match-case

test (exp-case) 'match-after

(exp-wait)

;; all done?
Tests? (expect-0 + 27)

;Local Variables:
;mode: Idio
;coding: utf-8-unix
;End:
