#*

Copyright (c) 2021-2022 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

expect.idio

*#

#*

IDIO_POLLHUP_OCCLUDES_POLLIN was introduced for WSL1 where, subject to
timing, you can have a spawned process both output something and exit
before this process gets round to calling poll(2).  For example, where
the spawned command might be something like "echo hello" but it could
also be the last output of a much longer command which you've
otherwise been quite happily consuming.

Normally, under those circumstances we should get POLLIN|POLLHUP and
would continue to get POLLIN|POLLHUP until all the (buffered) output
in read in from the pty.  At that point we would only get POLLHUP and
can handle that by indicating the remote end has been closed.

However, WSL1 only reports POLLHUP even though the output is present
and can be read.  This creates something of a problem as the headline
flags (POLLHUP only) suggest we should simply close the spawn-id down
and not refer to it again but in practice we can read the output and
do something with it.

Part of the problem, here, is how we have chosen to handle expect
spawn-id in exp-case (and friends).  It is always managed as a list
and each time round the exp-case-poll loop we remove entries from the
list that have completed (for some value of completed).  In addition,
on a POLLHUP we set the mfd to #f which we can use in a test to see if
there is anything worth doing.

The upshot is an extra pending-eof field which holds the string-length
of the buffer from the last time round the exp-case-poll loop.  If,
having tried to match something, we failed (which we can identify
because the string-length of the buffer is unchanged) we can say that,
ok, *now* we're done.  Otherwise, as things get matched in the buffer
we need to support this idea of not-quite-EOF-yet and therefore
not-quite-yet close things down.  It's all handled in cond-expand so
only WSL1 gets the extra code.

To complicate matters, IDIO_POLLHUP_OCCLUDES_POLLIN is also reported
by OpenBSD 6 and NetBSD 9 but those have, certainly historically,
managed to pass all the tests.  So the cond-expand qualification
becomes IDIO_POLLHUP_OCCLUDES_POLLIN and virtualisation/WSL.

****

https://unix.stackexchange.com/a/538271 suggests that read(2) on a
closed pty will result in EIO for Linux with differing results for
Solaris and *BSD.  Experience suggests that select(2) will provoke
this easily (or at least generate an immediate EOF) whereas poll(2)
seems to circumvent the issue most of the time (barring
IDIO_POLLHUP_OCCLUDES_POLLIN as above).

You can edit src/idio-config.h and add/edit

#undef IDIO_CAN_POLL_DEVICE

to use select(2) and see this behaviour yourself.

*#

module expect
export (
	 ;; vars
	 spawn-id
	 user-spawn-id
	 tty-spawn-id
	 exp-timeout
	 exp-match-max
	 exp-slow
	 exp-human

	 ;; names of functions to be...
	 exp-match-before
	 exp-match
	 exp-match-after

	 ;; funcs
	 exp-log
	 exp-log-user
	 exp-log-file

	 spawn

	 exp-case-eof?
	 exp-case-timeout?
	 exp-case-regexec

	 exp-close
	 exp-case-reset
	 exp-case-matched
	 exp-case-remaining?
	 exp-match-all

	 exp-case-set-timeout
	 exp-case-before
	 exp-case-after

	 exp-case-break-tag
	 exp-break
	 exp-case-continue-tag
	 exp-continue
	 exp-case-poll
	 exp-case-select
	 exp-case

	 ;; a sentinel value for exp-case to return when nothing
	 ;; matches
	 exp-case-failed-to-match

	 exp-send
	 exp-wait
	 exp-spawn-sync
)

import libc
import pty
import unicode

(export-struct
 struct-spawn
 argv pid mfd mode buffer matched eof timeout log-file lfh status pending-eof)

;; a simplified constructor
make-struct-spawn = {
  orig-make-struct-spawn := make-struct-spawn

  function/name make-struct-spawn (argv pid mfd mode) "
create an instance of a :ref:`struct-spawn <expect/struct-spawn>`

:param argv: command and arguments
:type argv: list
:param pid: Process ID of spawned process
:type pid: C/int
:param mfd: master file descriptor of pseudo-terminal
:type mfd: C/int
:param mode: initial terminal mode os standard input
:type mode: :ref:`libc/struct-termios <libc/struct-termios>`
:return: `struct-spawn`
:rtype: struct-instance

The `buffer` attribute is initialised to the empty string, ``\"\"``,
and the remaining attributes initialised to ``#f``.

" {
    orig-make-struct-spawn argv pid mfd mode "" #f #f #f #f #f #f #f
  }
}

spawn-id         :~ #f
user-spawn-id    :~ #f
trap ^system-error (function (c) {
  trap-return #f
  }) {
  user-spawn-id  = make-struct-spawn #n #f libc/STDIN_FILENO (libc/tcgetattr libc/STDIN_FILENO)
}
tty-spawn-id     :~ #f
exp-timeout      :~ -1
exp-match-max    :~ 2000
exp-match-before :~ #f
exp-match        :~ #f
exp-match-after  :~ #f

dev-tty-name     := %P"/dev/tty"

if (c? dev-tty-name) {
  ;; nominally it should be just ENXIO (or ENODEV) however if *any*
  ;; system error occurs then we're not going to have a tty-spawn-id
  trap ^system-error (function (c) {
    trap-return #f
  }) {
    fd := libc/open dev-tty-name libc/O_RDWR
    tty-spawn-id = make-struct-spawn #n #f fd (libc/tcgetattr fd)
  }
}

#*

exp-slow wants to describe a relatively slow rate of textual input --
ie. don't have us outrun the input buffer of the pseudo-terminal which
is expecting a human to be typing.  But humans are *really* slow so
this is lightning quick by comparison but nowhere near flat out.

It is a tuple of the number of code points and the millisecond gap
after.

A 9600 baud modem is roughly a byte per millisecond.  Twelve per
millisecond is roughly a 115200 baud modem (a bit more "modern") and
therefore (600 50) means we don't make systems calls through
libc/poller-poll to implement the timeout too often.

*#
exp-slow      :~ '(600 50)

#*

exp-human is derived from Don Libes' work.  He chose (see
human_write() in exp_command.c) a Weibull
distribution (https://en.wikipedia.org/wiki/Weibull_distribution) to
describe the average rate at which characters appear when a human is
typing.  Further, he differentiated between the average rate of
characters in a word and extra time taken to transition to characters
outside of a word (whitespace and punctuation).

In particular, the cumulative distribution function (CDF) is the
result of the characters appearing so we need the inverse cumulative
distribution function, the
quantile (https://en.wikipedia.org/wiki/Weibull_distribution#Cumulative_distribution_function),
to generate the CDF.

Here, accomodating the human_write() code, the function is

 λ (- (ln R))^K

where λ is the "scale", ie. average inter-character gap, R is a random
number, 0 <= R < 1, and K is the inverse of the "scale", nominally 1/K
in the quantile function, which determines if the gap gets larger or
smaller over time (technically, k, ie. 1/K, is about the rate of
failures -- I was quite pleased I found the web page, don't ask me to
understand the maths).

Expect drives the algorithm with a 5-tuple:

 in-word-gap out-word-gap K min max

Professional typists are reckoned to be around 60 wpm (close enough to
make the maths easy), that is a word per second.  Four letter words
and a space might be, say 180ms per in-word character and 240ms
transitioning from an in-word character to a non-word character with a
K of 1.  Roughly a 50 baud modem!

World record (accurate) typing is around 200 wpm, let's call it 180
wpm (maths) so the figures might be 65ms per in-word character and
75ms per non-word character.  Roughly a 150 baud modem.

There doesn't appear to be any peer-reviewed numbers for "enhanced
two-finger" typists.

In the meanwhile, "tiredness" might be represented by a K < 1 and
preternaturally good typing by a K > 1.

min and max obviously clip the generated distribution values.  Here,
you can get up to 4x quicker and twice as slow as the nominal in-word
gap.

*#
exp-human     :~ '(180 240 1 45 360)

log-user      := #t

define (exp-log spawn-id in? msg) "

``exp-log`` is a helper function for :ref:`exp-case <expect/exp-case>`
and others

" {
  dir := ">>"
  if in? {
    dir = "<<"
  }

  ;; log to user
  if log-user {
    if (string? msg) {
      printf "%s" msg
    } {
      printf "expect: log: %s '%s\n" dir msg
    }
  }

  ;; log to file -- spawn itself logs but we won't have set the log
  ;; file by then
  if (struct-spawn? spawn-id) {
    if (and (struct-spawn-lfh spawn-id)
	    (not (closed-handle? (struct-spawn-lfh spawn-id)))) {
      if (string? msg) {
	hprintf (struct-spawn-lfh spawn-id) "%s" msg
      } {
	hprintf (struct-spawn-lfh spawn-id) "expect: log: %s '%s\n" dir msg
      }
    }
  }
}

define (exp-log-user on?) "
Log the send/expect dialog to the user (ie. `stdout`) or not

:param on?: to log or not
:type on?: boolean
:return: ``#<unspec>``

The default is to have logging to the user enabled.

" {
  ;; don't keep a reference to on?
  log-user = (and on?
		  #t)
}

define* (exp-log-file file (:spawn-id spawn-id spawn-id) (:append append #t)) "
Log the send/expect dialog for `spawn-id` to `file` or not

:param file: the file to log to
:type file: see below
:keyword :spawn-id: the spawn-id(s) to use, defaults to :ref:`spawn-id <expect/spawn-id>`
:type :spawn-id: :ref:`expect/struct-spawn <expect/struct-spawn>`, optional
:keyword :append: to append or not, defaults to ``#t``
:type :append: boolean, optional
:return: ``#<unspec>``

`file` can be:

* ``#f`` to disable logging to a file

  If the existing log file was passed as a string, ie. it was opened
  by this module, then the associated log file handle will be closed.
  If this log file was shared with other spawn-ids then this closure
  will affect all of them.

  Both `log-file` and `lfh` will be set to ``#f`` in all cases.

* a string, indicating the filename to log to

* an output handle

* a file descriptor (open for output)

`spawn-id` can be a :ref:`struct-spawn <expect/struct-spawn>` or a
list of such ``struct-spawn``\ s.

" {
  (cond
   ((struct-spawn? spawn-id) {
     spawn-id = list spawn-id
   }))

  (cond
   ((not file) {
     for sid in spawn-id {
       if sid {
	 if (string? (struct-spawn-log-file sid)) {
	   lfh := struct-spawn-lfh sid
	   if (not (closed-handle? lfh)) {
	     close-handle lfh
	   }
	   set-struct-spawn-log-file! sid #f
	   set-struct-spawn-lfh! sid #f
	 }
       }
     }
   })
   ((string? file) {
     oflags := "we"
     if append {
       oflags = "ae"
     }
     lfh := open-file file oflags
     for sid in spawn-id {
       if sid {
	 set-struct-spawn-log-file! sid file
	 set-struct-spawn-lfh! sid lfh
       }
     }
   })
   ((output-handle? file) {
     for sid in spawn-id {
       if sid {
	 set-struct-spawn-log-file! sid file
	 set-struct-spawn-lfh! sid file
       }
     }
   })
   ((C/int? file) {
     oflags := "we"
     if append {
       oflags = "ae"
     }
     lfh := open-output-file-from-fd file oflags
     for sid in spawn-id {
       if sid {
	 set-struct-spawn-log-file! sid file
	 set-struct-spawn-lfh! sid lfh
       }
     }
   })
   (else {
     error/type ^rt-parameter-type-error 'exp-log-file "string|output handle|output file descriptor" file
   }))
}

define (spawn & argv) "
Spawn a process defined by `argv`

:param argv: command and arguments
:type argv: list
:return: :ref:`struct-spawn <expect/struct-spawn>`
:rtype: struct-instance
:raises ^system-error:

``spawn`` will set and return :ref:`spawn-id <expect/spawn-id>`.

.. tip::

   ``spawn-id`` defaults to ``#f`` however if you set it to ``#n`` or
   a list of spawn-id(s) then ``spawn`` will prepend any new value to
   the list.

" {
  sid := apply make-struct-spawn argv (apply pty/spawn argv)

  ;; Faintly annoyingly, this log entry cannot go into a
  ;; (spawn-specific) log file as we can't have set one up, yet.  We
  ;; could buffer logs but for how long and maybe the user is
  ;; judiciously not logging until the interesting bit.
  exp-log #f #f (sprintf "spawn %@\n" argv)

  if (list? spawn-id) {
    spawn-id = pair sid spawn-id
  } {
    spawn-id = sid
  }
}

#*

expect(1) allows for

  expect [[-opts] pat1 body1] ... [-opts] patn [bodyn]

with opts:

  -gl	(default)
  -ex
  -re
  -nocase

  [and others]

patn can be

  eof
  timeout
  default	== eof|timeout

exp-case {
}


loop over (test body) tuples

where test can be

  (regexec rx buffer)

    with rx derived from

      flags string

        and flags being

	  :re / :gl / :ex
	  :icase

	ie.

	  (regcomp (prepared string) [REG_ICASE])

  (or (POLLHUP? revents)
      (POLLERR? revents))

  (null? <result from poller-poll>)

******************************

What we want to do is, broadly, three things:

1. define a set of regcomps

  $e-r := make-array 5
  array-set! $e-r 0 (apply regcomp str1 flags1)
  array-set! $e-r 1 (apply regcomp str2 flags2)
  ...
  array-set! $e-r 4 :eof
  array-set! $e-r 5 :timeout

  where the keywords act as non-regcomp toggles

2. define a set of match clauses in cond which either call regexec or
   test the keyword's state and then run the corresponding body in a
   function which is passed (spawn-id) or (spawn-id r prefix) where r
   is the array result from regexec and prefix is the buffer up to
   r.0:

  define (exp-match spawn-id) {
    (cond
     ((regexec (array-ref $e-r 0) (struct-spawn-buffer spawn-id) 'REG_VERBOSE)
      => (function (r) {
	set-struct-spawn-matched! spawn-id #t
	r0 := r.0
	prefix := substring (struct-spawn-buffer spawn-id) 0 r0.1
	set-struct-spawn-buffer! (substring (struct-spawn-buffer spawn-id) r0.2)

	((function (spawn-id r prefix) {
	  ...
	}) spawn-id r prefix)
      }))
     ((regexec (array-ref $e-r 1) (struct-spawn-buffer spawn-id) 'REG_VERBOSE)
      => (function (r) {
	set-struct-spawn-matched! spawn-id #t
	r0 := r.0
	prefix := substring (struct-spawn-buffer spawn-id) 0 r0.1
	set-struct-spawn-buffer! (substring (struct-spawn-buffer spawn-id) r0.2)

	((function (spawn-id r prefix) {
	  ...
	}) spawn-id r prefix)
      }))
     ...
     ((struct-spawn-eof spawn-id) => (function (r) {
       set-struct-spawn-matched! spawn-id #t
       ((function (spawn-id)
	$@(pth c*)) spawn-id)
     }))
     ((struct-spawn-timeout spawn-id) => (function (r) {
       set-struct-spawn-matched! spawn-id #t
       ((function (spawn-id) {
	 ...
       }) spawn-id)
     })))
  }

3. define the exp-continue loop (in the scope of the user's body
   forms) where we run exp-match against the existing buffer contents
   and if not then poller-poll for more data

This is all complicated because our {str} could actually be an
expression (usually a variable but could be anything), in which case
we want to delay the regcomp/string processing until we're in the
match loop

    ***

exp-before and exp-after behaviour can't be done as simply as in
expect(1) as Expect evals the behaviour "strings" whereas we need to
manage them through a template which means we need to see them in the
evaluator.  In addition, it would be nice if we could use some dynamic
scope.

Part of the problem, here, is that exp-case, a template, being
processed by the evaluator can't see any dynamic changes of
exp-before/exp-after variables.

The, not terrible, fix is to define exp-case-before and exp-case-after
templates which do the same clause manipulation as exp-case where the
template expands to the assignment to the exp-match-before and
exp-match-after functions (with a simple assignment if no clauses are
passed).

exp-case, itself, can assign to exp-match then call exp-match-before,
exp-match and exp-match-after at the appropriate points.

*#

define (exp-case-eof? sid+) "

``exp-case-eof?`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  loop :+ function (sid*) {
    (cond
     ((null? sid*) #f)
     (else {
       sid := ph sid*
       if (and sid
	       (struct-spawn-eof sid)) {
	 ;; return the lot and the code in process-args can filter the
	 ;; individuals out again, calling the body for each in turn
	 sid+
       } (loop (pt sid*))
     }))
  }

  loop sid+
}

define (exp-case-timeout? sid+) "

``exp-case-timeout?`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  ;; timeout is a bit different as if one sid+ has timed out then
  ;; they all have

  loop :+ function (sid*) {
    (cond
     ((null? sid*) #f)
     (else {
       sid := ph sid+
       if (and sid
	       (struct-spawn-timeout sid)) {
	 ;; return the lot
	 sid+
       } (loop (pt sid*))
     }))
  }

  loop sid+
}

define (exp-case-regexec exp-regcomps i sid+) "

``exp-case-regexec`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  loop :+ function (sid*) {
    (cond
     ((null? sid*) #f)
     (else {
       sid := ph sid*
       if sid {
	 r := regexec (array-ref exp-regcomps i) (struct-spawn-buffer sid) 'REG_VERBOSE
	 if r {
	   list sid r
	 } (loop (pt sid*))
       } (loop (pt sid*))
     }))
  }

  loop sid+
}

define (process-args exp-regcomps i re-kind re-flags a*) "

``process-args`` is a helper function for :ref:`exp-case
<expect/exp-case>` and others

" {
  (cond
   ((null? a*)
    (error/type ^rt-syntax-error 'exp-case "invalid syntax: no string/body" re-kind re-flags))
   ((not (pair? a*))
    (error/type ^rt-syntax-error 'exp-case "invalid syntax: no string/body" re-kind re-flags a*))
   (else {
     (case (ph a*)
      ((:eof) {
	list (ph a*) #T{
	  ((exp-case-eof? spawn-id) => (function (sid+) {
	    for sid in sid+ {
	      if (and sid
		      (struct-spawn-eof sid)) {
		set-struct-spawn-matched! sid #t
		((function (spawn-id)
		 $@(pt a*)) sid)
	      }
	    }
	  }))
	}
      })
      ((:timeout) {
	list (ph a*) #T{
	  ((exp-case-timeout? spawn-id) => (function (sid+) {
	    for sid in sid+ {
	      if sid {
		set-struct-spawn-matched! sid #t
	      }
	    }
	    ((function (spawn-id)
	     $@(pt a*)) sid+)
	  }))
	}
      })
      ((:all) {
	list (ph a*) #T{
	  (#t {
	    for sid in spawn-id {
	      if sid {
		set-struct-spawn-matched! sid #t
		r0 := list (struct-spawn-buffer sid) 0 (string-length (struct-spawn-buffer sid))
		set-struct-spawn-buffer! sid ""
		((function (spawn-id r prefix)
		 $@(pt a*)) sid (list->array (list r0)) "")
	      }
	    }
	  })
	}
      })
      ((:re :gl :ex) {
	process-args exp-regcomps i (ph a*) re-flags (pt a*)
      })
      ((:icase) {
	process-args exp-regcomps i re-kind 'REG_ICASE (pt a*)
      })
      (else {
	body := #T{
	  ((exp-case-regexec $exp-regcomps $i spawn-id)
	   => (function (sid-r) {
	     sid := ph sid-r
	     r := pht sid-r
	     set-struct-spawn-matched! sid #t
	     r0 := array-ref r 0
	     prefix := substring (struct-spawn-buffer sid) 0 r0.1
	     set-struct-spawn-buffer! sid (substring (struct-spawn-buffer sid) r0.2)

	     ((function (spawn-id r prefix)
	      $@(pt a*)) sid r prefix)
	   }))
	}

	(cond
	 ((string? (ph a*)) {
	   (cond
	    ((eq? :gl re-kind) {
	      list (list (regex-pattern-string (ph a*)) re-flags) body
	    })
	    ((eq? :ex re-kind) {
	      list (list (regex-exact-string (ph a*)) re-flags) body
	    })
	    ((eq? :re re-kind) {
	      list (list (ph a*) re-flags) body
	    }))
	 })
	 (else {
	   (cond
	    ((eq? :gl re-kind) {
	      #T{
		(((regex-pattern-string $(ph a*)) $re-flags) $body)
	      }
	    })
	    ((eq? :ex re-kind) {
	      #T{
		(((regex-exact-string $(ph a*)) $re-flags) $body)
	      }
	    })
	    ((eq? :re re-kind) {
	      #T{
		(($(ph a*) $re-flags) $body)
	      }
	    }))
	 }))
      }))
   }))
}

define (process-clauses c* exp-regcomps i ri* rk* rb*) "

``process-clauses`` is a helper function for :ref:`exp-case
<expect/exp-case>` and others

" {
  (cond
   ((null? c*) (list (reverse! ri*) (reverse! rk*) (reverse! rb*)))
   ((or (not (pair? c*))
	(not (pair? (ph c*)))
	(not (pair? (pth c*)))) (error/type ^rt-syntax-error 'exp-case "invalid syntax" c*))
   (else {
     ;; key body
     kb := process-args exp-regcomps i :gl #n (ph c*)
     process-clauses (pt c*) exp-regcomps (i + 1) (pair i ri*) (pair (ph kb) rk*) (pair (pht kb) rb*)
   }))

}

define* (exp-close (:spawn-id spawn-id spawn-id)) "
close the master file descriptor to the spawned process

:keyword :spawn-id: the spawn-id(s) to use, defaults to :ref:`spawn-id <expect/spawn-id>`
:type :spawn-id: :ref:`expect/struct-spawn <expect/struct-spawn>`, optional
:return: ``#<unspec>``

``exp-close`` will also set the `mfd` structure element to ``#f``

`spawn-id` can be a :ref:`struct-spawn <expect/struct-spawn>` or a
list of such ``struct-spawn``\ s.

" {
  define (close-sid sid) {
    mfd := struct-spawn-mfd spawn-id
    if mfd {
      libc/close mfd
      set-struct-spawn-mfd! spawn-id #f
      (cond-expand
       ((and IDIO_POLLHUP_OCCLUDES_POLLIN
	     virtualisation/WSL) {
	 if (struct-spawn-pending-eof sid) {
	   set-struct-spawn-pending-eof! sid #f
	 }
       }))
    }
  }

  (cond
   ((struct-spawn? spawn-id) {
     close-sid spawn-id
   })
   ((pair? spawn-id) {
     for sid in spawn-id {
       close-sid sid
     }
   }))
}

define (exp-case-reset sid+ & matched) "

``exp-case-reset`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  loop :+ function (sid*) {
    (cond
     ((null? sid*) #t)
     ((ph sid*) => (function (sid) {
       if (struct-spawn-eof sid) {
	 exp-close :spawn-id sid
	 set-ph! sid* #f
       } {
	 set-struct-spawn-timeout! sid #f
	 if (not (null? matched)) {
	   set-struct-spawn-matched! sid #f
	 }
       }
       loop (pt sid*)
     }))
    (else (loop (pt sid*))))
  }

  loop sid+
}

define (exp-case-matched sid+) "

``exp-case-matched`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  loop :+ function (sid*) {
    (cond
     ((null? sid*) #f)
     ((and (ph sid*)
	   (struct-spawn-matched (ph sid*))) #t)
     (else (loop (pt sid*))))
  }

  loop sid+
}

define (exp-case-remaining? sid+) "

``exp-case-remaining?`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  loop :+ function (sid*) {
    (cond
     ((null? sid*) #f)
     ((ph sid*) #t)
     (else (loop (pt sid*))))
  }

  loop sid+
}

define (exp-match-all sid+) "

``exp-match-all`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  r := (void)
  if (function? exp-match-before) {
    r = exp-match-before sid+
  }

  if (and (function? exp-match)
	  (not (exp-case-matched sid+))
	  (exp-case-remaining? sid+)) {
    r = exp-match sid+
  }

  if (and (function? exp-match-after)
	  (not (exp-case-matched sid+))
	  (exp-case-remaining? sid+)) {
    r = exp-match-after sid+
  }

  r
}

define (exp-case-set-timeout sid+) "

``exp-case-set-timeout`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  for sid in sid+ {
    if sid {
      set-struct-spawn-timeout! sid #t
      expect/exp-log sid #t (sprintf "exp-case: %@: poll: timeout\n" (struct-spawn-argv sid))
      (cond-expand
       ((and IDIO_POLLHUP_OCCLUDES_POLLIN
	     virtualisation/WSL) {
	 if (struct-spawn-pending-eof sid) {
	   set-struct-spawn-pending-eof! sid #f
	 }
       }))
    }
  }
}

define-template (exp-case-before & clauses) {

  if (null? clauses) {
    #T{
      exp-match-before :~ #f
    }
  } {
    ;; #[ <regcomp> ]
    exp-regcomps := gensym 'e-r

    ;; index key body
    ikb := process-clauses clauses exp-regcomps 0 #n #n #n

    n := length clauses

    #T{
      $exp-regcomps := make-array $n
      $@(map (function (i t) {
	;; t is kw|(str flags)
	(cond
	 ((keyword? t) {
	   #T{
	     array-set! $exp-regcomps $i $t
	   }
	 })
	 (else {
	   #T{
	     array-set! $exp-regcomps $i (apply regcomp $(ph t) $(pht t))
	   }
	 }))
      }) (ph ikb) (pht ikb))

      exp-match-before :~ function (spawn-id) {
	(cond
	 $@(map (function (b) {
	   #T{
	     ($@b)
	   }

	 }) (phtt ikb)))
      }

    }
  }
}

define-template (exp-case-after & clauses) {

  if (null? clauses) {
    #T{
      exp-match-after :~ #f
    }
  } {
    ;; #[ <regcomp> ]
    exp-regcomps := gensym 'e-r

    ;; index key body
    ikb := process-clauses clauses exp-regcomps 0 #n #n #n

    n := length clauses

    #T{
      $exp-regcomps := make-array $n
      $@(map (function (i t) {
	;; t is kw|(str flags)
	(cond
	 ((keyword? t) {
	   #T{
	     array-set! $exp-regcomps $i $t
	   }
	 })
	 (else {
	   #T{
	     array-set! $exp-regcomps $i (apply regcomp $(ph t) $(pht t))
	   }
	 }))
      }) (ph ikb) (pht ikb))

      exp-match-after :~ function (spawn-id) {
	(cond
	 $@(map (function (b) {
	   #T{
	     ($@b)
	   }

	 }) (phtt ikb)))
      }

    }
  }
}

exp-case-failed-to-match := pair 'exp-case 'failed-to-match
exp-case-break-tag := make-prompt-tag 'exp-case-break
(define-syntax exp-break
 (syntax-rules ()
  ((exp-break)   (exp-break (void)))
  ((exp-break v) (abort-to* exp-case-break-tag v))))

exp-case-continue-tag := make-prompt-tag 'exp-case-continue
(define-syntax exp-continue
 (syntax-rules ()
  ((exp-continue)   (exp-continue (void)))
  ((exp-continue v) (abort-to* exp-case-continue-tag v))))

define (exp-case-poll) "

``exp-case-poll`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  ;; normalize the poll-timeout noting that Mac OS X says poll
  ;; doesn't like a timeout less than -1
  poll-timeout := (cond
		   ((exp-timeout gt 0) (exp-timeout * 1000))
		   ((exp-timeout lt 0) -1)
		   (else               0))

  poller := #f

  ;; poller only uses mfd so we need a hash table to get us back
  ;; to spawn-ids
  poller-map := #f

  ;; always deal with a list of spawn-ids
  sid+ := #n
  if (struct-spawn? spawn-id) {
    sid+ = list spawn-id
  } {
    ;; ensure we operate on a copy of the list
    sid+ = copy-value spawn-id
  }

  prompt-at exp-case-break-tag {
    exp-case-loop :+ function #n {
      prompt-at exp-case-continue-tag {
	; reset all flags (otherwise if you match a timeout and then
	; exp-continue you'll loop matching timeout)
	exp-case-reset sid+ #t

	;; anything to do -- clearly there is the first time through
	;; but calls to (exp-continue) after End of File indications
	;; will have reduced the list
	n := (fold-left (function (c sid) {
	  if sid {
	    ;; also exclude (the first time through) people who've
	    ;; managed to call exp-close before exp-case...
	    if (or (struct-spawn-mfd sid)
		   (struct-spawn-pending-eof sid)) (c + 1) c
	  } c
	}) 0 sid+)

	if (n gt 0) {
	  ;; search existing buffer
	  r := expect/exp-match-all sid+

	  if (exp-case-matched sid+) (exp-break r) {
	    exp-case-reset sid+

	    if (not poller) {
	      poller-map = make-hash #n #n 4
	      poller = apply libc/make-poller (fold-left (function (r sid) {
		if sid {
		  mfd := struct-spawn-mfd sid
		  if mfd {
		    hash-set! poller-map mfd sid
		    pair (list mfd libc/POLLIN) r
		  } r
		} r
	      }) #n sid+)
	    }

	    poll-results := libc/poller-poll poller poll-timeout

	    define (eof-sid poll-fd sid msg) {
	      libc/poller-deregister poller poll-fd
	      expect/exp-close :spawn-id sid
	      set-struct-spawn-eof! sid #t

	      expect/exp-log sid #t msg
	    }

	    define (close-poll poll-fd sid msg) {
	      (cond-expand
	       ((and IDIO_POLLHUP_OCCLUDES_POLLIN
		     virtualisation/WSL) {
		 blen := string-length (struct-spawn-buffer sid)
		 plen := struct-spawn-pending-eof sid
		 if plen {
		   if (plen eq blen) {
		     set-struct-spawn-pending-eof! sid #f
		     eof-sid poll-fd sid msg
		   } {
		     if (blen gt 0) {
		       set-struct-spawn-pending-eof! sid blen
		     } {
		       set-struct-spawn-pending-eof! sid #f
		       eof-sid poll-fd sid msg
		     }
		   }
		 } {
		   if (blen gt 0) {
		     set-struct-spawn-pending-eof! sid blen
		   } {
		     set-struct-spawn-pending-eof! sid #f
		     eof-sid poll-fd sid msg
		   }
		 }
	       })
	       (else {
		 eof-sid poll-fd sid msg
	       }))
	    }

	    define (read-poll poll-fd sid all) {
	      data := libc/read poll-fd 1024
	      if data {
		if (eof? data) {
		  close-poll poll-fd sid (sprintf "exp-case: %@: poll (fd=%d): POLLIN EOF\n" (struct-spawn-argv sid) poll-fd)
		} {
		  set-struct-spawn-buffer! sid (append-string (struct-spawn-buffer sid) data)
		  expect/exp-log sid #t data
		  if (and all
			  ((string-length data) eq 1024)) {
		    read-poll poll-fd sid all
		  }
		}
	      }
	    }

	    (cond
	     ((null? poll-results) {
	       exp-case-set-timeout sid+
	     })
	     (else {
	       for p-r in poll-results {
		 poll-fd := ph p-r
		 poll-revents := pht p-r
		 sid := hash-ref poller-map poll-fd
		 (cond
		  ((libc/POLLIN? poll-revents) {
		    read-poll poll-fd sid #f
		  })
		  ((libc/POLLHUP? poll-revents) {
		    (cond-expand
		     ((and IDIO_POLLHUP_OCCLUDES_POLLIN
			   virtualisation/WSL) {
		       trap ^system-error (function (c) {
			 if (and (C/== (system-error-errno c) libc/EIO)
				 (equal? (system-error-function c) "read")) {
			   #f
			 } {
			   condition-report "poll POLLHUP occludes POLLIN" c
			   raise c
			 }
		       }) {
			 read-poll poll-fd sid #t
		       }
		     }))

		    close-poll poll-fd sid (sprintf "exp-case: %@: poll (fd=%d): POLLHUP EOF\n" (struct-spawn-argv sid) poll-fd)
		  })
		  ((libc/POLLERR? poll-revents) {
		    close-pool poll-fd sid (sprintf "exp-case: %@: poll (fd=%d): POLLERR EOF\n" (struct-spawn-argv sid) poll-fd)
		  })
		  ((libc/POLLNVAL? poll-revents) {
		    close-poll poll-fd sid (sprintf "exp-case: %@: poll (fd=%d): invalid request\n" (struct-spawn-argv sid) poll-fd)
		  }))
	       }
	     }))

	    ;; search buffer + new data
	    r = expect/exp-match-all sid+

	    if (exp-case-matched sid+) (exp-break r) {
	      for-each (function (sid) {
		if sid {
		  if ((string-length (struct-spawn-buffer sid)) gt exp-match-max) {
		    set-struct-spawn-buffer! sid (substring (struct-spawn-buffer sid) (- exp-match-max))
		  }
		}
	      }) sid+
	    }
	  }
	} {
	  exp-break exp-case-failed-to-match
	}
      }

      (and (exp-case-remaining? sid+)
	   (exp-case-loop))
    }

    ;; initial loop
    (exp-case-loop)
  }

  ;; exp-break comes back here
}

define (exp-case-select) "

``exp-case-select`` is a helper function for :ref:`exp-case
<expect/exp-case>`

" {
  ;; Mac OS 10.5.8 does have poll(2) but it reports POLLNVAL
  ;; for (pseudo-terminal) devices.  It does mention devices in
  ;; the BUGS section in the man page.

  ;; Of interest, Mac OS 10.15.7 also has the same BUGS section
  ;; but does work for (pseudo-terminal) devices.

  ;; In the meanwhile, and for anything else in the same boat,
  ;; we'll fall back to select with attendant issues.

  ;; normalize the select-timeout
  select-timeout := (cond
		     ((exp-timeout gt 0) (exp-timeout * 1000000))
		     ((exp-timeout lt 0) #n)
		     (else               0))

  ;; select only uses mfd so we need a hash table to get us back
  ;; to spawn-ids
  select-map := make-hash #n #n 4

  ;; always deal with a list of spawn-ids
  sid+ := #n
  if (struct-spawn? spawn-id) {
    sid+ = list spawn-id
  } {
    ;; ensure we operate on a copy of the list
    sid+ = copy-value spawn-id
  }

  prompt-at exp-case-break-tag {
    exp-case-loop :+ function #n {
      prompt-at exp-case-continue-tag {
	; reset all flags (otherwise if you match a timeout and then
	; exp-continue you'll loop matching timeout)
	exp-case-reset sid+ #t

	;; anything to do -- clearly there is the first time through
	;; but calls to (exp-continue) after End of File indications
	;; will have reduced the list
	n := (fold-left (function (c sid) {
	  if sid {
	    ;; also exclude (the first time through) people who've
	    ;; managed to call exp-close before exp-case...
	    if (struct-spawn-mfd sid) (c + 1) c
	  } c
	}) 0 sid+)

	if (n gt 0) {
	  ;; search existing buffer
	  r := expect/exp-match-all sid+

	  if (exp-case-matched sid+) (exp-break r) {
	    exp-case-reset sid+

	    select-results := libc/select (fold-left (function (r sid) {
	      if sid {
		mfd := struct-spawn-mfd sid
		if mfd {
		  hash-set! select-map mfd sid
		  pair mfd r
		} r
	      } r
	    }) #n sid+) #n #n select-timeout
	    rlist := ph select-results

	    (cond
	     ((null? rlist) {
	       exp-case-set-timeout sid+
	     })
	     (else {
	       ;; we know it is mfd but let's go through the motions
	       for fd in rlist {
		 sid := hash-ref select-map fd

		 trap ^system-error (function (c) {
		   ;; select(2) is more likely to return EIO than
		   ;; poll(2)
		   if (C/== (system-error-errno c) libc/EIO) {
		     set-struct-spawn-eof! sid #t
		     expect/exp-log sid #t (sprintf "exp-case: %@: select (fd=%d): EIO\n" (struct-spawn-argv sid) fd)
		     trap-return #f
		   } {
		     raise c
		   }
		 }) {
		   data := libc/read fd 1024
		   if data {
		     if (eof? data) {
		       set-struct-spawn-eof! sid #t
		       expect/exp-log sid #t (sprintf "exp-case: %@: select (fd=%d): EOF\n" (struct-spawn-argv sid) fd)
		     } {
		       set-struct-spawn-buffer! sid (append-string (struct-spawn-buffer sid) data)
		       expect/exp-log sid #t data
		     }
		   }
		 }
	       }
	     }))

	    ;; search buffer + new data
	    r = expect/exp-match-all sid+

	    if (exp-case-matched sid+) (exp-break r) {
	      for-each (function (sid) {
		if sid {
		  if ((string-length (struct-spawn-buffer sid)) gt exp-match-max) {
		    set-struct-spawn-buffer! sid (substring (struct-spawn-buffer sid) (- exp-match-max))
		  }
		}
	      }) sid+
	    }
	  }
	} {
	  exp-break exp-case-failed-to-match
	}
      }

      (and (exp-case-remaining? sid+)
	   (exp-case-loop))
    }

    ;; initial loop
    (exp-case-loop)
  }

  ;; exp-break comes back here
}

define-template (exp-case & clauses) {
  ;; #[ <regcomp> ]
  exp-regcomps := gensym 'e-r

  ;; index key body
  ikb := process-clauses clauses exp-regcomps 0 #n #n #n

  n := length clauses

  sid* := gensym 'sid*

  #T{
    ;; exp-case needs to behave slightly differently in the face of no
    ;; clauses as there could be exp-case-before and/or exp-case-after
    ;; clauses to process
    $(if (n gt 0) {
      #T{
	$exp-regcomps := make-array $n
	$@(map (function (i t) {
	  ;; t is kw|(str flags)
	  (cond
	   ((keyword? t) {
	     #T{
	       array-set! $exp-regcomps $i $t
	     }
	   })
	   (else {
	     #T{
	       array-set! $exp-regcomps $i (apply regcomp $(ph t) $(pht t))
	     }
	   }))
	}) (ph ikb) (pht ikb))

	exp-match = function (spawn-id) {
	  (cond
	   $@(map (function (b) {
	     #T{
	       ($@b)
	     }

	   }) (phtt ikb)))
	}
      }
    } {
      #T{
	exp-match = #f
      }
    })

    (cond-expand
     (IDIO_CAN_POLL_DEVICE {
       (exp-case-poll)
     })
     (else {
       (exp-case-select)
     }))
  }
}

define* (exp-send msg
		  (:slow slow #f)
		  (:human human #f)
		  (:spawn-id spawn-id spawn-id)
		  (:cr cr #f)) "
send `msg` to the spawned process

:param msg: the string to send
:type msg: string
:keyword :slow: send `msg` slowly, defaults to ``#f``
:type :slow: boolean, optional
:keyword :human: send `msg` humanly, defaults to ``#f``
:type :human: boolean, optional
:keyword :spawn-id: the spawn-id to use, defaults to :ref:`spawn-id <expect/spawn-id>`
:type :spawn-id: :ref:`expect/struct-spawn <expect/struct-spawn>`, optional
:keyword :cr: to send a 'carriage return' or not, defaults to ``#f``
:type :cr: boolean, optional
:return: ``#<unspec>``

`:slow` says to use the value of :ref:`exp-slow <expect/exp-slow>`
which is a tuple of the number of code points in a burst prefixed by a
delay of a number of milliseconds.  The default is ``(600 50)`` -- 600
code points and a 50 ms delay -- roughly equivalent to a 115200 baud
modem (if the code points were ASCII).

`:human` says to use the value of :ref:`exp-human <expect/exp-human>`
which is a tuple of:

* the average gap between in-word code points

* the average gap transitioning from an in-word code point to a
  non-word code point

* a moderating factor, K:

  \"tiredness\" might be represented by a K < 1 and preternaturally
  consistent typing by a K > 1

* the minimum inter-code point gap

* the maximum inter-code point gap

The default is ``(180 240 1 45 360)`` roughly equivalent to a 60 wpm
typist.

The algorithm used to calculate the inter-code point gap is the
inverse cumulative distribution function of the Weibull distribution.
The same as Don Libes' :manpage:`expect(1)`.

`:human` is preferred to `:slow` if both are supplied.

`:spawn-id` can be passed a C/int representing an open (for output)
file descriptor which will be used instead.  For example, to send
output to the user pass ``libc/STDOUT_FILENO``.

:Example:

Suppose we wanted to observe a professional typist attempting a
well-known English `pangram <https://en.wikipedia.org/wiki/Pangram>`_:

.. code-block:: idio

   exp-send \"The quick brown fox jumps over the lazy dog\" :spawn-id libc/STDOUT_FILENO :human #t


" {
  mfd := #f
  (cond
   ((struct-spawn? spawn-id) {
     mfd = struct-spawn-mfd spawn-id
     if (not mfd) {
       error/type ^rt-parameter-value-error 'exp-send "mfd is #f" spawn-id
     }
   })
   ((C/int? spawn-id) {
     mfd = spawn-id
   })
   (else {
     error/type ^rt-parameter-type-error 'exp-send "struct-spawn|C/int" spawn-id
   }))

  (cond
   (human {
     expect/exp-send-human mfd msg
   })
   (slow {
     if (and (pair? exp-slow)
	     ((length exp-slow) ge 2)
	     (integer? (ph exp-slow))
	     (integer? (pht exp-slow))) {
       n      := ph exp-slow
       ms     := pht exp-slow

       poller := (libc/make-poller)
       pe     := string-length msg

       loop :+ function (p) {
	 if (p lt pe) {
	   pl := p + n
	   if (pl ge pe) {
	     libc/poller-poll poller ms
	     libc/write mfd (substring msg p)
	   } {
	     libc/poller-poll poller ms
	     libc/write mfd (substring msg p pl)
	     loop pl
	   }
	 }
       }

       loop 0
     } {
       error/type ^rt-parameter-value-error 'exp-send "should be (#cp ms): not" exp-slow
     }
   })
   (else {
     libc/write mfd msg
   }))
  expect/exp-log spawn-id #f msg

  if cr {
    libc/write mfd "\r"
    expect/exp-log spawn-id #f "\r"
  }
}

define* (exp-wait (:spawn-id spawn-id spawn-id) (:close close? #t)) "
wait for the spawned process

:keyword :spawn-id: the spawn-id(s) to use, defaults to :ref:`spawn-id <expect/spawn-id>`
:type :spawn-id: :ref:`expect/struct-spawn <expect/struct-spawn>`
:keyword :close: close the `mfd`, defaults to ``#t``
:type :close: boolean
:return: see below
:rtype: list

``exp-wait`` will call :ref:`exp-close <expect/exp-close>` if `:close`
is `true` and ``exp-close`` has not already been called.

Otherwise ``exp-wait`` will read data from the spawned process until
End of File (or some ^system-error) is indicated.

.. warning::

   Neither option is ideal if the spawned process has not completed
   its processing

   * pro-actively closing the `mfd` of a running program will probably
     have the operating system send the spawned process a hangup
     signal

     This is most likely to result in a failed process state (and
     presumes the spawned process does not ignore or otherwise handle
     a ``SIGHUP``).

   * on the other hand, *not* closing the `mfd` might have the spawned
     process block waiting for full output buffers to be emptied,
     hence reading from the spawned process until End of File is
     indicated

     However, if the spawned process is waiting for some input before
     writing any final output then the spawned process will also
     block.

``exp-wait`` will return a list of the result from :ref:`waitpid
<libc/waitpid>` plus a decoding of the status, eg. ``(exit 0)`` or
``(killed 1)`` (see tip).

`spawn-id` can be a :ref:`struct-spawn <expect/struct-spawn>` or a
list of such ``struct-spawn``\ s.  If `spawn-id` is a list the value
returned will be a list of individual result lists.

.. tip::

   The per-`spawn-id` result is also stored in the ``struct-spawn``
   structure as the `status` field.

" {
  define (waiter sid) {
    if (struct-spawn-mfd sid) {
      if close? {
	exp-close :spawn-id sid
      } {
	;; XXX there's bound to be a (trivial) pathological case where
	;; draining the pty to get to EOF doesn't work
	loop :+ function (mfd) {
	  eprintf "."
	  trap ^system-error (function (c) {
	    trap-return #t
	  }) {
	    data := libc/read mfd
	    if data {
	      if (eof? data) #t (loop mfd)
	    } (loop mfd)
	  }
	}

	loop (struct-spawn-mfd sid)
	eprintf "\n"
      }
    }

    r := struct-spawn-status sid
    if (and (not r)
	    (struct-spawn-pid sid)) {
      wr := libc/waitpid (struct-spawn-pid sid)
      pid := ph wr
      status := pht wr
      coding := (cond
		 ((null? status) {
		   eprintf "waitpid -> #n for %s\n" sid
		   '(null)
		 })
		 ((WIFEXITED status) {
		   list 'exit (WEXITSTATUS status)

		 })
		 ((WIFSIGNALED status) {
		   list 'killed (WTERMSIG status)
		 })
		 (else {
		   '(unknown)
		 }))

      r = append wr (list coding)
      set-struct-spawn-status! sid r
    }
    r
  }

  (cond
   ((struct-spawn? spawn-id) {
     waiter spawn-id
   })
   ((pair? spawn-id) {
     r := #n
     for sid in spawn-id {
       r = pair (waiter sid) r
     }
     r
   }))
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Bah!  On some systems spawning two processes is fine but expecting
;; them to immediately have data available is, apparently, not so
;; reasonable.  Something, something, OS process scheduling?  We need
;; to get everything sync'ed up.
;;
;; As the whole problem with calling poll/select with all of the
;; spawned processes at once is that not all of the processes are
;; ready to generate output -- and poll/select will happily return
;; with what they *do* have -- then what we must do is process each
;; one individually, thus giving the OS a chance to schedule them in.
;;
;; I suppose that this might be seen as a generic problem in which
;; case this code ought to intuit a bit more about input vs output
;; streams.
;;
;; In the meanwhile, the following works for the test suite where
;; we've multiple spawned processes running at once and intend to read
;; from them "simultaneously."

define* (exp-spawn-sync (spawn-id spawn-id) (timeout exp-timeout))"
wait for the spawned processes to be \"ready\"

:param spawn-id: the spawn-id(s) to use, defaults to :ref:`spawn-id <expect/spawn-id>`
:type spawn-id: a list of :ref:`expect/struct-spawn <expect/struct-spawn>`
:param timeout: timeout per spawn-id (in seconds), defaults to :ref:`exp-timeout <expect/exp-timeout>`
:type timeout: integer
:return: unspecified
:rtype: unspecified

If you spawn multiple processes on a transiently/mechanically
under-resourced system where a subsequent :ref:`exp-case
<expect/exp-case>` is intended to test patterns against all processes
it is quite possible that one or more of the spawned processes will
not (yet) have been scheduled to run by the operating system before
the ``exp-case`` starts.

:manpage:`poll(2)`/:manpage:`select(2)` will quite happily return with
what is available from those processes that have been scheduled
leaving the possibility of missing data from not yet ready processes.

``exp-spawn-sync`` will test each of the spawn-ids in `spawn-id` in
turn for a response which will give the operating system an
opportunity to schedule the process in.  The response could be that
the is output available to be read, there is no output or an error has
occurred -- however, at least a response is ready.

There should be no need to use ``exp-spawn-sync`` for single-instance
spawn-ids as the following ``exp-case`` provides the same
functionality implicitly.

``exp-spawn-sync`` is only of use where multiple spawn-ids are
expected to be tested against simultaneously.

" {
  for sid in spawn-id {
    mfd := struct-spawn-mfd sid
    if mfd {
      (cond-expand
       (IDIO_CAN_POLL_DEVICE {
	 poller := libc/make-poller (list mfd libc/POLLIN)
	 libc/poller-poll poller (timeout * 1000)
       })
       (else {
	 libc/select (list mfd) #n #n (timeout * 1000000)
       }))
    }
  }
}

provide expect

;Local Variables:
;mode: Idio
;coding: utf-8-unix
;End:
