
/*
 * libc-api.c
 *
 *
 * This file was generated by idio-c-api-gen for a Linux 5.12.10-300.fc34.x86_64 x86_64 system
 *
 * It has subsequently been reworked into a normal/portable form
 * (__pid_t to pid_t, etc.).
 */

#define _GNU_SOURCE

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/times.h>
#include <sys/utsname.h>
#include <sys/wait.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <ffi.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "gc.h"
#include "idio.h"

#include "bignum.h"
#include "c-type.h"
#include "error.h"
#include "evaluate.h"
#include "fixnum.h"
#include "handle.h"
#include "hash.h"
#include "idio-string.h"
#include "job-control.h"
#include "libc-wrap.h"
#include "module.h"
#include "pair.h"
#include "path.h"
#include "string-handle.h"
#include "symbol.h"
#include "util.h"
#include "vm.h"

#include "libc-api.h"

/*
	/usr/include/sys/utsname.h

	struct utsname
	{
	  char[]               sysname;
	  char[]               nodename;
	  char[]               release;
	  char[]               version;
	  char[]               machine;
	  char[]               domainname;	Linux
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_utsname);
IDIO_SYMBOL_DECL (sysname);
IDIO_SYMBOL_DECL (nodename);
IDIO_SYMBOL_DECL (release);
IDIO_SYMBOL_DECL (version);
IDIO_SYMBOL_DECL (machine);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-utsname-ref", libc_struct_utsname_ref, (IDIO utsname, IDIO member), "utsname member", "\
in C, utsname->member			\n\
					\n\
:param utsname: C struct utsname	\n\
:type utsname: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: utsname->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (utsname);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-utsname-ref-bad-pointer-type.idio
     *
     * struct-utsname-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, utsname);
    if (idio_CSI_libc_struct_utsname != IDIO_C_TYPE_POINTER_PTYPE (utsname)) {
	/*
	 * Test Case: libc-errors/struct-utsname-ref-invalid-pointer-type.idio
	 *
	 * struct-utsname-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-utsname-ref", "utsname", utsname, "C struct utsname", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct utsname *utsnamep = IDIO_C_TYPE_POINTER_P (utsname);

    /*
     * Test Case: libc-errors/struct-utsname-ref-bad-member-type.idio
     *
     * struct-utsname-ref (libc/idio-uname) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_sysname == member) {
	return idio_string_C (utsnamep->sysname);
    } else if (idio_S_nodename == member) {
	return idio_string_C (utsnamep->nodename);
    } else if (idio_S_release == member) {
	return idio_string_C (utsnamep->release);
    } else if (idio_S_version == member) {
	return idio_string_C (utsnamep->version);
    } else if (idio_S_machine == member) {
	return idio_string_C (utsnamep->machine);
    } else {
	/*
	 * Test Case: libc-errors/struct-utsname-ref-invalid-member.idio
	 *
	 * struct-utsname-ref (libc/idio-uname) 'not-likely
	 */
        idio_error_param_value_exp ("struct-utsname-ref", "member", member, "C struct utsname member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_utsname_as_string (struct utsname *utsnamep)
{
    IDIO_C_ASSERT (utsnamep);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-utsname", CSI_sh);

    idio_display_C (" sysname:", CSI_sh);

    idio_display_C (utsnamep->sysname, CSI_sh);

    idio_display_C (" nodename:", CSI_sh);

    idio_display_C (utsnamep->nodename, CSI_sh);

    idio_display_C (" release:", CSI_sh);

    idio_display_C (utsnamep->release, CSI_sh);

    idio_display_C (" version:", CSI_sh);

    idio_display_C (utsnamep->version, CSI_sh);

    idio_display_C (" machine:", CSI_sh);

    idio_display_C (utsnamep->machine, CSI_sh);

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-utsname-as-string", libc_struct_utsname_as_string, (IDIO utsname), "utsname", "\
:param utsname: C struct utsname	\n\
:type utsname: C/pointer		\n\
:return: string				\n\
:rtype:	string				\n\
")
{
    IDIO_ASSERT (utsname);

    /*
     * Test Case: libc-errors/struct-utsname-as-string-bad-pointer-type.idio
     *
     * struct-utsname-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, utsname);
    if (idio_CSI_libc_struct_utsname != IDIO_C_TYPE_POINTER_PTYPE (utsname)) {
	/*
	 * Test Case: libc-errors/struct-utsname-as-string-invalid-pointer-type.idio
	 *
	 * struct-utsname-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-utsname-as-string", "utsname", utsname, "C struct utsname", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_utsname_as_string (IDIO_C_TYPE_POINTER_P (utsname));
}

/*
	/usr/include/sys/times.h

	struct tms
	{
	  clock_t              tms_utime;
	  clock_t              tms_stime;
	  clock_t              tms_cutime;
	  clock_t              tms_cstime;
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_tms);
IDIO_SYMBOL_DECL (tms_utime);
IDIO_SYMBOL_DECL (tms_stime);
IDIO_SYMBOL_DECL (tms_cutime);
IDIO_SYMBOL_DECL (tms_cstime);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-tms-ref", libc_struct_tms_ref, (IDIO tms, IDIO member), "tms member", "\
in C, tms->member			\n\
					\n\
:param tms: C struct tms		\n\
:type tms: C/pointer			\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: tms->member			\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (tms);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-tms-ref-bad-pointer-type.idio
     *
     * struct-tms-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tms);
    if (idio_CSI_libc_struct_tms != IDIO_C_TYPE_POINTER_PTYPE (tms)) {
	/*
	 * Test Case: libc-errors/struct-tms-ref-invalid-pointer-type.idio
	 *
	 * struct-tms-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-tms-ref", "tms", tms, "C struct tms", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tms *tmsp = IDIO_C_TYPE_POINTER_P (tms);

    /*
     * Test Case: libc-errors/struct-tms-ref-bad-member-type.idio
     *
     * struct-tms-ref (pht (libc/times)) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tms_utime == member) {
        return idio_libc_clock_t (tmsp->tms_utime);
    } else if (idio_S_tms_stime == member) {
        return idio_libc_clock_t (tmsp->tms_stime);
    } else if (idio_S_tms_cutime == member) {
        return idio_libc_clock_t (tmsp->tms_cutime);
    } else if (idio_S_tms_cstime == member) {
        return idio_libc_clock_t (tmsp->tms_cstime);
    } else {
	/*
	 * Test Case: libc-errors/struct-tms-ref-invalid-member.idio
	 *
	 * struct-tms-ref (pht (libc/times)) 'not-likely
	 */
        idio_error_param_value_exp ("struct-tms-ref", "member", member, "C struct tms member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_tms_as_string (struct tms *tmsp)
{
    IDIO_C_ASSERT (tmsp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-tms", CSI_sh);

    char buf[BUFSIZ];
    char *fmt;

    idio_display_C (" tms_utime:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_clock_t);
    idio_snprintf (buf, BUFSIZ, fmt, tmsp->tms_utime);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tms_stime:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_clock_t);
    idio_snprintf (buf, BUFSIZ, fmt, tmsp->tms_stime);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tms_cutime:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_clock_t);
    idio_snprintf (buf, BUFSIZ, fmt, tmsp->tms_cutime);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tms_cstime:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_clock_t);
    idio_snprintf (buf, BUFSIZ, fmt, tmsp->tms_cstime);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-tms-as-string", libc_struct_tms_as_string, (IDIO tms), "tms", "\
:param tms: C struct tms	\n\
:type tms: C/pointer		\n\
:return: string			\n\
:rtype:	string			\n\
")
{
    IDIO_ASSERT (tms);

    /*
     * Test Case: libc-errors/struct-tms-as-string-bad-pointer-type.idio
     *
     * struct-tms-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tms);
    if (idio_CSI_libc_struct_tms != IDIO_C_TYPE_POINTER_PTYPE (tms)) {
	/*
	 * Test Case: libc-errors/struct-tms-as-string-invalid-pointer-type.idio
	 *
	 * struct-tms-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-tms-as-string", "tms", tms, "C struct tms", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_tms_as_string (IDIO_C_TYPE_POINTER_P (tms));
}

/*
	/usr/include/bits/termios-struct.h

	struct termios
	{
	  tcflag_t             c_iflag;
	  tcflag_t             c_oflag;
	  tcflag_t             c_cflag;
	  tcflag_t             c_lflag;
	  cc_t                 c_line;		Linux
	  cc_t[]               c_cc;
	  speed_t              c_ispeed;	not SunOS; int on OpenBSD
	  speed_t              c_ospeed;	not SunOS; int on OpenBSD
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_termios);
IDIO_SYMBOL_DECL (c_iflag);
IDIO_SYMBOL_DECL (c_oflag);
IDIO_SYMBOL_DECL (c_cflag);
IDIO_SYMBOL_DECL (c_lflag);
IDIO_SYMBOL_DECL (c_line);
IDIO_SYMBOL_DECL (c_cc);
IDIO_SYMBOL_DECL (c_ispeed);
IDIO_SYMBOL_DECL (c_ospeed);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-termios-ref", libc_struct_termios_ref, (IDIO termios, IDIO member), "termios member", "\
in C, termios->member			\n\
					\n\
:param termios: C struct termios	\n\
:type termios: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: termios->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (termios);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-termios-ref-bad-pointer-type.idio
     *
     * struct-termios-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, termios);
    if (idio_CSI_libc_struct_termios != IDIO_C_TYPE_POINTER_PTYPE (termios)) {
	/*
	 * Test Case: libc-errors/struct-termios-ref-invalid-pointer-type.idio
	 *
	 * struct-termios-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-termios-ref", "termios", termios, "C struct termios", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct termios *termiosp = IDIO_C_TYPE_POINTER_P (termios);

    /*
     * Test Case: libc-errors/struct-termios-ref-bad-member-type.idio
     *
     * struct-termios-ref (libc/tcgetattr libc/STDIN_FILENO) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_c_iflag == member) {
        return idio_libc_tcflag_t (termiosp->c_iflag);
    } else if (idio_S_c_oflag == member) {
        return idio_libc_tcflag_t (termiosp->c_oflag);
    } else if (idio_S_c_cflag == member) {
        return idio_libc_tcflag_t (termiosp->c_cflag);
    } else if (idio_S_c_lflag == member) {
        return idio_libc_tcflag_t (termiosp->c_lflag);
    } else if (idio_S_c_cc == member) {
        /*
         * WARNING:
         * cc_t[] c_cc
         *
         * sizeof (termiosp->c_cc) is probably incorrect
         *
         * check the API
         */
        size_t alen = sizeof (termiosp->c_cc);
        cc_t *rp = (cc_t *) idio_alloc (alen);
        memcpy ((void *) rp, (void *) &termiosp->c_cc, alen);
        return idio_C_pointer_free_me (rp);
    }
#if defined (__sun) && defined (__SVR4)
#else
    else if (idio_S_c_ispeed == member) {
        return idio_libc_speed_t (termiosp->c_ispeed);
    } else if (idio_S_c_ospeed == member) {
        return idio_libc_speed_t (termiosp->c_ospeed);
    }
#endif
    else {
	/*
	 * Test Case: libc-errors/struct-termios-ref-invalid-member.idio
	 *
	 * struct-termios-ref (libc/tcgetattr libc/STDIN_FILENO) 'not-likely
	 */
        idio_error_param_value_exp ("struct-tms-ref", "member", member, "C struct termios member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO_DEFINE_PRIMITIVE3_DS ("struct-termios-set!", libc_struct_termios_set, (IDIO termios, IDIO member, IDIO val), "termios member val", "\
in C, termios->member = val		\n\
					\n\
:param termios: C struct termios	\n\
:type termios: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:param val: C/type val			\n\
:type val: varies on member		\n\
:return: termios->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (termios);
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);

    /*
     * Test Case: libc-errors/struct-termios-set-bad-pointer-type.idio
     *
     * struct-termios-set! #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, termios);
    if (idio_CSI_libc_struct_termios != IDIO_C_TYPE_POINTER_PTYPE (termios)) {
	/*
	 * Test Case: libc-errors/struct-termios-set-invalid-pointer-type.idio
	 *
	 * struct-termios-set! libc/NULL #t #t
	 */
	idio_error_param_value_exp ("struct-termios-set!", "termios", termios, "C struct termios", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct termios *termiosp = IDIO_C_TYPE_POINTER_P (termios);

    /*
     * Test Case: libc-errors/struct-termios-set-bad-member-type.idio
     *
     * struct-termios-set! (libc/tcgetattr libc/STDIN_FILENO) #t #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_c_iflag == member) {
       /*
	* Test Case: not yet: libc-errors/struct-termios-set-c_iflag-bad-value-type.idio
	*
	* struct-termios-set! v 'c_iflag #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (tcflag_t, val);

        termiosp->c_iflag = IDIO_C_TYPE_libc_tcflag_t (val);
        return idio_S_unspec;
    } else if (idio_S_c_oflag == member) {
       /*
	* Test Case: not yet: libc-errors/struct-termios-set-c_oflag-bad-value-type.idio
	*
	* struct-termios-set! v 'c_oflag #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (tcflag_t, val);

        termiosp->c_oflag = IDIO_C_TYPE_libc_tcflag_t (val);
        return idio_S_unspec;
    } else if (idio_S_c_cflag == member) {
       /*
	* Test Case: not yet: libc-errors/struct-termios-set-c_cflag-bad-value-type.idio
	*
	* struct-termios-set! v 'c_cflag #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (tcflag_t, val);

        termiosp->c_cflag = IDIO_C_TYPE_libc_tcflag_t (val);
        return idio_S_unspec;
    } else if (idio_S_c_lflag == member) {
       /*
	* Test Case: not yet: libc-errors/struct-termios-set-c_lflag-bad-value-type.idio
	*
	* struct-termios-set! v 'c_lflag #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (tcflag_t, val);

        termiosp->c_lflag = IDIO_C_TYPE_libc_tcflag_t (val);
        return idio_S_unspec;
    } else if (idio_S_c_cc == member) {
       /*
	* Test Case: not yet: libc-errors/struct-termios-set-c_cc-bad-value-type.idio
	*
	* struct-termios-set! v 'c_cc #t
	*/
	IDIO_USER_C_TYPE_ASSERT (pointer, val);

        /*
         * WARNING:
         * cc_t[] c_cc
         *
         * sizeof (termiosp->c_cc) is possibly incorrect
         *
         * check the API
         */
        cc_t *valp = IDIO_C_TYPE_POINTER_P (val);
        size_t alen = sizeof (termiosp->c_cc);
        memcpy ((void *) &termiosp->c_cc, (void *) valp, alen);
        return idio_S_unspec;
    }
#if defined (__sun) && defined (__SVR4)
#else
    else if (idio_S_c_ispeed == member) {
       /*
	* Test Case: libc-errors/struct-termios-set-c_ispeed-bad-value-type.idio
	*
	* struct-termios-set! v 'c_ispeed #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (speed_t, val);

        termiosp->c_ispeed = IDIO_C_TYPE_libc_speed_t (val);
        return idio_S_unspec;
    } else if (idio_S_c_ospeed == member) {
       /*
	* Test Case: libc-errors/struct-termios-set-c_ospeed-bad-value-type.idio
	*
	* struct-termios-set! v 'c_ospeed #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (speed_t, val);

        termiosp->c_ospeed = IDIO_C_TYPE_libc_speed_t (val);
        return idio_S_unspec;
    }
#endif
    else {
	/*
	 * Test Case: libc-errors/struct-termios-set-invalid-member.idio
	 *
	 * struct-termios-set! v 'not-likely #t
	 */
        idio_error_param_value_exp ("struct-termios-set!", "member", member, "C struct termios member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_termios_as_string (struct termios *termiosp)
{
    IDIO_C_ASSERT (termiosp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-termios", CSI_sh);

    char buf[BUFSIZ];
    char *fmt;

    idio_display_C (" c_iflag:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_tcflag_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_iflag);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" c_oflag:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_tcflag_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_oflag);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" c_cflag:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_tcflag_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_cflag);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" c_lflag:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_tcflag_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_lflag);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" c_cc:", CSI_sh);

    idio_display_C ("<<1cc_t[]>>", CSI_sh);

#if defined (__sun) && defined (__SVR4)
#else
    idio_display_C (" c_ispeed:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_speed_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_ispeed);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" c_ospeed:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_speed_t);
    idio_snprintf (buf, BUFSIZ, fmt, termiosp->c_ospeed);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);
#endif

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-termios-as-string", libc_struct_termios_as_string, (IDIO termios), "termios", "\
:param termios: C struct termios	\n\
:type termios: C/pointer		\n\
:return: string				\n\
:rtype:	string				\n\
")
{
    IDIO_ASSERT (termios);

    /*
     * Test Case: libc-errors/struct-termios-as-string-bad-pointer-type.idio
     *
     * struct-termios-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, termios);
    if (idio_CSI_libc_struct_termios != IDIO_C_TYPE_POINTER_PTYPE (termios)) {
	/*
	 * Test Case: libc-errors/struct-termios-as-string-invalid-pointer-type.idio
	 *
	 * struct-termios-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-termios-as-string", "termios", termios, "C struct termios", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_termios_as_string (IDIO_C_TYPE_POINTER_P (termios));
}

/*
	/usr/include/bits/types/struct_tm.h

	struct tm
	{
	  int                  tm_sec;
	  int                  tm_min;
	  int                  tm_hour;
	  int                  tm_mday;
	  int                  tm_mon;
	  int                  tm_year;
	  int                  tm_wday;
	  int                  tm_yday;
	  int                  tm_isdst;
	  long int             tm_gmtoff;	not SunOS
	  char*                tm_zone;		not SunOS
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_tm);
IDIO_SYMBOL_DECL (tm_sec);
IDIO_SYMBOL_DECL (tm_min);
IDIO_SYMBOL_DECL (tm_hour);
IDIO_SYMBOL_DECL (tm_mday);
IDIO_SYMBOL_DECL (tm_mon);
IDIO_SYMBOL_DECL (tm_year);
IDIO_SYMBOL_DECL (tm_wday);
IDIO_SYMBOL_DECL (tm_yday);
IDIO_SYMBOL_DECL (tm_isdst);
#if defined (__sun) && defined (__SVR4)
#else
IDIO_SYMBOL_DECL (tm_gmtoff);
IDIO_SYMBOL_DECL (tm_zone);
#endif

IDIO_DEFINE_PRIMITIVE2_DS ("struct-tm-ref", libc_struct_tm_ref, (IDIO tm, IDIO member), "tm member", "\
in C, tm->member			\n\
					\n\
:param tm: C struct tm	\n\
:type tm: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: tm->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (tm);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-tm-ref-bad-pointer-type.idio
     *
     * struct-tm-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/struct-tm-ref-invalid-pointer-type.idio
	 *
	 * struct-tm-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-tm-ref", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tm *tmp = IDIO_C_TYPE_POINTER_P (tm);

    /*
     * Test Case: libc-errors/struct-tm-ref-bad-member-type.idio
     *
     * struct-tm-ref v #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tm_sec == member) {
        return idio_C_int (tmp->tm_sec);
    } else if (idio_S_tm_min == member) {
        return idio_C_int (tmp->tm_min);
    } else if (idio_S_tm_hour == member) {
        return idio_C_int (tmp->tm_hour);
    } else if (idio_S_tm_mday == member) {
        return idio_C_int (tmp->tm_mday);
    } else if (idio_S_tm_mon == member) {
        return idio_C_int (tmp->tm_mon);
    } else if (idio_S_tm_year == member) {
        return idio_C_int (tmp->tm_year);
    } else if (idio_S_tm_wday == member) {
        return idio_C_int (tmp->tm_wday);
    } else if (idio_S_tm_yday == member) {
        return idio_C_int (tmp->tm_yday);
    } else if (idio_S_tm_isdst == member) {
        return idio_C_int (tmp->tm_isdst);
    }
#if defined (__sun) && defined (__SVR4)
#else
    else if (idio_S_tm_gmtoff == member) {
        return idio_C_long (tmp->tm_gmtoff);
    } else if (idio_S_tm_zone == member) {
        /*
         * WARNING:
         * char* tm_zone
         *
         * sizeof (tmp->tm_zone) is dubious
         *
         * check the API
         */
        size_t slen = sizeof (tmp->tm_zone);
        char* rp = (char*) idio_alloc (slen);
        memcpy ((void *) rp, (void *) &tmp->tm_zone, slen);
	return idio_C_pointer_free_me (rp);
    }
#endif
    else {
	/*
	 * Test Case: libc-errors/struct-tm-ref-invalid-member.idio
	 *
	 * struct-tm-ref v 'not-likely
	 */
        idio_error_param_value_exp ("struct-tm-ref", "member", member, "C struct tm member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO_DEFINE_PRIMITIVE3_DS ("struct-tm-set!", libc_struct_tm_set, (IDIO tm, IDIO member, IDIO val), "tm member val", "\
in C, tm->member = val		\n\
					\n\
:param tm: C struct tm	\n\
:type tm: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:param val: C/type val			\n\
:type val: varies on member		\n\
:return: tm->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (tm);
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);


    /*
     * Test Case: libc-errors/struct-tm-set-bad-pointer-type.idio
     *
     * struct-tm-set! #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/struct-tm-set-invalid-pointer-type.idio
	 *
	 * struct-tm-set! libc/NULL #t #t
	 */
	idio_error_param_value_exp ("struct-tm-set!", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tm *tmp = IDIO_C_TYPE_POINTER_P (tm);

    /*
     * Test Case: libc-errors/struct-tm-set-bad-member-type.idio
     *
     * struct-tm-set! v #t #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tm_sec == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_sec-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_sec #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_sec = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_min == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_min-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_min #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_min = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_hour == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_hour-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_hour #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_hour = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_mday == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_mday-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_mday #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_mday = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_mon == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_mon-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_mon #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_mon = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_year == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_year-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_year #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_year = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_wday == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_wday-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_wday #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_wday = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_yday == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_yday-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_yday #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_yday = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    } else if (idio_S_tm_isdst == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_isdst-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_isdst #t
	*/
	IDIO_USER_C_TYPE_ASSERT (int, val);

        tmp->tm_isdst = IDIO_C_TYPE_int (val);
        return idio_S_unspec;
    }
#if defined (__sun) && defined (__SVR4)
#else    
    else if (idio_S_tm_gmtoff == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_gmtoff-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_gmtoff #t
	*/
	IDIO_USER_C_TYPE_ASSERT (long, val);

        tmp->tm_gmtoff = IDIO_C_TYPE_long (val);
        return idio_S_unspec;
    } else if (idio_S_tm_zone == member) {
       /*
	* Test Case: libc-errors/struct-tm-set-tm_zone-bad-value-type.idio
	*
	* struct-tm-set! v 'tm_zone #t
	*/
	IDIO_USER_C_TYPE_ASSERT (pointer, val);

        /*
         * WARNING:
         * char* tm_zone
         *
         * sizeof (tmp->tm_zone) is dubious
         *
         * check the API
         */
        char* valp = IDIO_C_TYPE_POINTER_P (val);
        size_t slen = sizeof (tmp->tm_zone);
        memcpy ((void *) &tmp->tm_zone, (void *) valp, slen);
        return idio_S_unspec;
    }
#endif
    else {
	/*
	 * Test Case: libc-errors/struct-tm-set-invalid-member.idio
	 *
	 * struct-tm-set! v 'not-likely #t
	 */
        idio_error_param_value_exp ("struct-tm-set!", "member", member, "C struct tm member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_tm_as_string (struct tm *tmp)
{
    IDIO_C_ASSERT (tmp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-tm", CSI_sh);

    char buf[BUFSIZ];
    char *fmt;

    idio_display_C (" tm_sec:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_sec);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_min:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_min);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_hour:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_hour);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_mday:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_mday);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_mon:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_mon);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_year:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_year);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_wday:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_wday);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_yday:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_yday);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_isdst:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_INT);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_isdst);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

#if defined (__sun) && defined (__SVR4)
#else
    idio_display_C (" tm_gmtoff:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_LONG);
    idio_snprintf (buf, BUFSIZ, fmt, tmp->tm_gmtoff);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" tm_zone:", CSI_sh);

    if (tmp->tm_zone) {
	idio_display_C (tmp->tm_zone, CSI_sh);
    } else {
	idio_display_C ("(nil)", CSI_sh);
    }
#endif

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-tm-as-string", libc_struct_tm_as_string, (IDIO tm), "tm", "\
:param tm: C struct tm	\n\
:type tm: C/pointer			\n\
:return: string				\n\
:rtype:	string				\n\
")
{
    IDIO_ASSERT (tm);

    /*
     * Test Case: libc-errors/struct-tm-as-string-bad-pointer-type.idio
     *
     * struct-tm-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/struct-tm-as-string-invalid-pointer-type.idio
	 *
	 * struct-tm-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-tm-as-string", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_tm_as_string (IDIO_C_TYPE_POINTER_P (tm));
}

/*
	/usr/include/bits/struct_stat.h

	struct stat
	{
	  dev_t                st_dev;
	  ino_t                st_ino;
	  nlink_t              st_nlink;
	  mode_t               st_mode;
	  uid_t                st_uid;
	  gid_t                st_gid;
	  int                  __pad0;			Linux
	  dev_t                st_rdev;
	  off_t                st_size;
	  blksize_t            st_blksize;
	  blkcnt_t             st_blocks;
	  struct timespec      st_atim;
	  struct timespec      st_mtim;
	  struct timespec      st_ctim;
	  __syscall_slong_t[]  __glibc_reserved;	Linux
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_stat);
IDIO_SYMBOL_DECL (st_dev);
IDIO_SYMBOL_DECL (st_ino);
IDIO_SYMBOL_DECL (st_nlink);
IDIO_SYMBOL_DECL (st_mode);
IDIO_SYMBOL_DECL (st_uid);
IDIO_SYMBOL_DECL (st_gid);
IDIO_SYMBOL_DECL (st_rdev);
IDIO_SYMBOL_DECL (st_size);
IDIO_SYMBOL_DECL (st_blksize);
IDIO_SYMBOL_DECL (st_blocks);
IDIO_SYMBOL_DECL (st_atim);
IDIO_SYMBOL_DECL (st_mtim);
IDIO_SYMBOL_DECL (st_ctim);

/* specials */
IDIO_SYMBOL_DECL (st_atime);
IDIO_SYMBOL_DECL (st_mtime);
IDIO_SYMBOL_DECL (st_ctime);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-stat-ref", libc_struct_stat_ref, (IDIO stat, IDIO member), "stat member", "\
in C, stat->member			\n\
					\n\
:param stat: C struct stat	\n\
:type stat: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: stat->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (stat);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-stat-ref-bad-pointer-type.idio
     *
     * struct-stat-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, stat);
    if (idio_CSI_libc_struct_stat != IDIO_C_TYPE_POINTER_PTYPE (stat)) {
	/*
	 * Test Case: libc-errors/struct-stat-ref-invalid-pointer-type.idio
	 *
	 * struct-stat-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-stat-ref", "stat", stat, "C struct stat", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct stat *statp = IDIO_C_TYPE_POINTER_P (stat);

    /*
     * Test Case: libc-errors/struct-stat-ref-bad-member-type.idio
     *
     * struct-stat-ref (libc/stat ".") #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_st_dev == member) {
        return idio_libc_dev_t (statp->st_dev);
    } else if (idio_S_st_ino == member) {
        return idio_libc_ino_t (statp->st_ino);
    } else if (idio_S_st_nlink == member) {
        return idio_libc_nlink_t (statp->st_nlink);
    } else if (idio_S_st_mode == member) {
        return idio_libc_mode_t (statp->st_mode);
    } else if (idio_S_st_uid == member) {
        return idio_libc_uid_t (statp->st_uid);
    } else if (idio_S_st_gid == member) {
        return idio_libc_gid_t (statp->st_gid);
    } else if (idio_S_st_rdev == member) {
        return idio_libc_dev_t (statp->st_rdev);
    } else if (idio_S_st_size == member) {
        return idio_libc_off_t (statp->st_size);
    } else if (idio_S_st_blksize == member) {
        return idio_libc_blksize_t (statp->st_blksize);
    } else if (idio_S_st_blocks == member) {
        return idio_libc_blkcnt_t (statp->st_blocks);
    } else if (idio_S_st_atim == member) {
        struct timespec *rp = (struct timespec *) idio_alloc (sizeof (struct timespec));
#if defined (__APPLE__) && defined (__MACH__)
        memcpy ((void *) rp, (void *) &statp->st_atimespec, sizeof (struct timespec));
#else
        memcpy ((void *) rp, (void *) &statp->st_atim, sizeof (struct timespec));
#endif
        return idio_C_pointer_type (idio_CSI_libc_struct_timespec, rp);
    } else if (idio_S_st_atime == member) {
#if defined (__APPLE__) && defined (__MACH__)
        return idio_libc_time_t(statp->st_atimespec.tv_sec);
#else
        return idio_libc_time_t(statp->st_atim.tv_sec);
#endif
    } else if (idio_S_st_mtim == member) {
        struct timespec *rp = (struct timespec *) idio_alloc (sizeof (struct timespec));
#if defined (__APPLE__) && defined (__MACH__)
        memcpy ((void *) rp, (void *) &statp->st_mtimespec, sizeof (struct timespec));
#else
        memcpy ((void *) rp, (void *) &statp->st_mtim, sizeof (struct timespec));
#endif
        return idio_C_pointer_type (idio_CSI_libc_struct_timespec, rp);
    } else if (idio_S_st_mtime == member) {
#if defined (__APPLE__) && defined (__MACH__)
        return idio_libc_time_t (statp->st_mtimespec.tv_sec);
#else
        return idio_libc_time_t (statp->st_mtim.tv_sec);
#endif
    } else if (idio_S_st_ctim == member) {
        struct timespec *rp = (struct timespec *) idio_alloc (sizeof (struct timespec));
#if defined (__APPLE__) && defined (__MACH__)
        memcpy ((void *) rp, (void *) &statp->st_ctimespec, sizeof (struct timespec));
#else
        memcpy ((void *) rp, (void *) &statp->st_ctim, sizeof (struct timespec));
#endif
        return idio_C_pointer_type (idio_CSI_libc_struct_timespec, rp);
    } else if (idio_S_st_ctime == member) {
#if defined (__APPLE__) && defined (__MACH__)
        return idio_libc_time_t (statp->st_ctimespec.tv_sec);
#else
        return idio_libc_time_t (statp->st_ctim.tv_sec);
#endif
    } else {
	/*
	 * Test Case: libc-errors/struct-stat-ref-invalid-member.idio
	 *
	 * struct-stat-ref (libc/stat ".") 'not-likely
	 */
        idio_error_param_value_exp ("struct-stat-ref", "member", member, "C struct stat member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_stat_as_string (struct stat *statp)
{
    IDIO_C_ASSERT (statp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-stat", CSI_sh);

    char buf[BUFSIZ];
    char *fmt;

    idio_display_C (" st_dev:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_dev_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_dev);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_ino:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_ino_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_ino);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_nlink:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_nlink_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_nlink);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_mode:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_mode_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_mode);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_uid:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_uid_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_uid);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_gid:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_gid_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_gid);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_rdev:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_dev_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_rdev);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_size:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_off_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_size);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_blksize:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_blksize_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_blksize);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_blocks:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_blkcnt_t);
    idio_snprintf (buf, BUFSIZ, fmt, statp->st_blocks);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" st_atim:", CSI_sh);

#if defined (__APPLE__) && defined (__MACH__)
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_atimespec)), CSI_sh);
#else
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_atim)), CSI_sh);
#endif

    idio_display_C (" st_mtim:", CSI_sh);

#if defined (__APPLE__) && defined (__MACH__)
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_mtimespec)), CSI_sh);
#else
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_mtim)), CSI_sh);
#endif

    idio_display_C (" st_ctim:", CSI_sh);

#if defined (__APPLE__) && defined (__MACH__)
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_ctimespec)), CSI_sh);
#else
    idio_display (idio_libc_struct_timespec_as_string (&(statp->st_ctim)), CSI_sh);
#endif

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-stat-as-string", libc_struct_stat_as_string, (IDIO stat), "stat", "\
:param stat: C struct stat	\n\
:type stat: C/pointer		\n\
:return: string			\n\
:rtype:	string			\n\
")
{
    IDIO_ASSERT (stat);

    /*
     * Test Case: libc-errors/struct-stat-as-string-bad-pointer-type.idio
     *
     * struct-stat-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, stat);
    if (idio_CSI_libc_struct_stat != IDIO_C_TYPE_POINTER_PTYPE (stat)) {
	/*
	 * Test Case: libc-errors/struct-stat-as-string-invalid-pointer-type.idio
	 *
	 * struct-stat-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-stat-as-string", "stat", stat, "C struct stat", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_stat_as_string (IDIO_C_TYPE_POINTER_P (stat));
}

/*
	/usr/include/bits/types/struct_timespec.h

	struct timespec
	{
	  time_t               tv_sec;
	  __syscall_slong_t    tv_nsec;		a long?
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_timespec);
IDIO_SYMBOL_DECL (tv_sec);
IDIO_SYMBOL_DECL (tv_nsec);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-timespec-ref", libc_struct_timespec_ref, (IDIO timespec, IDIO member), "timespec member", "\
in C, timespec->member			\n\
					\n\
:param timespec: C struct timespec	\n\
:type timespec: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: timespec->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (timespec);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-timespec-ref-bad-pointer-type.idio
     *
     * struct-timespec-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timespec);
    if (idio_CSI_libc_struct_timespec != IDIO_C_TYPE_POINTER_PTYPE (timespec)) {
	/*
	 * Test Case: libc-errors/struct-timespec-ref-invalid-pointer-type.idio
	 *
	 * struct-timespec-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-timespec-ref", "timespec", timespec, "C struct timespec", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct timespec *timespecp = IDIO_C_TYPE_POINTER_P (timespec);

    /*
     * Test Case: libc-errors/struct-timespec-ref-bad-member-type.idio
     *
     * statbuf := libc/stat "."
     * struct-timespec-ref statbuf.st_atim #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tv_sec == member) {
        return idio_libc_time_t (timespecp->tv_sec);
    } else if (idio_S_tv_nsec == member) {
        return idio_C_long (timespecp->tv_nsec);
    } else {
	/*
	 * Test Case: libc-errors/struct-timespec-ref-invalid-member.idio
	 *
	 * statbuf := libc/stat "."
	 * struct-timespec-ref statbuf.st_atim 'not-likely
	 */
        idio_error_param_value_exp ("struct-timespec-ref", "member", member, "C struct timespec member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO_DEFINE_PRIMITIVE3_DS ("struct-timespec-set!", libc_struct_timespec_set, (IDIO timespec, IDIO member, IDIO val), "timespec member val", "\
in C, timespec->member = val		\n\
					\n\
:param timespec: C struct timespec	\n\
:type timespec: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:param val: C/type val			\n\
:type val: varies on member		\n\
:return: timespec->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (timespec);
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);

    /*
     * Test Case: libc-errors/struct-timespec-set-bad-pointer-type.idio
     *
     * struct-timespec-set! #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timespec);
    if (idio_CSI_libc_struct_timespec != IDIO_C_TYPE_POINTER_PTYPE (timespec)) {
	/*
	 * Test Case: libc-errors/struct-timespec-set-invalid-pointer-type.idio
	 *
	 * struct-timespec-set! libc/NULL #t #t
	 */
	idio_error_param_value_exp ("struct-timespec-set!", "timespec", timespec, "C struct timespec", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct timespec *timespecp = IDIO_C_TYPE_POINTER_P (timespec);

    /*
     * Test Case: libc-errors/struct-timespec-set-bad-member-type.idio
     *
     * statbuf := libc/stat "."
     * struct-timespec-set! statbuf.st_atim #t #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tv_sec == member) {
       /*
	* Test Case: not yet: libc-errors/struct-timespec-set-tv_sec-bad-value-type.idio
	*
	* struct-timespec-set! v 'tv_sec #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (time_t, val);

        timespecp->tv_sec = IDIO_C_TYPE_libc_time_t (val);
        return idio_S_unspec;
    } else if (idio_S_tv_nsec == member) {
       /*
	* Test Case: not yet: libc-errors/struct-timespec-set-tv_nsec-bad-value-type.idio
	*
	* struct-timespec-set! v 'tv_nsec #t
	*/
	IDIO_USER_C_TYPE_ASSERT (long, val);

        timespecp->tv_nsec = IDIO_C_TYPE_long (val);
        return idio_S_unspec;
    } else {
	/*
	 * Test Case: libc-errors/struct-timespec-set-invalid-member.idio
	 *
	 * statbuf := libc/stat "."
	 * struct-timespec-set! statbuf.st_atim 'not-likely
	 */
        idio_error_param_value_exp ("struct-timespec-set!", "member", member, "C struct timespec member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_timespec_as_string (struct timespec *timespecp)
{
    IDIO_C_ASSERT (timespecp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    char buf[BUFSIZ];
    char *fmt;

    /*
     * In the style of timeval (using micro-seconds) lets ensure the
     * timespec's nanoseconds are length-limited.
     *
     * The printing of a timespec is a %ld.%09ld style with the even
     * more correct form of %ld.%.*ld using some precision
     */
    int prec = 9;
    if (idio_S_nil != idio_print_conversion_precision_sym) {
	IDIO ipcp = idio_module_symbol_value (idio_print_conversion_precision_sym,
					      idio_Idio_module,
					      IDIO_LIST1 (idio_S_false));

	if (idio_S_false != ipcp) {
	    if (idio_isa_fixnum (ipcp)) {
		prec = IDIO_FIXNUM_VAL (ipcp);
	    } else {
		/*
		 * Test Case: ??
		 *
		 * If we set idio-print-conversion-precision to
		 * something not a fixnum (nor #f) then it affects
		 * *everything* in the codebase that uses
		 * idio-print-conversion-precision before we get here.
		 */
		idio_error_param_type ("fixnum", ipcp, IDIO_C_FUNC_LOCATION ());

		/* notreached */
		return NULL;
	    }
	}
    }

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_time_t);
    idio_snprintf (buf, BUFSIZ, fmt, timespecp->tv_sec);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (".", CSI_sh);

    /*
     * __syscall_slong_t **must** be 9 digits -- it is nano-seconds,
     * not micro-seconds or anything else.
     *
     * prec, therefore cannot be greater than 9
     *
     * However, we need to apply the prec to the leading-0-padded
     * string.  That's because 1ns -> ".000000001" and a prec of 3 =>
     * ".000"
     */
    char us[30];
    idio_snprintf (us, 30, "%09ld", timespecp->tv_nsec);
    char sfmt[30];
    if (prec > 9) {
	prec = 9;
    }
    idio_snprintf (sfmt, 30, "%%.%ds", prec);
    idio_snprintf (buf, BUFSIZ, sfmt, us);
    idio_display_C (buf, CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-timespec-as-string", libc_struct_timespec_as_string, (IDIO timespec), "timespec", "\
:param timespec: C struct timespec	\n\
:type timespec: C/pointer		\n\
:return: string				\n\
:rtype:	string				\n\
")
{
    IDIO_ASSERT (timespec);

    /*
     * Test Case: libc-errors/struct-timespec-as-string-bad-pointer-type.idio
     *
     * struct-timespec-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timespec);
    if (idio_CSI_libc_struct_timespec != IDIO_C_TYPE_POINTER_PTYPE (timespec)) {
	/*
	 * Test Case: libc-errors/struct-timespec-as-string-invalid-pointer-type.idio
	 *
	 * struct-timespec-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-timespec-as-string", "timespec", timespec, "C struct timespec", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_timespec_as_string (IDIO_C_TYPE_POINTER_P (timespec));
}

/*
	/usr/include/bits/resource.h

	struct rlimit
	{
	  rlim_t               rlim_cur;
	  rlim_t               rlim_max;
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_rlimit);
IDIO_SYMBOL_DECL (rlim_cur);
IDIO_SYMBOL_DECL (rlim_max);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-rlimit-ref", libc_struct_rlimit_ref, (IDIO rlimit, IDIO member), "rlimit member", "\
in C, rlimit->member			\n\
					\n\
:param rlimit: C struct rlimit	\n\
:type rlimit: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: rlimit->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (rlimit);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-rlimit-ref-bad-pointer-type.idio
     *
     * struct-rlimit-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rlimit);
    if (idio_CSI_libc_struct_rlimit != IDIO_C_TYPE_POINTER_PTYPE (rlimit)) {
	/*
	 * Test Case: libc-errors/struct-rlimit-ref-invalid-pointer-type.idio
	 *
	 * struct-rlimit-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-rlimit-ref", "rlimit", rlimit, "C struct rlimit", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct rlimit *rlimitp = IDIO_C_TYPE_POINTER_P (rlimit);

    /*
     * Test Case: libc-errors/struct-rlimit-ref-bad-member-type.idio
     *
     * struct-rlimit-ref (libc/getrlimit libc/RLIMIT_NOFILE) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_rlim_cur == member) {
        return idio_libc_rlim_t (rlimitp->rlim_cur);
    } else if (idio_S_rlim_max == member) {
        return idio_libc_rlim_t (rlimitp->rlim_max);
    } else {
	/*
	 * Test Case: libc-errors/struct-rlimit-ref-invalid-member.idio
	 *
	 * struct-rlimit-ref (libc/getrlimit libc/RLIMIT_NOFILE) 'not-likely
	 */
        idio_error_param_value_exp ("struct-rlimit-ref", "member", member, "C struct rlimit member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO_DEFINE_PRIMITIVE3_DS ("struct-rlimit-set!", libc_struct_rlimit_set, (IDIO rlimit, IDIO member, IDIO val), "rlimit member val", "\
in C, rlimit->member = val		\n\
					\n\
:param rlimit: C struct rlimit	\n\
:type rlimit: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:param val: C/type val			\n\
:type val: varies on member		\n\
:return: rlimit->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (rlimit);
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);

    /*
     * Test Case: libc-errors/struct-rlimit-set-bad-pointer-type.idio
     *
     * struct-rlimit-set! #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rlimit);
    if (idio_CSI_libc_struct_rlimit != IDIO_C_TYPE_POINTER_PTYPE (rlimit)) {
	/*
	 * Test Case: libc-errors/struct-rlimit-set-invalid-pointer-type.idio
	 *
	 * struct-rlimit-set! libc/NULL #t #t
	 */
	idio_error_param_value_exp ("struct-rlimit-set!", "rlimit", rlimit, "C struct rlimit", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct rlimit *rlimitp = IDIO_C_TYPE_POINTER_P (rlimit);

    /*
     * Test Case: libc-errors/struct-rlimit-set-bad-member-type.idio
     *
     * struct-rlimit-set! (libc/getrlimit libc/RLIMIT_NOFILE) #t #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_rlim_cur == member) {
       /*
	* Test Case: libc-errors/struct-rlimit-set-bad-value-type.idio
	*
	* struct-rlimit-set! (libc/getrlimit libc/RLIMIT_NOFILE) 'rlim_cur #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (rlim_t, val);

        rlimitp->rlim_cur = IDIO_C_TYPE_libc_rlim_t (val);
        return idio_S_unspec;
    } else if (idio_S_rlim_max == member) {
       /*
	* Test Case: libc-errors/struct-rlimit-set-bad-value-type.idio
	*
	* struct-rlimit-set! (libc/getrlimit libc/RLIMIT_NOFILE) 'rlim_max #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (rlim_t, val);

        rlimitp->rlim_max = IDIO_C_TYPE_libc_rlim_t (val);
        return idio_S_unspec;
    } else {
	/*
	 * Test Case: libc-errors/struct-rlimit-set-invalid-member.idio
	 *
	 * struct-rlimit-set! (libc/getrlimit libc/RLIMIT_NOFILE) 'not-likely
	 */
        idio_error_param_value_exp ("struct-rlimit-set!", "member", member, "C struct rlimit member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_rlimit_as_string (struct rlimit *rlimitp)
{
    IDIO_C_ASSERT (rlimitp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-rlimit", CSI_sh);

    char buf[BUFSIZ];
    char *fmt;

    idio_display_C (" rlim_cur:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_rlim_t);
    idio_snprintf (buf, BUFSIZ, fmt, rlimitp->rlim_cur);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (" rlim_max:", CSI_sh);

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_rlim_t);
    idio_snprintf (buf, BUFSIZ, fmt, rlimitp->rlim_max);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-rlimit-as-string", libc_struct_rlimit_as_string, (IDIO rlimit), "rlimit", "\
:param rlimit: C struct rlimit	\n\
:type rlimit: C/pointer		\n\
:return: string			\n\
:rtype:	string			\n\
")
{
    IDIO_ASSERT (rlimit);

    /*
     * Test Case: libc-errors/struct-rlimit-as-string-bad-pointer-type.idio
     *
     * struct-rlimit-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rlimit);
    if (idio_CSI_libc_struct_rlimit != IDIO_C_TYPE_POINTER_PTYPE (rlimit)) {
	/*
	 * Test Case: libc-errors/struct-rlimit-as-string-invalid-pointer-type.idio
	 *
	 * struct-rlimit-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-rlimit-as-string", "rlimit", rlimit, "C struct rlimit", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_rlimit_as_string (IDIO_C_TYPE_POINTER_P (rlimit));
}

/*
	/usr/include/bits/types/struct_timeval.h

	struct timeval
	{
	  time_t             tv_sec;
	  suseconds_t        tv_usec;
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_timeval);
/* tv_sec already declared */
IDIO_SYMBOL_DECL (tv_usec);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-timeval-ref", libc_struct_timeval_ref, (IDIO timeval, IDIO member), "timeval member", "\
in C, timeval->member			\n\
					\n\
:param timeval: C struct timeval	\n\
:type timeval: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: timeval->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (timeval);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-timeval-ref-bad-pointer-type.idio
     *
     * struct-timeval-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timeval);
    if (idio_CSI_libc_struct_timeval != IDIO_C_TYPE_POINTER_PTYPE (timeval)) {
	/*
	 * Test Case: libc-errors/struct-timeval-ref-invalid-pointer-type.idio
	 *
	 * struct-timeval-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-timeval-ref", "timeval", timeval, "C struct timeval", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct timeval *timevalp = IDIO_C_TYPE_POINTER_P (timeval);

    /*
     * Test Case: libc-errors/struct-timeval-ref-bad-member-type.idio
     *
     * struct-timeval-ref (libc/gettimeofday) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tv_sec == member) {
        return idio_libc_time_t (timevalp->tv_sec);
    } else if (idio_S_tv_usec == member) {
        return idio_libc_suseconds_t (timevalp->tv_usec);
    } else {
	/*
	 * Test Case: libc-errors/struct-timeval-ref-invalid-member.idio
	 *
	 * struct-timeval-ref (libc/gettimeofday) 'not-likely
	 */
        idio_error_param_value_exp ("struct-timeval-ref", "member", member, "C struct timeval member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO_DEFINE_PRIMITIVE3_DS ("struct-timeval-set!", libc_struct_timeval_set, (IDIO timeval, IDIO member, IDIO val), "timeval member val", "\
in C, timeval->member = val		\n\
					\n\
:param timeval: C struct timeval	\n\
:type timeval: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:param val: C/type val			\n\
:type val: varies on member		\n\
:return: timeval->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (timeval);
    IDIO_ASSERT (member);
    IDIO_ASSERT (val);

    /*
     * Test Case: libc-errors/struct-timeval-set-bad-pointer-type.idio
     *
     * struct-timeval-set! #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timeval);
    if (idio_CSI_libc_struct_timeval != IDIO_C_TYPE_POINTER_PTYPE (timeval)) {
	/*
	 * Test Case: libc-errors/struct-timeval-set-invalid-pointer-type.idio
	 *
	 * struct-timeval-set! libc/NULL #t #t
	 */
	idio_error_param_value_exp ("struct-timeval-set!", "timeval", timeval, "C struct timeval", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct timeval *timevalp = IDIO_C_TYPE_POINTER_P (timeval);

    /*
     * Test Case: libc-errors/struct-timeval-set-bad-member-type.idio
     *
     * struct-timeval-set! v #t #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_tv_sec == member) {
       /*
	* Test Case: not yet: libc-errors/struct-timeval-set-tv_sec-bad-value-type.idio
	*
	* struct-timeval-set! v 'tv_sec #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (time_t, val);

        timevalp->tv_sec = IDIO_C_TYPE_libc_time_t (val);
        return idio_S_unspec;
    } else if (idio_S_tv_usec == member) {
       /*
	* Test Case: not yet: libc-errors/struct-timeval-set-tv_usec-bad-value-type.idio
	*
	* struct-timeval-set! v 'tv_usec #t
	*/
	IDIO_USER_libc_TYPE_ASSERT (suseconds_t, val);

        timevalp->tv_usec = IDIO_C_TYPE_libc_suseconds_t (val);
        return idio_S_unspec;
    } else {
	/*
	 * Test Case: libc-errors/struct-timeval-set-invalid-member.idio
	 *
	 * struct-timeval-set! (libc/gettimeofday) 'not-likely
	 */
        idio_error_param_value_exp ("struct-timeval-set!", "member", member, "C struct timeval member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_timeval_as_string (struct timeval *timevalp)
{
    IDIO_C_ASSERT (timevalp);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    char buf[BUFSIZ];
    char *fmt;

    /*
     * The more common (shell) printing of a timeval is a %ld.%06ld
     * style with the even more correct form of %ld.%.*ld using some
     * precision
     */
    int prec = 6;
    if (idio_S_nil != idio_print_conversion_precision_sym) {
	IDIO ipcp = idio_module_symbol_value (idio_print_conversion_precision_sym,
					      idio_Idio_module,
					      IDIO_LIST1 (idio_S_false));

	if (idio_S_false != ipcp) {
	    if (idio_isa_fixnum (ipcp)) {
		prec = IDIO_FIXNUM_VAL (ipcp);
	    } else {
		/*
		 * Test Case: ??
		 *
		 * If we set idio-print-conversion-precision to
		 * something not a fixnum (nor #f) then it affects
		 * *everything* in the codebase that uses
		 * idio-print-conversion-precision before we get here.
		 */
		idio_error_param_type ("fixnum", ipcp, IDIO_C_FUNC_LOCATION ());

		/* notreached */
		return NULL;
	    }
	}
    }

    fmt = idio_C_type_format_string (IDIO_TYPE_C_libc_time_t);
    idio_snprintf (buf, BUFSIZ, fmt, timevalp->tv_sec);
    idio_display_C (buf, CSI_sh);
    IDIO_GC_FREE (fmt);

    idio_display_C (".", CSI_sh);

    /*
     * suseconds_t **must** be 6 digits -- it is micro-seconds, not
     * nano-seconds or anything else.
     *
     * prec, therefore cannot be greater than 6
     *
     * However, we need to apply the prec to the leading-0-padded
     * string.  That's because 1us -> ".000001" and a prec of 3 =>
     * ".000"
     */
    char us[30];
#if defined (__APPLE__) && defined (__MACH__)
    /* technically it's a __darwin_suseconds_t => __int32_t */
    idio_snprintf (us, 30, "%06d", timevalp->tv_usec);
#else
    idio_snprintf (us, 30, "%06ld", timevalp->tv_usec);
#endif
    char sfmt[30];
    if (prec > 6) {
	prec = 6;
    }
    idio_snprintf (sfmt, 30, "%%.%ds", prec);
    idio_snprintf (buf, BUFSIZ, sfmt, us);
    idio_display_C (buf, CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-timeval-as-string", libc_struct_timeval_as_string, (IDIO timeval), "timeval", "\
:param timeval: C struct timeval	\n\
:type timeval: C/pointer		\n\
:return: string				\n\
:rtype:	string				\n\
")
{
    IDIO_ASSERT (timeval);

    /*
     * Test Case: libc-errors/struct-timeval-as-string-bad-pointer-type.idio
     *
     * struct-timeval-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, timeval);
    if (idio_CSI_libc_struct_timeval != IDIO_C_TYPE_POINTER_PTYPE (timeval)) {
	/*
	 * Test Case: libc-errors/struct-timeval-as-string-invalid-pointer-type.idio
	 *
	 * struct-timeval-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-timeval-as-string", "timeval", timeval, "C struct timeval", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_timeval_as_string (IDIO_C_TYPE_POINTER_P (timeval));
}

/*
	/usr/include/bits/types/struct_rusage.h

	struct rusage
	{
	  struct timeval       ru_utime;
	  struct timeval       ru_stime;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	  union {}             -anon-;
	};
*/

IDIO_C_STRUCT_IDENT_DECL (libc_struct_rusage);
IDIO_SYMBOL_DECL (ru_utime);
IDIO_SYMBOL_DECL (ru_stime);

IDIO_DEFINE_PRIMITIVE2_DS ("struct-rusage-ref", libc_struct_rusage_ref, (IDIO rusage, IDIO member), "rusage member", "\
in C, rusage->member			\n\
					\n\
:param rusage: C struct rusage	\n\
:type rusage: C/pointer		\n\
:param member: C struct member		\n\
:type member: symbol			\n\
:return: rusage->member		\n\
:rtype:	varies on member		\n\
")
{
    IDIO_ASSERT (rusage);
    IDIO_ASSERT (member);

    /*
     * Test Case: libc-errors/struct-rusage-ref-bad-pointer-type.idio
     *
     * struct-rusage-ref #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rusage);
    if (idio_CSI_libc_struct_rusage != IDIO_C_TYPE_POINTER_PTYPE (rusage)) {
	/*
	 * Test Case: libc-errors/struct-rusage-ref-invalid-pointer-type.idio
	 *
	 * struct-rusage-ref libc/NULL #t
	 */
	idio_error_param_value_exp ("struct-rusage-ref", "rusage", rusage, "C struct rusage", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct rusage *rusagep = IDIO_C_TYPE_POINTER_P (rusage);

    /*
     * Test Case: libc-errors/struct-rusage-ref-bad-member-type.idio
     *
     * struct-rusage-ref (libc/getrusage libc/RUSAGE_SELF) #t
     */
    IDIO_USER_TYPE_ASSERT (symbol, member);

    if (idio_S_ru_utime == member) {
        struct timeval *rp = (struct timeval *) idio_alloc (sizeof (struct timeval));
        memcpy ((void *) rp, (void *) &rusagep->ru_utime, sizeof (struct timeval));

        return idio_C_pointer_type (idio_CSI_libc_struct_timeval, rp);

    } else if (idio_S_ru_stime == member) {
        struct timeval *rp = (struct timeval *) idio_alloc (sizeof (struct timeval));
        memcpy ((void *) rp, (void *) &rusagep->ru_stime, sizeof (struct timeval));

        return idio_C_pointer_type (idio_CSI_libc_struct_timeval, rp);

    } else {
	/*
	 * Test Case: libc-errors/struct-rusage-ref-invalid-member.idio
	 *
	 * struct-rusage-ref (libc/getrusage libc/RUSAGE_SELF) 'not-likely
	 */
        idio_error_param_value_exp ("struct-rusage-ref", "member", member, "C struct rusage member", IDIO_C_FUNC_LOCATION());

        return idio_S_notreached;
    }

    return idio_S_notreached;
}

IDIO idio_libc_struct_rusage_as_string (struct rusage *rusagep)
{
    IDIO_C_ASSERT (rusagep);

    IDIO CSI_sh = idio_open_output_string_handle_C ();
    idio_display_C ("#<CSI libc/struct-rusage", CSI_sh);

    idio_display_C (" ru_utime:", CSI_sh);

    idio_display (idio_libc_struct_timeval_as_string (&(rusagep->ru_utime)), CSI_sh);

    idio_display_C (" ru_stime:", CSI_sh);

    idio_display (idio_libc_struct_timeval_as_string (&(rusagep->ru_stime)), CSI_sh);

    idio_display_C (">", CSI_sh);

    return idio_get_output_string (CSI_sh);
}

IDIO_DEFINE_PRIMITIVE1_DS ("struct-rusage-as-string", libc_struct_rusage_as_string, (IDIO rusage), "rusage", "\
:param rusage: C struct rusage	\n\
:type rusage: C/pointer		\n\
:return: string			\n\
:rtype:	string			\n\
")
{
    IDIO_ASSERT (rusage);

    /*
     * Test Case: libc-errors/struct-rusage-as-string-bad-pointer-type.idio
     *
     * struct-rusage-as-string #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rusage);
    if (idio_CSI_libc_struct_rusage != IDIO_C_TYPE_POINTER_PTYPE (rusage)) {
	/*
	 * Test Case: libc-errors/struct-rusage-as-string-invalid-pointer-type.idio
	 *
	 * struct-rusage-as-string libc/NULL
	 */
	idio_error_param_value_exp ("struct-rusage-as-string", "rusage", rusage, "C struct rusage", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_rusage_as_string (IDIO_C_TYPE_POINTER_P (rusage));
}

IDIO_DEFINE_PRIMITIVE2_DS ("write", libc_write, (IDIO fd, IDIO str), "fd str", "\
in C, write (fd, str)						\n\
a wrapper to libc write (2)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:param str: string						\n\
:type str: string						\n\
:return: number of bytes written or raises ^system-error	\n\
:rtype: libc/ssize_t						\n\
")
{
    IDIO_ASSERT (fd);
    IDIO_ASSERT (str);

    /*
     * Test Case: libc-wrap-errors/write-bad-fd-type.idio
     *
     * write #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    /*
     * Test Case: libc-wrap-errors/write-bad-str-type.idio
     *
     * write (C/integer-> 0) #t
     */
    IDIO_USER_TYPE_ASSERT (string, str);

    int C_fd = IDIO_C_TYPE_int (fd);

    size_t blen = 0;
    char *C_str = idio_string_as_C (str, &blen);

    ssize_t write_r = write (C_fd, C_str, blen);

    if (-1 == write_r) {
	/*
	 * Test Case: libc-wrap-errors/write-bad-fd.idio
	 *
	 * write (C/integer-> -1) "hello\n"
	 */
	idio_error_system_errno ("write", IDIO_LIST2 (fd, str), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    IDIO_GC_FREE (C_str);

    return idio_libc_ssize_t (write_r);
}

IDIO_DEFINE_PRIMITIVE1V_DS ("waitpid", libc_waitpid, (IDIO pid, IDIO args), "pid [options]", "\
in C, waitpid (pid, statusp, options)				\n\
a wrapper to libc waitpid(2)					\n\
								\n\
:param pid: process ID						\n\
:type pid: libc/pid_t						\n\
:param options: see below					\n\
:type options: C/int						\n\
:return: list of (pid_t, statusp) or raises ^system-error	\n\
:rtype: list							\n\
								\n\
WAIT_ANY is defined as -1 in place of ``pid``.			\n\
								\n\
The following options are defined:				\n\
WNOHANG								\n\
WUNTRACED							\n\
								\n\
Options will be IORed together					\n\
								\n\
``statusp`` is C/pointer to a C ``int *``.  See ``WIFEXITED``,	\n\
``WEXITSTATUS``, ``WIFSIGNALLED``, ``WTERMSIG``, ``WIFSTOPPED``	\n\
for functions to manipulate ``statusp``.			\n\
")
{
    IDIO_ASSERT (pid);
    IDIO_ASSERT (args);

    /*
     * Test Case: libc-wrap-errors/waitpid-bad-pid-type.idio
     *
     * waitpid #t #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pid);
    pid_t C_pid = IDIO_C_TYPE_libc_pid_t (pid);

    /*
     * Test Case: libc-wrap-errors/waitpid-bad-options-type.idio
     *
     * waitpid (C/integer-> 0 libc/pid_t) #t
     */
    int C_options = 0;
    if (idio_S_nil != args) {
	IDIO option = IDIO_PAIR_H (args);

	IDIO_USER_C_TYPE_ASSERT (int, option);
	C_options |= IDIO_C_TYPE_int (option);
	args = IDIO_PAIR_T (args);
    }

    int *statusp = idio_alloc (sizeof (int));
    IDIO istatus = idio_C_pointer_free_me (statusp);

    while (1) {
	pid_t waitpid_r = waitpid (C_pid, statusp, C_options);

	if (-1 == waitpid_r) {
	    if (ECHILD == errno) {
		/*
		 * Either pid isn't one of ours or we somehow have
		 * SIGCHLD set to SIG_IGN!
		 *
		 * Either way it feels like we're in the wrong, not
		 * erroring.
		 */
		IDIO stray_pids = idio_module_symbol_value (idio_job_control_stray_pids_sym, idio_job_control_module, idio_S_nil);
		IDIO spid = idio_hash_ref (stray_pids, pid);
		if (idio_S_unspec != spid) {
		    fprintf (stderr, "%6d: waitpid: recovered stray pid %d\n", getpid (), C_pid);
		    idio_hash_delete (stray_pids, pid);
		    return IDIO_LIST2 (pid, spid);
		}

		return IDIO_LIST2 (idio_libc_pid_t (0), idio_S_nil);
	    } else if (EINTR != errno) {
		/*
		 * Test Case: libc-wrap-errors/waitpid-bad-options.idio
		 *
		 * waitpid (C/integer-> 0 libc/pid_t) (C/integer-> -1)
		 */
		args = idio_pair (pid, args);
		idio_error_system_errno ("waitpid", args, IDIO_C_FUNC_LOCATION ());

		return idio_S_notreached;
	    }

	    /*
	     * That should leave EINTR for which we go round the loop
	     */
	} else {
	    /*
	     * waitpid_r > 0: there is some status for pid
	     * waitpid_r == 0: no status for pid (caller to handle!)
	     */
	    return IDIO_LIST2 (idio_libc_pid_t (waitpid_r), istatus);
	}
    }
}

IDIO_DEFINE_PRIMITIVE1_DS ("unlink", libc_unlink, (IDIO pathname), "pathname", "\
in C, unlink (pathname)				\n\
a wrapper to libc unlink(2)			\n\
						\n\
:param pathname: filename to unlink		\n\
:type pathname: string				\n\
:return: 0 or raises ^system-error		\n\
:rtype: C/int					\n\
")
{
    IDIO_ASSERT (pathname);

    /*
     * Test Case: libc-wrap-errors/unlink-bad-type.idio
     *
     * unlink #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;
    /*
     * Test Case: libc-wrap-errors/unlink-bad-format.idio
     *
     * unlink (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *pathname_C = idio_libc_string_C (pathname, "unlink", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    int unlink_r = unlink (pathname_C);

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    if (-1 == unlink_r) {
	/*
	 * Test Case: libc-wrap-errors/unlink-non-existent.idio
	 *
	 * fd+name := mkstemp "XXXXXX"
	 * close (ph fd+name)
	 * delete-file (pht fd+name)
	 * unlink (pht fd+name)
	 */
	idio_error_system_errno ("unlink", pathname, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (unlink_r);
}

IDIO_DEFINE_PRIMITIVE0_DS ("uname", libc_uname, (void), "", "\
in C, uname (utsnamep)						\n\
a wrapper to libc uname(3)					\n\
								\n\
:return: struct-utsname or raises ^system-error			\n\
:rtype: C/pointer						\n\
								\n\
Not strictly useful at the moment.  You might want to use	\n\
``libc/idio-uname`` such as:					\n\
								\n\
libc/idio-uname.nodename					\n\
								\n\
instead.							\n\
")
{
    struct utsname *utsnamep = idio_alloc (sizeof (struct utsname));

    if (uname (utsnamep) == -1) {
	/*
	 * Test Case: ??
	 *
	 * EFAULT buf is not valid.
	 */
	idio_error_system_errno ("uname", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_utsname, utsnamep);
}

IDIO_DEFINE_PRIMITIVE0_DS ("times", libc_times, (void), "", "\
in C: times ()							\n\
a wrapper to libc times(3)					\n\
								\n\
:return: (clock_t, struct-tms) or raises ^system-error		\n\
:rtype: list							\n\
								\n\
times(3) is complicated because we need to return the struct tms\n\
that the user would have passed in as a pointer and the clock_t,\n\
elapsed real time, that times(3) returns.			\n\
								\n\
All fields are in clock ticks for which sysconf(_SC_CLK_TCK) is	\n\
available for reference as the exported symbol CLK_TCK.		\n\
")
{
    struct tms* tmsp = idio_alloc (sizeof (struct tms));

    clock_t times_r = times (tmsp);

    if (-1 == times_r) {
	/*
	 * Test Case: ??
	 *
	 * EFAULT tmsp points outside the process's address space.
	 */
        idio_error_system_errno ("times", idio_S_nil, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return IDIO_LIST2 (idio_libc_clock_t (times_r), idio_C_pointer_type (idio_CSI_libc_struct_tms, tmsp));
}

IDIO_DEFINE_PRIMITIVE2_DS ("tcsetpgrp", libc_tcsetpgrp, (IDIO fd, IDIO pgrp), "fd pgrp", "\
in C, tcsetpgrp (fd, pgrp)					\n\
a wrapper to libc tcsetpgrp(3)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:param pgrp: PGID						\n\
:type pgrp: libc/pid_t						\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (fd);
    IDIO_ASSERT (pgrp);

    /*
     * Test Case: libc-wrap-errors/tcsetpgrp-bad-fd-type.idio
     *
     * tcsetpgrp #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    /*
     * Test Case: libc-wrap-errors/tcsetpgrp-bad-pgrp-type.idio
     *
     * tcsetpgrp (C/integer-> 0) #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pgrp);
    pid_t C_pgrp = IDIO_C_TYPE_libc_pid_t (pgrp);

    int tcsetpgrp_r = tcsetpgrp (C_fd, C_pgrp);

    if (-1 == tcsetpgrp_r) {
	/*
	 * Test Case: libc-wrap-errors/tcsetpgrp-bad-fd.idio
	 *
	 * tcsetpgrp (C/integer-> -1) (C/integer-> PID libc/pid_t)
	 */
	idio_error_system_errno ("tcsetpgrp", IDIO_LIST2 (fd, pgrp), IDIO_C_FUNC_LOCATION ());
    }

    return idio_C_int (tcsetpgrp_r);
}

IDIO_DEFINE_PRIMITIVE3_DS ("tcsetattr", libc_tcsetattr, (IDIO fd, IDIO options, IDIO termios), "fd options termios", "\
in C, tcsetattr (fd, options, termios)				\n\
a wrapper to libc tcsetattr(3)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:param options: see below					\n\
:type options: C/int						\n\
:param termios: struct termios					\n\
:type termios: C/pointer					\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
								\n\
The following options are defined:				\n\
TCSADRAIN							\n\
TCSAFLUSH							\n\
								\n\
See ``tcgetattr`` for obtaining a struct termios.		\n\
")
{
    IDIO_ASSERT (fd);
    IDIO_ASSERT (options);
    IDIO_ASSERT (termios);

    /*
     * Test Case: libc-wrap-errors/tcsetattr-bad-fd-type.idio
     *
     * tcsetattr #t #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    /*
     * Test Case: libc-wrap-errors/tcsetattr-bad-options-type.idio
     *
     * tcsetattr (C/integer-> 0) #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, options);
    int C_options = IDIO_C_TYPE_int (options);

    /*
     * Test Case: libc-wrap-errors/tcsetattr-bad-termios-type.idio
     *
     * tcsetattr (C/integer-> 0) (C/integer-> 0) #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, termios);
    struct termios *C_termiosp = IDIO_C_TYPE_POINTER_P (termios);

    int tcsetattr_r = tcsetattr (C_fd, C_options, C_termiosp);

    if (-1 == tcsetattr_r) {
	/*
	 * Test Case: libc-wrap-errors/tcsetattr-bad-fd.idio
	 *
	 * get the attributes of stdin and assign them to fd -1
	 *
	 * tcsetattr (C/integer-> -1) (C/integer-> 0) (tcgetattr (C/integer-> 0))
	 */
	idio_error_system_errno ("tcsetattr", IDIO_LIST3 (fd, options, termios), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (tcsetattr_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("tcgetpgrp", libc_tcgetpgrp, (IDIO fd), "fd", "\
in C, tcgetpgrp (fd)						\n\
a wrapper to libc tcgetpgrp(3)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:return: PID or raises ^system-error				\n\
:rtype: libc/pid_t						\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/tcgetpgrp-bad-type.idio
     *
     * tcgetpgrp #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    pid_t pid = tcgetpgrp (C_fd);

    if (-1 == pid) {
	/*
	 * Test Case: libc-wrap-errors/tcgetpgrp-bad-fd.idio
	 *
	 * tcgetpgrp (C/integer-> -1)
	 */
	idio_error_system_errno ("tcgetpgrp", fd, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_pid_t (pid);
}

IDIO_DEFINE_PRIMITIVE1_DS ("tcgetattr", libc_tcgetattr, (IDIO fd), "fd", "\
in C, tcgetattr (fd, termiosp)					\n\
a wrapper to libc tcgetattr(3)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:return: struct termios or raises ^system-error			\n\
:rtype: C/pointer						\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/tcgetattr-bad-type.idio
     *
     * tcgetattr #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    struct termios *termiosp = idio_alloc (sizeof (struct termios));

    int tcgetattr_r = tcgetattr (C_fd, termiosp);

    if (-1 == tcgetattr_r) {
	/*
	 * Test Case: libc-wrap-errors/tcgetattr-bad-fd.idio
	 *
	 * tcgetattr (C/integer-> -1)
	 */
	idio_error_system_errno ("tcgetattr", fd, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_termios, termiosp);
}

IDIO_DEFINE_PRIMITIVE1_DS ("strsignal", libc_strsignal, (IDIO sig), "sig", "\
in C, strsignal (sig)						\n\
a wrapper to libc strsignal(3)					\n\
								\n\
:param sig: signal number to describe				\n\
:type sig: C/int						\n\
:return: string describing errnum				\n\
:rtype: string							\n\
								\n\
On some systems (Solaris) #n may be returned for an invalid	\n\
signal number.							\n\
")
{
    IDIO_ASSERT (sig);

    /*
     * Test Case: libc-wrap-errors/strsignal-bad-type.idio
     *
     * strsignal #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, sig);
    int C_sig = IDIO_C_TYPE_int (sig);

    char *strsignal_r = strsignal (C_sig);

    if (NULL == strsignal_r) {
	/*
	 * Code coverage: SunOS
	 *
	 * strsignal -1		; #n
	 */
	return idio_S_nil;
    } else {
	return idio_string_C (strsignal_r);
    }
}

IDIO_DEFINE_PRIMITIVE2_DS ("strptime", libc_strptime, (IDIO s, IDIO format), "s format", "\
in C: strptime (s, format)		\n\
a wrapper to libc strptime(3)		\n\
					\n\
:param s: time string			\n\
:type s: string				\n\
:param format: 				\n\
:type format: string			\n\
:return:				\n\
:rtype: C struct tm			\n\
")
{
    IDIO_ASSERT (s);
    IDIO_ASSERT (format);

    /*
     * Test Case: libc-errors/strptime-bad-s-type.idio
     *
     * strptime #t #t
     */
    IDIO_USER_TYPE_ASSERT (string, s);
    
    int free_C_s = 0;
    /*
     * Test Case: libc-wrap-errors/strptime-bad-s-format.idio
     *
     * strptime "hello\x00world" #t
     */
    char *C_s = idio_libc_string_C (s, "strptime", &free_C_s, IDIO_C_FUNC_LOCATION ());

    /*
     * Test Case: libc-errors/strptime-bad-format-type.idio
     *
     * strptime #t #t
     */
    IDIO_USER_TYPE_ASSERT (string, format);

    int free_C_format = 0;
    /*
     * Test Case: libc-wrap-errors/strptime-bad-s-format.idio
     *
     * strptime "hello\x00world" #t
     */
    char *C_format = idio_libc_string_C (format, "strptime", &free_C_format, IDIO_C_FUNC_LOCATION ());

    /*
     * strptime does not initialize {tm}.
     */
    struct tm *tmp = idio_alloc (sizeof (struct tm));;
    memset (tmp, 0, sizeof (struct tm));

    char* strptime_r = strptime (C_s, C_format, tmp);

    if (free_C_s) {
	IDIO_GC_FREE (C_s);
    }

    if (free_C_format) {
	IDIO_GC_FREE (C_format);
    }

    if (NULL == strptime_r) {
	IDIO_GC_FREE (tmp);

        idio_error_C ("strptime", IDIO_LIST2 (s, format), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    /*
     * XXX We don't indicate if strptime consumed the whole of {s}.
     * If we want to do that we'd need to return something like:
     *
     * (list tmp idio_string_C (strptime_r))
     */

    return idio_C_pointer_type (idio_CSI_libc_struct_tm, tmp);
}

IDIO_DEFINE_PRIMITIVE2_DS ("strftime", libc_strftime, (IDIO format, IDIO tm), "format tm", "\
in C: strftime (format, tm)		\n\
a wrapper to libc strftime(3)		\n\
					\n\
:param format: 				\n\
:type format: string			\n\
:param tm: 				\n\
:type tm: C struct tm			\n\
:return:				\n\
:rtype: string				\n\
					\n\
Internally, libc/BUFSIZ is used for the	\n\
maximum string size			\n\
")
{
    IDIO_ASSERT (format);
    IDIO_ASSERT (tm);

    /*
     * Test Case: libc-errors/strftime-bad-format-type.idio
     *
     * strftime #t #t
     */
    IDIO_USER_TYPE_ASSERT (string, format);

    int free_C_format = 0;
    /*
     * Test Case: libc-wrap-errors/strftime-bad-s-format.idio
     *
     * strftime "hello\x00world" #t
     */
    char *C_format = idio_libc_string_C (format, "strftime", &free_C_format, IDIO_C_FUNC_LOCATION ());

    /*
     * Test Case: libc-errors/strftime-bad-tm-type.idio
     *
     * strftime "%c" #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/strftime-tm-invalid-pointer-type.idio
	 *
	 * struct-tm-ref "%c" libc/NULL
	 */
	idio_error_param_value_exp ("strftime", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tm *C_tm = IDIO_C_TYPE_POINTER_P (tm);

    char *s = idio_alloc (BUFSIZ);

    size_t strftime_r = strftime (s, BUFSIZ, C_format, C_tm);

    if (0 == strftime_r) {
	IDIO_GC_FREE (s);

        idio_error_system_errno ("strftime", IDIO_LIST2 (format, tm), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    IDIO r = idio_string_C_len (s, strftime_r);

    IDIO_GC_FREE (s);

    return r;
}

IDIO_DEFINE_PRIMITIVE1_DS ("strerror", libc_strerror, (IDIO errnum), "errnum", "\
in C, strerror (errnum)						\n\
a wrapper to libc strerror(3)					\n\
								\n\
:param errnum: error code to describe				\n\
:type errnum: C/int						\n\
:return: string describing errnum				\n\
:rtype: string							\n\
")
{
    IDIO_ASSERT (errnum);

    /*
     * Test Case: libc-wrap-errors/strerror-bad-type.idio
     *
     * strerror #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, errnum);
    int C_errnum = IDIO_C_TYPE_int (errnum);

    /*
     * Arguably we could make a 0 < errnum < IDIO_LIBC_NERRNO check
     * ourselves, here.
     */

    errno = 0;
    char *strerror_r = strerror (C_errnum);

    if (0 != errno) {
	/*
	 * Test Case: ?? libc-wrap-errors/strerror-bad-errnum.idio
	 *
	 * strerror -1
	 *
	 * XXX this generates "Unknown error -1" which means, I guess, all ints are covered.
	 */
	idio_error_system_errno ("strerror", errnum, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_string_C (strerror_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("stat", libc_stat, (IDIO pathname), "pathname", "\
in C: stat (pathname)				\n\
a wrapper to libc stat(2)			\n\
						\n\
:param pathname:				\n\
:type pathname: C/pointer			\n\
:return: struct-stat or raises ^system-error	\n\
:rtype: struct instance				\n\
")
{
    IDIO_ASSERT (pathname);

    /*
     * Test Case: libc-wrap-errors/stat-bad-type.idio
     *
     * stat #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;
    /*
     * Test Case: libc-wrap-errors/stat-bad-format.idio
     *
     * stat (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *pathname_C = idio_libc_string_C (pathname, "stat", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    struct stat* statp = idio_alloc (sizeof (struct stat));

    int stat_r = stat (pathname_C, statp);

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    if (-1 == stat_r) {
	/*
	 * Test Case: libc-wrap-errors/stat-empty-pathname.idio
	 *
	 * stat ""
	 */
        idio_error_system_errno ("stat", pathname, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_stat, statp);
}

IDIO_DEFINE_PRIMITIVE1_DS ("sleep", libc_sleep, (IDIO seconds), "seconds", "\
in C, sleep (seconds)						\n\
a wrapper to libc sleep(3)					\n\
								\n\
:param seconds: seconds to sleep				\n\
:type seconds: unsigned fixnum or C/uint			\n\
:return: 0 or the number of seconds left if interrupted		\n\
:rtype: C/uint							\n\
")
{
    IDIO_ASSERT (seconds);

    unsigned int C_seconds = 0;
    if (idio_isa_fixnum (seconds) &&
	IDIO_FIXNUM_VAL (seconds) >= 0) {
	C_seconds = IDIO_FIXNUM_VAL (seconds);
    } else if (idio_isa_C_uint (seconds)) {
	C_seconds = IDIO_C_TYPE_uint (seconds);
    } else {
	/*
	 * Test Case: libc-wrap-errors/sleep-bad-type.idio
	 *
	 * sleep #t
	 */
	idio_error_param_type ("unsigned fixnum|C_uint", seconds, IDIO_C_FUNC_LOCATION ());
    }

    unsigned int sleep_r = sleep (C_seconds);

    return idio_C_uint (sleep_r);
}

IDIO_DEFINE_PRIMITIVE2_DS ("signal", libc_signal, (IDIO sig, IDIO handler), "sig handler", "\
in C, signal (sig, handler)					\n\
a wrapper to libc signal(2)					\n\
								\n\
:param sig: signal						\n\
:type sig: C/int						\n\
:param handler: signal disposition					\n\
:type handler: C/pointer						\n\
:return: previous disposition or raises ^system-error		\n\
:rtype: C/pointer						\n\
								\n\
The following dispositions are defined:				\n\
SIG_IGN								\n\
SIG_DFL								\n\
")
{
    IDIO_ASSERT (sig);
    IDIO_ASSERT (handler);

    /*
     * Test Case: libc-wrap-errors/signal-bad-sig-type.idio
     *
     * signal #t #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, sig);
    /*
     * Test Case: libc-wrap-errors/signal-bad-handler-type.idio
     *
     * signal (C/integer-> 0) #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, handler);

    int C_sig = IDIO_C_TYPE_int (sig);
    void (*C_handler) (int) = IDIO_C_TYPE_POINTER_P (handler);

    void (*signal_r) (int) = signal (C_sig, C_handler);

    if (SIG_ERR == signal_r) {
	/*
	 * Test Case: libc-wrap-errors/signal-bad-signal.idio
	 *
	 * signal (C/integer-> -1) SIG_DFL
	 */
	idio_error_system_errno ("signal", IDIO_LIST2 (sig, handler), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer (signal_r);
}

IDIO_DEFINE_PRIMITIVE2_DS ("setrlimit", libc_setrlimit, (IDIO resource, IDIO rlim), "resource rlim", "\
in C, setrlimit (resource, rlim)				\n\
a wrapper to libc setrlimit (2)					\n\
								\n\
:param resource: resource, see below				\n\
:type resource: C/int						\n\
:param rlim: struct-rlimit					\n\
:type rlim: struct instance					\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
								\n\
The resource names follow C conventions such as ``RLIMIT_AS``	\n\
and ``RLIMIT_NOFILE``.						\n\
								\n\
See ``getrlimit`` to obtain a struct-rlimit.			\n\
")
{
    IDIO_ASSERT (resource);
    IDIO_ASSERT (rlim);

    /*
     * Test Case: setrlimit-bad-resource-type.idio
     *
     * setrlimit #t #t
     *
     * NB Fedora uses an unsigned int enum whereas the
     * IDIO_LIBC_RLIMIT(n) macro defines the names as idio_C_int.
     */
    IDIO_USER_C_TYPE_ASSERT (int, resource);
    int C_resource = IDIO_C_TYPE_int (resource);

    /*
     * Test Case: libc-wrap-errors/setrlimit-bad-rlim-type.idio
     *
     * setrlimit (C/integer-> 0) #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, rlim);
    if (idio_CSI_libc_struct_rlimit != IDIO_C_TYPE_POINTER_PTYPE (rlim)) {
	/*
	 * Test Case: libc-errors/setrlimit-invalid-pointer-type.idio
	 *
	 * setrlimit-ref (C/integer-> 0) libc/NULL
	 */
	idio_error_param_value_exp ("setrlimit", "rlim", rlim, "C struct rlimit", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct rlimit *C_rlim = IDIO_C_TYPE_POINTER_P (rlim);

    if (setrlimit (C_resource, C_rlim) == -1) {
	/*
	 * Test Case:  libc-wrap-errors/setrlimit-bad-rlim.idio
	 *
	 * setrlimit (C/integer-> -1) (getrlimit RLIMIT_CPU)
	 */
	idio_error_system_errno ("setrlimit", IDIO_LIST2 (resource, rlim), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_S_unspec;
}

IDIO_DEFINE_PRIMITIVE2_DS ("setpgid", libc_setpgid, (IDIO pid, IDIO pgid), "pid pgid", "\
in C, setpgid (pid, pgid)					\n\
a wrapper to libc setpgid(2)					\n\
								\n\
:param pid: process ID						\n\
:type pid: libC/pid_t						\n\
:param pgid: PGID						\n\
:type pgid: libc/pid_t						\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (pid);
    IDIO_ASSERT (pgid);

    /*
     * Test Case: libc-wrap-errors/setpgid-bad-pid-type.idio
     *
     * setpgid #t #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pid);
    pid_t C_pid = IDIO_C_TYPE_libc_pid_t (pid);

    /*
     * Test Case: libc-wrap-errors/setpgid-bad-pgid-type.idio
     *
     * setpgid (C/integer-> PID libc/pid_t) #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pgid);
    pid_t C_pgid = IDIO_C_TYPE_libc_pid_t (pgid);

    int setpgid_r = setpgid (C_pid, C_pgid);

    if (-1 == setpgid_r) {
	if (EACCES == errno) {
	    /*
	     * The child has already successfully executed exec() =>
	     * EACCES for us.
	     *
	     * Since the child also ran setpgid() on itself before
	     * calling exec() we should be good.
	     */
	    setpgid_r = 0;
	} else {
	    /*
	     * Test Case: libc-wrap-errors/setpgid-negative-pgid.idio
	     *
	     * setpgid (C/integer-> PID libc/pid_t) (C/integer-> -1 libc/pid_t)
	     */
	    idio_error_system_errno ("setpgid", IDIO_LIST2 (pid, pgid), IDIO_C_FUNC_LOCATION ());
	}
    }

    return idio_C_int (setpgid_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("getpgid", libc_getpgid, (IDIO pid), "pid", "\
in C: getpgid (pid)		\n\
a wrapper to libc getpgid(2)		\n\
					\n\
:param pid: 				\n\
:type pid: libc/pid_t			\n\
")
{
    IDIO_ASSERT (pid);

   /*
    * Test Case: libc-errors/getpgid-bad-pid-type.idio
    *
    * getpgid #t
    */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pid);
    pid_t C_pid = IDIO_C_TYPE_libc_pid_t (pid);

    pid_t getpgid_r = getpgid (C_pid);

    if (-1 == getpgid_r) {
	/*
	 * Test Case: libc-errors/getpgid-bad-pid.idio
	 *
	 * getpgid (C/integer-> -1)
	 */
        idio_error_system_errno ("getpgid", pid, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_libc_pid_t (getpgid_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("rmdir", libc_rmdir, (IDIO pathname), "pathname", "\
in C, rmdir (pathname)						\n\
a wrapper to libc rmdir(2)					\n\
								\n\
:param pathname: directory to rmdir				\n\
:type pathname: string						\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (pathname);

    /*
     * Test Case: libc-wrap-errors/rmdir-bad-type.idio
     *
     * rmdir #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;
    /*
     * Test Case: libc-wrap-errors/rmdir-bad-format.idio
     *
     * rmdir (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *pathname_C = idio_libc_string_C (pathname, "rmdir", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    int rmdir_r = rmdir (pathname_C);

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    if (-1 == rmdir_r) {
	/*
	 * Test Case: libc-wrap-errors/rmdir-non-existent.idio
	 *
	 * tmpdir := (make-tmp-dir)
	 * rmdir tmpdir
	 * rmdir tmpdir
	 */
	idio_error_system_errno ("rmdir", pathname, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (rmdir_r);
}

/*
 * XXX
 *
 * ssize_t read(int fd, void *buf, size_t count);
 *
 * The nominal limit for count is ssize_t in POSIX (noting that count
 * itself is size_t).
 *
 * Linux suggests it will limit read(2) to 0x7ffff000 (2,147,479,552)
 * bytes on both 32-bit and 64-bit systems.
 *
 * We allow a fixnum (2 bits short of an intptr_t) or a libc/size_t.
 */
IDIO_DEFINE_PRIMITIVE1V_DS ("read", libc_read, (IDIO fd, IDIO args), "fd [count]", "\
in C, read (fd[, count])					\n\
a wrapper to libc read(2)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:param count: number of bytes to read				\n\
:type count: fixnum or libC/size_t				\n\
:return: string of bytes read or see below			\n\
:rtype: string or see below					\n\
								\n\
count defaults to BUFSIZ					\n\
								\n\
If read(2) returned 0 then this code returns #<eof>.		\n\
								\n\
If read(2) indicated EAGAIN then this code returns #f.		\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/read-bad-type.idio
     *
     * read #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    size_t C_count = BUFSIZ;

    if (idio_S_nil != args) {
	IDIO count = IDIO_PAIR_H (args);

	if (idio_isa_fixnum (count)) {
	    C_count = IDIO_FIXNUM_VAL (count);
	} else if (idio_isa_libc_size_t (count)) {
	    C_count = IDIO_C_TYPE_libc_size_t (count);
	} else {
	    /*
	     * Test Case: libc-wrap-errors/read-bad-count-type.idio
	     *
	     * read (C/integer-> 0) #t
	     */
	    idio_error_param_type ("fixnum|libc/size_t", count, IDIO_C_FUNC_LOCATION ());

	    return idio_S_notreached;
	}
    }

    char *buf = idio_alloc (C_count);

    ssize_t n = read (C_fd, buf, C_count);

    IDIO r;

    if (-1 == n) {
	/*
	 * Test Case: ??
	 */
	if (EAGAIN == errno) {
	    /*
	     * Test Case: ??
	     *
	     * The Open Group:
	     *
	     *   If some process has the pipe open for writing and
	     *   O_NONBLOCK is set, read() will return -1 and set
	     *   errno to [EAGAIN].
	     */
	    return idio_S_false;
	}
	args = idio_pair (fd, args);
	idio_error_system_errno ("read", args, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    } else if (n) {
	r = idio_string_C_len (buf, n);
    } else {
	r = idio_S_eof;
    }

    IDIO_GC_FREE (buf);

    return r;
}

IDIO_DEFINE_PRIMITIVE0_DS ("pipe", libc_pipe, (void), "", "\
in C, pipe (pipefd)						\n\
a wrapper to libc pipe(2)					\n\
								\n\
:return: pointer to pipe array or raises ^system-error		\n\
:rtype: C/pointer						\n\
								\n\
See ``pipe-reader`` and ``pipe-writer`` for accessors to	\n\
the pipe array.							\n\
")
{
    int *pipefd = idio_alloc (2 * sizeof (int));

    int pipe_r = pipe (pipefd);

    if (-1 == pipe_r) {
	/*
	 * Test Case: ??
	 *
	 * Short of reaching EMFILE/ENFILE there's not much we can do.
	 */
	idio_error_system_errno ("pipe", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer_free_me (pipefd);
}

/*
 * XXX nanosleep requires bignums because 32-bit fixnums only get
 * halfway...
 */
IDIO_DEFINE_PRIMITIVE1_DS ("nanosleep", libc_nanosleep, (IDIO req), "req", "\
in C: nanosleep (req, rem)		\n\
a wrapper to libc nanosleep(2)		\n\
					\n\
:param req: 				\n\
:type req: C struct timespec or a list	\n\
:return:				\n\
:rtype: list (completed? rem)		\n\
					\n\
``EINTR`` will return (#f rem)		\n\
otherwise return (#t rem)		\n\
					\n\
``req`` can be a list of (sec [nsec])	\n\
where ``sec`` can be a libc/time_t|fixnum|bignum	\n\
and ``nsec`` can be a C/long|fixnum|bignum	\n\
")
{
    IDIO_ASSERT (req);

    /*
     * {ts} is a handly automatic variable we can use if we're not
     * passed a struct timespec and which we only need up to the
     * system call.  ie. it is not returned to the user.
     */
    struct timespec ts;
    struct timespec* C_req = NULL;
    if (idio_isa_pair (req)) {
	ts.tv_sec = 0;
	ts.tv_nsec = 0;
	C_req = &ts;

	IDIO sec = IDIO_PAIR_H (req);
	if (idio_isa_libc_time_t (sec)) {
	    ts.tv_sec = IDIO_C_TYPE_libc_time_t (sec);
	} else if (idio_isa_fixnum (sec)) {
	    ts.tv_sec = IDIO_FIXNUM_VAL (sec);
	} else if (idio_isa_bignum (sec)) {
	    if (IDIO_BIGNUM_INTEGER_P (sec)) {
		/*
		 * Code coverage: I'm not waiting for the test case to
		 * finish...
		 */
		ts.tv_sec = idio_bignum_ptrdiff_t_value (sec);
	    } else {
		IDIO sec_i = idio_bignum_real_to_integer (sec);
		if (idio_S_nil == sec_i) {
		    /*
		     * Test Case: libc-errors/nanosleep-sec-float.idio
		     *
		     * nanosleep (1.1)
		     */
		    idio_error_param_value_exp ("nanosleep", "sec", sec, "an integer bignum", IDIO_C_FUNC_LOCATION ());

		    return idio_S_notreached;
		} else {
		    ts.tv_sec = idio_bignum_ptrdiff_t_value (sec_i);
		}
	    }
	} else {
	    /*
	     * Test Case: libc-errors/nanosleep-req-sec-bad-type.idio
	     *
	     * nanosleep '(#t)
	     */
	    idio_error_param_type ("libc/time_t|fixnum|bignum", sec, IDIO_C_FUNC_LOCATION ());

	    return idio_S_notreached;
	}

	if (idio_isa_pair (IDIO_PAIR_T (req))) {

	    IDIO nsec = IDIO_PAIR_HT (req);
	    if (idio_isa_C_long (nsec)) {
		ts.tv_nsec = IDIO_C_TYPE_long (nsec);
	    } else if (idio_isa_fixnum (nsec)) {
		ts.tv_nsec = IDIO_FIXNUM_VAL (nsec);
	    } else if (idio_isa_bignum (nsec)) {
		if (IDIO_BIGNUM_INTEGER_P (nsec)) {
		    /*
		     * Code coverage: Hmm, maybe on a 32-bit system
		     * with a value greater than FIXNUM-MAX but below
		     * 1e9, so 6e8, say?
		     */
		    ts.tv_nsec = idio_bignum_ptrdiff_t_value (nsec);
		} else {
		    IDIO nsec_i = idio_bignum_real_to_integer (nsec);
		    if (idio_S_nil == nsec_i) {
			/*
			 * Test Case: libc-errors/nanosleep-nsec-float.idio
			 *
			 * nanosleep (0 1.1)
			 */
			idio_error_param_value_exp ("nanosleep", "nsec", nsec, "an integer bignum", IDIO_C_FUNC_LOCATION ());

			return idio_S_notreached;
		    } else {
			ts.tv_nsec = idio_bignum_ptrdiff_t_value (nsec_i);
		    }
		}
	    } else {
		/*
		 * Test Case: libc-errors/nanosleep-req-nsec-bad-type.idio
		 *
		 * nanosleep '(0 #t)
		 */
		idio_error_param_type ("C/long|fixnum|bignum", nsec, IDIO_C_FUNC_LOCATION ());

		return idio_S_notreached;
	    }
	}
    } else if (idio_isa_C_pointer (req)) {
	IDIO_USER_C_TYPE_ASSERT (pointer, req);
	if (idio_CSI_libc_struct_timespec != IDIO_C_TYPE_POINTER_PTYPE (req)) {
	    /*
	     * Test Case: libc-errors/nanosleep-req-invalid-pointer-type.idio
	     *
	     * nanosleep libc/NULL
	     */
	    idio_error_param_value_exp ("nanosleep", "req", req, "C struct timespec", IDIO_C_FUNC_LOCATION ());

	    return idio_S_notreached;
	}
	C_req = IDIO_C_TYPE_POINTER_P (req);
    } else {
	idio_error_param_type ("struct timespec|list", req, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    struct timespec* C_rem = idio_alloc (sizeof (struct timespec));
    /* nanosleep does not initialise rem */
    C_rem->tv_sec = 0;
    C_rem->tv_nsec = 0;

    int nanosleep_r = nanosleep (C_req, C_rem);

    IDIO completed = idio_S_true;

    if (-1 == nanosleep_r) {
	if (EINTR == errno) {
	    /*
	     * Code coverage: timing.  The secret of all great code coverage is
	     */
	    completed = idio_S_false;
	} else {
	    idio_error_system_errno ("nanosleep", req, IDIO_C_FUNC_LOCATION ());

	    return idio_S_notreached;
	}
    }

    IDIO rem = idio_C_pointer_type (idio_CSI_libc_struct_timespec, C_rem);

    return IDIO_LIST2 (completed, rem);
}

IDIO_DEFINE_PRIMITIVE1_DS ("mktime", libc_mktime, (IDIO tm), "tm", "\
in C: mktime (tm)		\n\
a wrapper to libc mktime(3)		\n\
					\n\
:param tm: 				\n\
:type tm: C struct tm			\n\
:return:				\n\
:rtype: libc/time_t			\n\
")
{
    IDIO_ASSERT (tm);

    /*
     * Test Case: libc-errors/mktime-bad-tm-type.idio
     *
     * mktime #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/mktime-tm-invalid-pointer-type.idio
	 *
	 * mktime libc/NULL
	 */
	idio_error_param_value_exp ("mktime", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tm *C_tm = IDIO_C_TYPE_POINTER_P (tm);

    time_t mktime_r = mktime (C_tm);

    if (-1 == mktime_r) {
        idio_error_system_errno ("mktime", tm, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_libc_time_t (mktime_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("mkstemp", libc_mkstemp, (IDIO template), "template", "\
in C, mkstemp (template)						\n\
a wrapper to libc mkstemp(3)					\n\
								\n\
:param template: template template				\n\
:type template: string						\n\
:return: a list of (file descriptor and new filename) or raises ^system-error\n\
:rtype: list (C/int, string)					\n\
")
{
    IDIO_ASSERT (template);

    /*
     * Test Case: libc-wrap-errors/mkstemp-bad-type.idio
     *
     * mkstemp #t
     */
    IDIO_USER_TYPE_ASSERT (string, template);

    /*
     * XXX mkstemp() requires a NUL-terminated C string and it will
     * modify the template part.
     */

    int free_template_C = 0;
    /*
     * Test Case: libc-wrap-errors/mkstemp-bad-format.idio
     *
     * mkstemp (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *template_C = idio_libc_string_C (template, "mkstemp", &free_template_C, IDIO_C_FUNC_LOCATION ());

    int mkstemp_r = mkstemp (template_C);

    if (-1 == mkstemp_r) {
	/*
	 * Test Case: libc-wrap-errors/mkstemp-bad-template.idio
	 *
	 * mkstemp "XXX"
	 */
	if (free_template_C) {
	    IDIO_GC_FREE (template_C);
	}

	idio_error_system_errno ("mkstemp", template, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    /*
     * Yuk!  The semantics of mkstemp are slightly different to
     * mkdtemp, above.  mkdtemp "returns a pointer to the modified
     * template string on success" so we can return a new Idio string.
     *
     * mkstemp, however, "return the file descriptor of the temporary
     * file" with the tacit assumption that the caller can use the
     * modified template to unlink the file.
     *
     * Therefore, we need to return a tuple of the file descriptor and
     * a string of the created file name.
     */
    IDIO filename = idio_pathname_C (template_C);

    if (free_template_C) {
	IDIO_GC_FREE (template_C);
    }

    return IDIO_LIST2 (idio_C_int (mkstemp_r), filename);
}

IDIO_DEFINE_PRIMITIVE2_DS ("mkfifo", libc_mkfifo, (IDIO path, IDIO mode), "path mode", "\
in C: mkfifo (path, mode)		\n\
a wrapper to libc mkfifo()		\n\
					\n\
:param path: 				\n\
:type path: string			\n\
:param mode: 				\n\
:type mode: libc/mode_t			\n\
:return:				\n\
:rtype: C/int				\n\
")
{
    IDIO_ASSERT (path);
    IDIO_ASSERT (mode);

   /*
    * Test Case: libc-errors/mkfifo-bad-path-type.idio
    *
    * mkfifo #t #t
    */
    IDIO_USER_TYPE_ASSERT (string, path);

    int free_path_C = 0;

    /*
     * Test Case: libc-wrap-errors/mkfifo-bad-path-format.idio
     *
     * mkfifo (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *path_C = idio_libc_string_C (path, "mkfifo", &free_path_C, IDIO_C_FUNC_LOCATION ());

   /*
    * Test Case: libc-errors/mkfifo-bad-mode-type.idio
    *
    * mkfifo "." #t
    */
    IDIO_USER_libc_TYPE_ASSERT (mode_t, mode);
    mode_t C_mode = IDIO_C_TYPE_libc_mode_t (mode);

    int mkfifo_r = mkfifo (path_C, C_mode);

    if (free_path_C) {
	IDIO_GC_FREE (path_C);
    }

    if (-1 == mkfifo_r) {
        idio_error_system_errno ("mkfifo", IDIO_LIST2 (path, mode), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_int (mkfifo_r);

}

IDIO_DEFINE_PRIMITIVE1_DS ("mkdtemp", libc_mkdtemp, (IDIO template), "template", "\
in C, mkdtemp (template)						\n\
a wrapper to libc mkdtemp(3)					\n\
								\n\
:param template: directory template				\n\
:type template: string						\n\
:return: modified template or raises ^system-error		\n\
:rtype: string							\n\
")
{
    IDIO_ASSERT (template);

    /*
     * Test Case: libc-wrap-errors/mkdtemp-bad-type.idio
     *
     * mkdtemp #t
     */
    IDIO_USER_TYPE_ASSERT (string, template);

    /*
     * XXX mkdtemp() requires a NUL-terminated C string and it will
     * modify the template part.
     */

    int free_template_C = 0;

    /*
     * Test Case: libc-wrap-errors/mkdtemp-bad-format.idio
     *
     * mkdtemp (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *template_C = idio_libc_string_C (template, "mkdtemp", &free_template_C, IDIO_C_FUNC_LOCATION ());

    char *mkdtemp_r = mkdtemp (template_C);

    if (NULL == mkdtemp_r) {
	/*
	 * Test Case: libc-wrap-errors/mkdtemp-bad-template.idio
	 *
	 * mkdtemp "XXX"
	 */
	if (free_template_C) {
	    IDIO_GC_FREE (template_C);
	}

	idio_error_system_errno ("mkdtemp", template, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    IDIO r = idio_pathname_C (mkdtemp_r);

    /*
     * XXX free this after using mkdtemp_r
     */
    if (free_template_C) {
	IDIO_GC_FREE (template_C);
    }

    return r;
}

IDIO_DEFINE_PRIMITIVE2_DS ("mkdir", libc_mkdir, (IDIO pathname, IDIO mode), "pathname mode", "\
in C, mkdir (pathname, mode)					\n\
a wrapper to libc mkdir(2)					\n\
								\n\
:param pathname: file name					\n\
:type pathname: string						\n\
:param mode: directory mode					\n\
:type mode: libc/mode_t						\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (pathname);
    IDIO_ASSERT (mode);

    /*
     * Test Case: libc-wrap-errors/mkdir-bad-pathname-type.idio
     *
     * mkdir #t #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;
    /*
     * Test Case: libc-wrap-errors/mkdir-bad-format.idio
     *
     * mkdir (join-string (make-string 1 #U+0) '("hello" "world")) (C/integer-> #o555)
     */
    char *pathname_C = idio_libc_string_C (pathname, "mkdir", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    /*
     * Test Case: libc-wrap-errors/mkdir-bad-mode-type.idio
     *
     * mkdir "." #t
     */
    IDIO_USER_libc_TYPE_ASSERT (mode_t, mode);
    int C_mode = IDIO_C_TYPE_libc_mode_t (mode);

    int mkdir_r = mkdir (pathname_C, C_mode);

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    if (-1 == mkdir_r) {
	/*
	 * Test Case: libc-wrap-errors/mkdir-pathname-exists.idio
	 *
	 * fd+name := mkstemp "XXXXXX"
	 * close (ph fd+name)
	 * mkdir (pht fd+name) (C/integer-> #o555 libc/mode_t)
	 *
	 * XXX You'll want an unwind-protect to actually delete the
	 * file!
	 */
	idio_error_system_errno ("mkdir", IDIO_LIST2 (pathname, mode), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (mkdir_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("lstat", libc_lstat, (IDIO pathname), "pathname", "\
in C: lstat (pathname)				\n\
a wrapper to libc lstat(2)			\n\
						\n\
:param pathname:				\n\
:type pathname: C/pointer			\n\
:return: struct-stat or raises ^system-error	\n\
:rtype: struct instance				\n\
")
{
    IDIO_ASSERT (pathname);

    /*
     * Test Case: libc-wrap-errors/lstat-bad-type.idio
     *
     * lstat #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;

    /*
     * Test Case: libc-wrap-errors/lstat-bad-format.idio
     *
     * lstat (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *pathname_C = idio_libc_string_C (pathname, "lstat", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    struct stat* statp = idio_alloc (sizeof (struct stat));

    int lstat_r = lstat (pathname_C, statp);

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    if (-1 == lstat_r) {
	/*
	 * Test Case: libc-wrap-errors/lstat-empty-pathname.idio
	 *
	 * lstat ""
	 */
        idio_error_system_errno ("lstat", pathname, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_stat, statp);
}

/*
 * Code coverage: must think of something!
 */
IDIO_DEFINE_PRIMITIVE2_DS ("killpg", libc_killpg, (IDIO pgrp, IDIO sig), "pgrp sig", "\
in C: killpg (pgrp, sig)		\n\
a wrapper to libc killpg()		\n\
					\n\
:param pgrp: 				\n\
:type pgrp: libc/pid_t			\n\
:param sig: 				\n\
:type sig: C/int			\n\
:return:				\n\
:rtype: C/int				\n\
")
{
    IDIO_ASSERT (pgrp);
    IDIO_ASSERT (sig);

   /*
    * Test Case: libc-errors/killpg-bad-pgrp-type.idio
    *
    * killpg #t #t
    */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pgrp);
    pid_t C_pgrp = IDIO_C_TYPE_libc_pid_t (pgrp);

   /*
    * Test Case: libc-errors/killpg-bad-sig-type.idio
    *
    * killpg libc/0pid_t #t
    */
    IDIO_USER_C_TYPE_ASSERT (int, sig);
    int C_sig = IDIO_C_TYPE_int (sig);

    int killpg_r = killpg (C_pgrp, C_sig);

    if (-1 == killpg_r) {
        idio_error_system_errno ("killpg", IDIO_LIST2 (pgrp, sig), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_int (killpg_r);
}

IDIO_DEFINE_PRIMITIVE2_DS ("kill", libc_kill, (IDIO pid, IDIO sig), "pid sig", "\
in C, kill (pid, sig)						\n\
a wrapper to libc kill(2)					\n\
								\n\
:param pid: process ID						\n\
:type pid: libc/pid_t						\n\
:param fd: signal						\n\
:type fd: C/int							\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (pid);
    IDIO_ASSERT (sig);

    /*
     * Test Case: libc-wrap-errors/kill-bad-pid-type.idio
     *
     * kill #t #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pid);
    pid_t C_pid = IDIO_C_TYPE_libc_pid_t (pid);

    /*
     * Test Case: libc-wrap-errors/kill-bad-sig-type.idio
     *
     * kill (C/integer-> PID libc/pid_t) #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, sig);
    int C_sig = IDIO_C_TYPE_int (sig);

    int kill_r = kill (C_pid, C_sig);

    if (-1 == kill_r) {
	/*
	 * Test Case: libc-wrap-errors/kill-invalid-signal.idio
	 *
	 * ;; technically risky as 98765 could be a valid signal...
	 * kill (C/integer-> PID libc/pid_T) (C/integer-> 98765)
	 */
	idio_error_system_errno ("kill", IDIO_LIST2 (pid, sig), IDIO_C_FUNC_LOCATION ());
    }

    return idio_C_int (kill_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("isatty", libc_isatty, (IDIO fd), "fd", "\
in C, isatty (fd)						\n\
a wrapper to libc isatty(3)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:return: 1 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/isatty-bad-type.idio
     *
     * isatty #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);

    int C_fd = IDIO_C_TYPE_int (fd);

    int isatty_r = isatty (C_fd);

    if (0 == isatty_r) {
	/*
	 * Test Case: libc-wrap-errors/isatty-not-tty.idio
	 *
	 * fd+name := mkstemp "XXXXXX"
	 * delete-file (pht fd+name)
	 * isatty (ph fd+name)
	 */
	idio_error_system_errno ("isatty", fd, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (isatty_r);
}

IDIO_DEFINE_PRIMITIVE0V_DS ("gmtime", libc_gmtime, (IDIO args), "[t]", "\
in C: gmtime (t)			\n\
a wrapper to libc gmtime(3)		\n\
					\n\
:param t: time in seconds since epoch	\n\
:type t: libc/time_t			\n\
:return:				\n\
:rtype: C struct tm			\n\
					\n\
``t`` defaults to the result of time(2)	\n\
")
{
    IDIO_ASSERT (args);

    time_t C_t = 0;

    if (idio_isa_pair (args)) {
	IDIO t = IDIO_PAIR_H (args);

	/*
	 * Test Case: libc-errors/gmtime-bad-t-type.idio
	 *
	 * gmtime #t
	 */
	IDIO_USER_libc_TYPE_ASSERT (time_t, t);
	C_t = IDIO_C_TYPE_libc_time_t (t);
    } else {
	C_t = time (NULL);
    }

    /*
     * gmtime() uses static buffers *and* we need to allocate the
     * result anyway so we'll use gmtime_r().
     *
     * In the NOTES on Linux: "For portable code, tzset(3) should be
     * called before gmtime_r()."
     */
    tzset ();
    struct tm *result = idio_alloc (sizeof (struct tm));

    struct tm* gmtime_r_r = gmtime_r (&C_t, result);

    if (NULL == gmtime_r_r) {
	IDIO_GC_FREE (result);

        idio_error_system_errno ("gmtime_r", idio_libc_time_t (C_t), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_tm, result);
}

IDIO_DEFINE_PRIMITIVE0_DS ("gettimeofday", libc_gettimeofday, (void), "", "\
in C, gettimeofday ()						\n\
a wrapper to libc gettimeofday (2)				\n\
								\n\
:return: struct-timeval or raises ^system-error			\n\
:rtype: struct-timeval						\n\
								\n\
The struct timezone parameter is not used.			\n\
")
{
    struct timeval *tvp = (struct timeval *) idio_alloc (sizeof (struct timeval));

    if (-1 == gettimeofday (tvp, NULL)) {
	/*
	 * Test Case: ??
	 *
	 * EFAULT One of tv or tz pointed outside the accessible
	 * address space.
	 */
	idio_error_system_errno ("gettimeofday", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_struct_timeval_pointer (tvp);
}

/*
 * Code coverage:
 *
 * This is primarily for catching when someone else has made us a
 * session leader (hint: rlwrap).
 */
IDIO_DEFINE_PRIMITIVE1_DS ("getsid", libc_getsid, (IDIO pid), "pid", "\
in C, getsid (pid)						\n\
a wrapper to libc getsid(2)					\n\
								\n\
:param pid: getsid pid						\n\
:type pid: libc/pid_t						\n\
:return:							\n\
:rtype: libc/pid_t						\n\
")
{
    IDIO_ASSERT (pid);

    /*
     * Test Case: libc-wrap-errors/getsid-bad-type.idio
     *
     * libc/getsid #t
     */
    IDIO_USER_libc_TYPE_ASSERT (pid_t, pid);
    pid_t C_pid = IDIO_C_TYPE_libc_pid_t (pid);

    pid_t getsid_r = getsid (C_pid);

    if (-1 == getsid_r) {
	/*
	 * Test Case: libc-wrap-errors/getsid-invalid-pid.idio
	 *
	 * int-max := C/->number INT_MAX
	 * getsid (C/integer-> int-max libc/pid_t)
	 *
	 * XXX Probably!
	 *
	 * We're assuming that 1) INT_MAX isn't a valid pid (to
	 * generate the error) and 2) that INT_MAX (a C/int) is less
	 * than or equal to the maximum value in the range of a
	 * libc/pid_t (which is probably a C/int or a C/long but you
	 * never know)
	 */
	idio_error_system_errno ("getsid", pid, IDIO_C_FUNC_LOCATION ());
    }

    return idio_libc_pid_t (getsid_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("getrusage", libc_getrusage, (IDIO who), "who", "\
in C, getrusage (who, rusagep)					\n\
a wrapper to libc getrusage(2)					\n\
								\n\
:param who: who, see below					\n\
:type who: C/int						\n\
:return: struct-rusage or raises ^system-error			\n\
:rtype: struct-rusage						\n\
								\n\
The parameter `who` refers to RUSAGE_SELF or RUSAGE_CHILDREN	\n\
")
{
    IDIO_ASSERT (who);

    /*
     * Test Case: libc-wrap-errors/getrusage-bad-type.idio
     *
     * getrusage #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, who);
    int C_who = IDIO_C_TYPE_int (who);

    struct rusage *rusagep = (struct rusage *) idio_alloc (sizeof (struct rusage));

    if (-1 == getrusage (C_who, rusagep)) {
	/*
	 * Test Case:  libc-wrap-errors/getrusage-bad-who.idio
	 *
	 * On Linux:
	 *
	 * #define RUSAGE_SELF     0
	 * #define RUSAGE_CHILDREN (-1)
	 * #define RUSAGE_BOTH     (-2)
	 * #define RUSAGE_THREAD   1
	 *
	 * Is that positive/negative, a bit-mask?  15 seems to provoke
	 * EINVAL...
	 *
	 * getrusage (C/integer-> 15)
	 */

	IDIO_GC_FREE (rusagep);

	idio_error_system_errno ("getrusage", who, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_rusage, rusagep);
}

IDIO_DEFINE_PRIMITIVE1_DS ("getrlimit", libc_getrlimit, (IDIO resource), "resource", "\
in C, getrlimit (resource)					\n\
a wrapper to libc getrlimit (2)					\n\
								\n\
:param resource: resource, see below				\n\
:type resource: C/int						\n\
:return: struct-rlimit or raises ^system-error			\n\
:rtype: struct instance						\n\
								\n\
The resource names follow C conventions such as ``RLIMIT_AS``	\n\
and ``RLIMIT_NOFILE``.						\n\
")
{
    IDIO_ASSERT (resource);

    /*
     * Test Case: libc-wrap-errors/getrlimit-bad-resource-type.idio
     *
     * getrlimit #t
     *
     * NB Fedora uses an unsigned int enum whereas the
     * IDIO_LIBC_RLIMIT(n) macro defines the names as idio_C_int.
     */
    IDIO_USER_C_TYPE_ASSERT (int, resource);
    int C_resource = IDIO_C_TYPE_int (resource);

    struct rlimit *rlimp = idio_alloc (sizeof (struct rlimit));

    if (getrlimit (C_resource, rlimp) == -1) {
	/*
	 * Test Case:  libc-wrap-errors/getrlimit-bad-rlim.idio
	 *
	 * getrlimit (C/integer-> -1)
	 */
	idio_error_system_errno ("getrlimit", resource, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_rlimit, rlimp);
}

IDIO_DEFINE_PRIMITIVE0_DS ("getppid", libc_getppid, (void), "", "\
in C, getppid ()						\n\
a wrapper to libc getppid(2)					\n\
								\n\
:return: PPID or raises ^system-error				\n\
:rtype: libc/pid_t						\n\
")
{
    /*
     * XXX getppid(2) is always successful.
     */
    return idio_libc_pid_t (getppid ());
}

IDIO_DEFINE_PRIMITIVE0_DS ("getpid", libc_getpid, (void), "", "\
in C, getpid ()							\n\
a wrapper to libc getpid(2)					\n\
								\n\
:return: PID or raises ^system-error				\n\
:rtype: libc/pid_t						\n\
")
{
    /*
     * XXX getpid(2) is always successful.
     */
    return idio_libc_pid_t (getpid ());
}

IDIO_DEFINE_PRIMITIVE0_DS ("getpgrp", libc_getpgrp, (void), "", "\
in C, getpgrp ()						\n\
a wrapper to libc getpgrp(2)					\n\
								\n\
:return: PGID or raises ^system-error				\n\
:rtype: libc/pid_t						\n\
")
{
    pid_t pid = getpgrp ();

    if (-1 == pid) {
	/*
	 * Test Case: ??
	 *
	 * Not sure this POSIX.1 variant getpgrp(2) can fail...here's
	 * hoping!
	 */
	idio_error_system_errno ("getpgrp", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_libc_pid_t (pid);
}

IDIO_DEFINE_PRIMITIVE0_DS ("getcwd", libc_getcwd, (void), "", "\
in C, getcwd (buf, size)					\n\
a wrapper to libc getcwd(3)					\n\
								\n\
:return: CWD or raises ^system-error				\n\
:rtype: string							\n\
")
{
    /*
     * getcwd(3) and its arguments
     *
     * A sensible {size}?
     *
     * PATH_MAX varies: POSIX is 256, CentOS 7 is 4096
     *
     * The Linux man page for realpath(3) suggests that calling
     * pathconf(3) for _PC_PATH_MAX doesn't improve matters a whole
     * bunch as it can return a value that is infeasible to allocate
     * in memory.
     *
     * Some systems (OS X, FreeBSD) suggest getcwd(3) should accept
     * MAXPATHLEN (which is #define'd as PATH_MAX in <sys/param.h>).
     *
     * A NULL {buf}?
     *
     * Some systems (older OS X, FreeBSD) do not support a zero {size}
     * parameter.  If passed a NULL {buf}, those systems seem to
     * allocate as much memory as is required to contain the result,
     * regardless of {size}.
     *
     * On systems that do support a zero {size} parameter then they
     * will limit themselves to allocating a maximum of {size} bytes
     * if passed a NULL {buf} and a non-zero {size}.
     *
     * Given that we can't set {size} to zero on some systems then
     * always set {size} to PATH_MAX which should be be enough.
     *
     * Bah! Until Fedora 33/gcc 10.2.1 which is complaining:
     *
     *  warning: argument 1 is null but the corresponding size argument 2 value is 4096
     *
     * It also helpfully reports that:
     *
     *  /usr/include/unistd.h:520:14: note: in a call to function ‘getcwd’ declared with attribute ‘write_only (1, 2)’
     *
     * See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96832
     *
     * If getcwd(3) returns a value that consumes all of PATH_MAX (or
     * more) then we're doomed to hit other problems in the near
     * future anyway as other parts of the system try to use the
     * result.
     */

    /*
     * Mac OS X: getcwd(3) => EMFILE (the man page says nothing)
     */

    char *cwd = idio_getcwd ("libc/getcwd", NULL, PATH_MAX);
    if (NULL == cwd) {
	/*
	 * Test Case: libc-wrap-errors/getcwd-no-access.idio
	 *
	 * tmpdir := (make-tmp-dir)
	 * chdir tmpdir
	 * chmod -rx tmpdir
	 * (getcwd)
	 */
	idio_error_system_errno ("getcwd", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    IDIO r = idio_pathname_C (cwd);
    /*
     * XXX getcwd() used system allocator
     */
    free (cwd);

    return r;
}

IDIO_DEFINE_PRIMITIVE1_DS ("fstat", libc_fstat, (IDIO fd), "fd", "\
in C: fstat (fd)				\n\
a wrapper to libc fstat(2)			\n\
						\n\
:param fd:					\n\
:type fd: C/int					\n\
:return: struct-stat or raises ^system-error	\n\
:rtype: struct instance				\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/fstat-bad-type.idio
     *
     * fstat #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    struct stat* statp = idio_alloc (sizeof (struct stat));

    int fstat_r = fstat (C_fd, statp);

    if (-1 == fstat_r) {
	/*
	 * Test Case: libc-wrap-errors/fstat-bad-fd.idio
	 *
	 * fstat (C/integer-> 99)
	 *
	 * Obviously, this is a risky test.  perhaps we should get a
	 * new fd then close it and reuse that fd?
	 */
        idio_error_system_errno ("fstat", fd, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_stat, statp);
}

IDIO_DEFINE_PRIMITIVE0_DS ("fork", libc_fork, (void), "", "\
in C, fork ()							\n\
a wrapper to libc fork(2)					\n\
								\n\
:return: 0 or PID						\n\
:rtype: libc/pid_t						\n\
")
{
    pid_t C_pid = fork ();

    if (-1 == C_pid) {
	/*
	 * Test Case: ??
	 *
	 * How do you make fork(2) fail?
	 */
	idio_error_system_errno ("fork", idio_S_nil, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    if (0 == C_pid) {
	idio_job_control_cmd_pid = getpid ();
	idio_job_control_interactive = 0;
	idio_module_set_symbol_value (IDIO_SYMBOLS_C_INTERN ("PID"), idio_libc_pid_t (getpid ()), idio_Idio_module);
	idio_module_set_symbol_value (IDIO_SYMBOLS_C_INTERN ("PPID"), idio_libc_pid_t (getppid ()), idio_Idio_module);
    }

    return idio_libc_pid_t (C_pid);
}

IDIO_DEFINE_PRIMITIVE2V_DS ("fcntl", libc_fcntl, (IDIO fd, IDIO cmd, IDIO args), "fd cmd [args]", "\
in C, fcntl (fd, cmd[, args])					\n\
a wrapper to libc fcntl(2)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:param cmd: fcntl command					\n\
:type cmd: C/int						\n\
:param args: fcntl command args					\n\
:type args: list						\n\
:return: appropriate value or raises ^system-error		\n\
:rtype: C/int							\n\
								\n\
Supported commands include:					\n\
F_DUPFD								\n\
F_DUPFD_CLOEXEC (if supported)					\n\
F_GETFL								\n\
F_SETFL								\n\
"
)
{
    IDIO_ASSERT (fd);
    IDIO_ASSERT (cmd);
    IDIO_ASSERT (args);

    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    IDIO_USER_C_TYPE_ASSERT (int, cmd);
    int C_cmd = IDIO_C_TYPE_int (cmd);

    IDIO arg = idio_list_head (args);

    int fcntl_r;

    switch (C_cmd) {
    case F_DUPFD:
	{
	    /*
	     * CentOS 6 i386 fcntl(2) says it wants long but accepts
	     * int
	     */
	    IDIO_USER_C_TYPE_ASSERT (int, arg);
	    int C_arg = IDIO_C_TYPE_int (arg);

	    fcntl_r = fcntl (C_fd, C_cmd, C_arg);
	}
	break;
#if defined (F_DUPFD_CLOEXEC)
    case F_DUPFD_CLOEXEC:
	{
	    /*
	     * CentOS 6 i386 fcntl(2) says it wants long but accepts
	     * int
	     */
	    IDIO_USER_C_TYPE_ASSERT (int, arg);
	    int C_arg = IDIO_C_TYPE_int (arg);

	    fcntl_r = fcntl (C_fd, C_cmd, C_arg);
	}
	break;
#endif
    case F_GETFD:
	{
	    fcntl_r = fcntl (C_fd, C_cmd);
	}
	break;
    case F_SETFD:
	{
	    IDIO_USER_C_TYPE_ASSERT (int, arg);
	    int C_arg = IDIO_C_TYPE_int (arg);

	    fcntl_r = fcntl (C_fd, C_cmd, C_arg);
	}
	break;
    case F_GETFL:
	{
	    fcntl_r = fcntl (C_fd, C_cmd);
	}
	break;
    case F_SETFL:
	{
	    IDIO_USER_C_TYPE_ASSERT (int, arg);
	    int C_arg = IDIO_C_TYPE_int (arg);

	    fcntl_r = fcntl (C_fd, C_cmd, C_arg);
	}
	break;
    default:
	/*
	 * Test Case: libc-wrap-errors/fcntl-unknown-cmd.idio
	 *
	 * fcntl C/0i (C/integer-> 98765)
	 */
	idio_error_param_value_msg ("fcntl", "cmd", cmd, "unexpected cmd", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    if (-1 == fcntl_r) {
        if (EINVAL == errno &&
	    F_SETFD == C_cmd &&
	    idio_vm_virtualisation_WSL) {
	    perror ("fcntl F_SETFD");
	} else {
	    /*
	     * Test Case: libc-wrap-errors/fcntl-F_DUPFD-bad-fd.idio
	     *
	     * fd+name := mkstemp "XXXXXX"
	     * close (ph fd+name)
	     * delete-file (pht fd+name)
	     * fcntl (ph fd+name) F_DUPFD C/0i
	     */
	    args = idio_pair (cmd, args);
	    args = idio_pair (fd, args);
	    idio_error_system_errno ("fcntl", args, IDIO_C_FUNC_LOCATION ());

	    return idio_S_notreached;
	}
    }

    return idio_C_int (fcntl_r);
}

IDIO_DEFINE_PRIMITIVE2_DS ("dup2", libc_dup2, (IDIO oldfd, IDIO newfd), "oldfd newfd", "\
in C, dup2 (oldfd, newfd)					\n\
a wrapper to libc dup2(2)					\n\
								\n\
:param oldfd: file descriptor					\n\
:type oldfd: C/int						\n\
:param newfd: file descriptor					\n\
:type newfd: C/int						\n\
:return: new fd or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (oldfd);
    IDIO_ASSERT (newfd);

    IDIO_USER_C_TYPE_ASSERT (int, oldfd);
    int C_oldfd = IDIO_C_TYPE_int (oldfd);

    IDIO_USER_C_TYPE_ASSERT (int, newfd);
    int C_newfd = IDIO_C_TYPE_int (newfd);

    int dup2_r = dup2 (C_oldfd, C_newfd);

    if (-1 == dup2_r) {
	/*
	 * Test Case: libc-wrap-errors/dup2-bad-fd.idio
	 *
	 * fd+name := mkstemp tmpfilename
	 * close (ph fd+name)
	 * delete-file (pht fd+name)
	 * dup2 (ph fd+name) 99
	 */
	idio_error_system_errno ("dup2", IDIO_LIST2 (oldfd, newfd), IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (dup2_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("dup", libc_dup, (IDIO oldfd), "oldfd", "\
in C, dup (oldfd)						\n\
a wrapper to libc dup(2)					\n\
								\n\
:param oldfd: file descriptor					\n\
:type oldfd: C/int						\n\
:return: new fd or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (oldfd);

    IDIO_USER_C_TYPE_ASSERT (int, oldfd);
    int C_oldfd = IDIO_C_TYPE_int (oldfd);

    int dup_r = dup (C_oldfd);

    if (-1 == dup_r) {
	/*
	 * Test Case: libc-wrap-errors/dup-bad-fd.idio
	 *
	 * fd+name := mkstemp tmpfilename
	 * close (ph fd+name)
	 * delete-file (pht fd+name)
	 * dup (ph fd+name)
	 */
	idio_error_system_errno ("dup", oldfd, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (dup_r);
}

IDIO_DEFINE_PRIMITIVE0V_DS ("ctime", libc_ctime, (IDIO args), "[t]", "\
in C: ctime (t)				\n\
a wrapper to libc ctime(3)		\n\
					\n\
:param t: time in seconds since epoch	\n\
:type t: libc/time_t			\n\
:return:				\n\
:rtype: string				\n\
					\n\
``t`` defaults to the result of time(2)	\n\
")
{
    IDIO_ASSERT (args);

    time_t C_t = 0;

    if (idio_isa_pair (args)) {
	IDIO t = IDIO_PAIR_H (args);

	/*
	 * Test Case: libc-errors/ctime-bad-t-type.idio
	 *
	 * ctime #t
	 */
	IDIO_USER_libc_TYPE_ASSERT (time_t, t);
	C_t = IDIO_C_TYPE_libc_time_t (t);
    } else {
	C_t = time (NULL);
    }

    /*
     * ctime() uses static buffers and it's no real effort to use
     * ctime_r().
     *
     * How big can {buf} get?  Linux and SunOS suggest at least 26
     * bytes, so let's double that.
     *
     * SunOS in non _POSIX_PTHREAD_SEMANTICS mode (ie. default) also
     * wants to pass buflen.
     *
     * Of note is that the git(1) source code bans the use of ctime_r.
     */
#define IDIO_CTIME_BUFLEN 52
    char buf[IDIO_CTIME_BUFLEN];

#if defined (__sun) && defined (__SVR4)
    char* ctime_r_r = ctime_r (&C_t, buf, IDIO_CTIME_BUFLEN);
#else
    char* ctime_r_r = ctime_r (&C_t, buf);
#endif

    if (NULL == ctime_r_r) {
        idio_error_system_errno ("ctime_r", idio_libc_time_t (C_t), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_string_C (buf);
}

IDIO_DEFINE_PRIMITIVE1_DS ("close", libc_close, (IDIO fd), "fd", "\
in C, close (fd)						\n\
a wrapper to libc close(2)					\n\
								\n\
:param fd: file descriptor					\n\
:type fd: C/int							\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (fd);

    /*
     * Test Case: libc-wrap-errors/close-bad-type.idio
     *
     * close #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, fd);
    int C_fd = IDIO_C_TYPE_int (fd);

    int close_r = close (C_fd);

    if (-1 == close_r) {
	/*
	 * Test Case: libc-wrap-errors/close-bad-fd.idio
	 *
	 * fd+name := mkstemp tmpfilename
	 * close (ph fd+name)
	 * delete-file (pht fd+name)
	 * close (ph fd+name)
	 */
	idio_error_system_errno ("close", fd, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (close_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("chdir", libc_chdir, (IDIO path), "path", "\
in C, chdir (path)						\n\
a wrapper to libc chdir(2)					\n\
								\n\
:param path: directory name					\n\
:type path: string						\n\
:return: 0 or raises ^system-error				\n\
:rtype: C/int							\n\
")
{
    IDIO_ASSERT (path);

    /*
     * Test Case: libc-wrap-errors/chdir-bad-type.idio
     *
     * chdir #t
     */
    IDIO_USER_TYPE_ASSERT (string, path);

    int free_path_C = 0;

    /*
     * Test Case: libc-wrap-errors/chdir-bad-format.idio
     *
     * chdir (join-string (make-string 1 #U+0) '("hello" "world"))
     */
    char *path_C = idio_libc_string_C (path, "chdir", &free_path_C, IDIO_C_FUNC_LOCATION ());

    int chdir_r = chdir (path_C);

    if (free_path_C) {
	IDIO_GC_FREE (path_C);
    }

    if (-1 == chdir_r) {
	/*
	 * Test Case: libc-wrap-errors/chdir-non-existent.idio
	 *
	 * tmpdir := (make-tmp-dir)
	 * rmdir tmpdir
	 * chdir tmpdir
	 */
	idio_error_system_errno ("chdir", path, IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }

    return idio_C_int (chdir_r);
}

IDIO_DEFINE_PRIMITIVE1_DS ("asctime", libc_asctime, (IDIO tm), "tm", "\
in C: asctime (tm)			\n\
a wrapper to libc asctime(3)		\n\
					\n\
:param tm: 				\n\
:type tm: C struct tm			\n\
:return:				\n\
:rtype: string				\n\
")
{
    IDIO_ASSERT (tm);

    /*
     * Test Case: libc-errors/asctime-bad-tm-type.idio
     *
     * asctime #t
     */
    IDIO_USER_C_TYPE_ASSERT (pointer, tm);
    if (idio_CSI_libc_struct_tm != IDIO_C_TYPE_POINTER_PTYPE (tm)) {
	/*
	 * Test Case: libc-errors/asctime-tm-invalid-pointer-type.idio
	 *
	 * asctime libc/NULL
	 */
	idio_error_param_value_exp ("asctime", "tm", tm, "C struct tm", IDIO_C_FUNC_LOCATION ());

	return idio_S_notreached;
    }
    struct tm *C_tm = IDIO_C_TYPE_POINTER_P (tm);

    /*
     * asctime() uses static buffers and it's no real effort to use
     * asctime_r().
     *
     * How big can {buf} get?  Linux and SunOS suggest at least 26
     * bytes, so let's double that.
     *
     * SunOS in non _POSIX_PTHREAD_SEMANTICS mode (ie. default) also
     * wants to pass buflen.
     *
     * Of note is that the git(1) source code bans the use of
     * asctime_r.
     */
#define IDIO_ASCTIME_BUFLEN 52
    char buf[IDIO_ASCTIME_BUFLEN];

#if defined (__sun) && defined (__SVR4)
    char* asctime_r_r = asctime_r (C_tm, buf, IDIO_ASCTIME_BUFLEN);
#else
    char* asctime_r_r = asctime_r (C_tm, buf);
#endif

    if (NULL == asctime_r_r) {
        idio_error_system_errno ("asctime_r", tm, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_string_C (buf);
}

IDIO_DEFINE_PRIMITIVE0V_DS ("localtime", libc_localtime, (IDIO args), "[t]", "\
in C: localtime (t)			\n\
a wrapper to libc localtime(3)		\n\
					\n\
:param t: time in seconds since epoch	\n\
:type t: libc/time_t			\n\
:return:				\n\
:rtype: C struct tm			\n\
					\n\
``t`` defaults to the result of time(2)	\n\
")
{
    IDIO_ASSERT (args);

    time_t C_t = 0;

    if (idio_isa_pair (args)) {
	IDIO t = IDIO_PAIR_H (args);

	/*
	 * Test Case: libc-errors/localtime-bad-t-type.idio
	 *
	 * localtime #t
	 */
	IDIO_USER_libc_TYPE_ASSERT (time_t, t);
	C_t = IDIO_C_TYPE_libc_time_t (t);
    } else {
	C_t = time (NULL);
    }

    /*
     * localtime() uses static buffers *and* we need to allocate the
     * result anyway so we'll use localtime_r().
     *
     * In the NOTES on Linux: "For portable code, tzset(3) should be
     * called before localtime_r()."
     */
    tzset ();
    struct tm *result = idio_alloc (sizeof (struct tm));

    struct tm* localtime_r_r = localtime_r (&C_t, result);

    if (NULL == localtime_r_r) {
	IDIO_GC_FREE (result);

        idio_error_system_errno ("localtime_r", idio_libc_time_t (C_t), IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_C_pointer_type (idio_CSI_libc_struct_tm, result);
}

IDIO_DEFINE_PRIMITIVE0_DS ("time", libc_time, (void), "", "\
in C: time ()				\n\
a wrapper to libc time(2)		\n\
					\n\
:return:				\n\
:rtype: libc/time_t			\n\
")
{
    time_t time_r = time (NULL);

    if (-1 == time_r) {
        idio_error_system_errno ("time", idio_S_nil, IDIO_C_FUNC_LOCATION ());

        return idio_S_notreached;
    }

    return idio_libc_time_t (time_r);
}

IDIO_DEFINE_PRIMITIVE2_DS ("access", libc_access, (IDIO pathname, IDIO mode), "pathname mode", "\
in C, access (pathname, mode)					\n\
a wrapper to libc access(2)					\n\
								\n\
:param pathname: file name					\n\
:type pathname: string						\n\
:param mode: accessibility check(s)				\n\
:type mode: C/int						\n\
:return: #t or #f						\n\
:rtype: boolean							\n\
								\n\
Any non-zero value from access(2) returns #f,			\n\
no ^system-error is raised.					\n\
")
{
    IDIO_ASSERT (pathname);
    IDIO_ASSERT (mode);

    /*
     * Test Case: libc-wrap-errors/access-bad-pathname-type.idio
     *
     * access #t #t
     */
    IDIO_USER_TYPE_ASSERT (string, pathname);

    int free_pathname_C = 0;

    /*
     * Test Case: libc-wrap-errors/access-bad-format.idio
     *
     * access (join-string (make-string 1 #U+0) '("hello" "world")) libc/R_OK
     */
    char *pathname_C = idio_libc_string_C (pathname, "access", &free_pathname_C, IDIO_C_FUNC_LOCATION ());

    /*
     * Test Case: libc-wrap-errors/access-bad-mode-type.idio
     *
     * access "." #t
     */
    IDIO_USER_C_TYPE_ASSERT (int, mode);
    int C_mode = IDIO_C_TYPE_int (mode);

    IDIO access_r = idio_S_false;

    /*
     * access(2) errors are a bit vague:
     *
     *   On error (at least one bit in mode asked for a permission
     *   that is denied, or mode is F_OK and the file does not exist,
     *   or some other error occurred), -1 is returned, and errno is
     *   set appropriately.
     *
     * So, we'll just fail and let the user figure it out...
     */

    if (0 == access (pathname_C, C_mode)) {
	access_r = idio_S_true;
    }

    if (free_pathname_C) {
	IDIO_GC_FREE (pathname_C);
    }

    return access_r;
}

void idio_libc_api_add_primitives ()
{
    IDIO iuvas = idio_module_symbol_value (idio_util_value_as_string,
					   idio_Idio_module,
					   idio_S_nil);

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_utsname_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_utsname,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-utsname-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_tms_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_tms,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-tms-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_termios_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_termios,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-termios-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_tm_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_tm,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-tm-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_stat_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_stat,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-stat-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timespec_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_timespec,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-timespec-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_rlimit_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_rlimit,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-rlimit-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timeval_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_timeval,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-timeval-as-string"),
								   idio_libc_module,
								   idio_S_nil));

    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_rusage_as_string);
    idio_hash_put (iuvas,
		   idio_CSI_libc_struct_rusage,
		   idio_module_symbol_value (IDIO_SYMBOLS_C_INTERN ("struct-rusage-as-string"),
								   idio_libc_module,
								   idio_S_nil));
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_write);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_waitpid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_unlink);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_uname);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_times);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_tcsetpgrp);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_tcsetattr);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_tcgetpgrp);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_tcgetattr);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_strsignal);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_strptime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_strftime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_strerror);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_stat);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_sleep);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_signal);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_setrlimit);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_setpgid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_rmdir);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_read);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_pipe);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_nanosleep);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_mktime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_mkstemp);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_mkfifo);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_mkdtemp);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_mkdir);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_lstat);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_killpg);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getpgid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_kill);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_isatty);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_gmtime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_gettimeofday);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getsid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getrusage);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getrlimit);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getppid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getpid);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getpgrp);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_getcwd);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_fstat);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_fork);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_fcntl);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_dup2);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_dup);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_ctime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_close);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_chdir);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_asctime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_localtime);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_time);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_access);

}

void idio_init_libc_api ()
{

    /* /usr/include/bits/resource.h */
    /* enum __rlimit_resource */
    /*
     * RLIMIT_* are (more portably re-)defined in
     * idio_libc_set_rlimit_names() in libc-wrap.c however the
     * generated header/Idio files will still reference these names
     */
#ifdef __rlimit_resource
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_CPU"), idio_C_uint (RLIMIT_CPU), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_FSIZE"), idio_C_uint (RLIMIT_FSIZE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_DATA"), idio_C_uint (RLIMIT_DATA), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_STACK"), idio_C_uint (RLIMIT_STACK), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_CORE"), idio_C_uint (RLIMIT_CORE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_RSS"), idio_C_uint (__RLIMIT_RSS), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_NOFILE"), idio_C_uint (RLIMIT_NOFILE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_OFILE"), idio_C_uint (__RLIMIT_OFILE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RLIMIT_AS"), idio_C_uint (RLIMIT_AS), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_NPROC"), idio_C_uint (__RLIMIT_NPROC), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_MEMLOCK"), idio_C_uint (__RLIMIT_MEMLOCK), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_LOCKS"), idio_C_uint (__RLIMIT_LOCKS), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_SIGPENDING"), idio_C_uint (__RLIMIT_SIGPENDING), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_MSGQUEUE"), idio_C_uint (__RLIMIT_MSGQUEUE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_NICE"), idio_C_uint (__RLIMIT_NICE), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_RTPRIO"), idio_C_uint (__RLIMIT_RTPRIO), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_RTTIME"), idio_C_uint (__RLIMIT_RTTIME), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIMIT_NLIMITS"), idio_C_uint (__RLIMIT_NLIMITS), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("__RLIM_NLIMITS"), idio_C_uint (__RLIM_NLIMITS), idio_libc_module);
#endif	/* __rlimit_resource */

    /* /usr/include/bits/resource.h */
    /* enum __rusage_who */
#ifdef __rusage_who
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RUSAGE_SELF"), idio_C_int (RUSAGE_SELF), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RUSAGE_CHILDREN"), idio_C_int (RUSAGE_CHILDREN), idio_libc_module);
    idio_module_export_symbol_value (IDIO_SYMBOLS_C_INTERN ("RUSAGE_THREAD"), idio_C_int (RUSAGE_THREAD), idio_libc_module);
#endif  /* __rusage_who */

    IDIO fgvi;

    /* /usr/include/sys/utsname.h */
    IDIO_SYMBOL_DEF ("sysname", sysname);
    IDIO_SYMBOL_DEF ("nodename", nodename);
    IDIO_SYMBOL_DEF ("release", release);
    IDIO_SYMBOL_DEF ("version", version);
    IDIO_SYMBOL_DEF ("machine", machine);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_utsname_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct utsname", libc_struct_utsname, fgvi);

    /* /usr/include/sys/times.h */
    IDIO_SYMBOL_DEF ("tms_utime", tms_utime);
    IDIO_SYMBOL_DEF ("tms_stime", tms_stime);
    IDIO_SYMBOL_DEF ("tms_cutime", tms_cutime);
    IDIO_SYMBOL_DEF ("tms_cstime", tms_cstime);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_tms_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct tms", libc_struct_tms, fgvi);

    /* /usr/include/bits/termios-struct.h */
    IDIO_SYMBOL_DEF ("c_iflag", c_iflag);
    IDIO_SYMBOL_DEF ("c_oflag", c_oflag);
    IDIO_SYMBOL_DEF ("c_cflag", c_cflag);
    IDIO_SYMBOL_DEF ("c_lflag", c_lflag);
    IDIO_SYMBOL_DEF ("c_line", c_line);
    IDIO_SYMBOL_DEF ("c_cc", c_cc);
    IDIO_SYMBOL_DEF ("c_ispeed", c_ispeed);
    IDIO_SYMBOL_DEF ("c_ospeed", c_ospeed);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_termios_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct termios", libc_struct_termios, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_termios_set);

    /* /usr/include/bits/types/struct_tm.h */
    IDIO_SYMBOL_DEF ("tm_sec", tm_sec);
    IDIO_SYMBOL_DEF ("tm_min", tm_min);
    IDIO_SYMBOL_DEF ("tm_hour", tm_hour);
    IDIO_SYMBOL_DEF ("tm_mday", tm_mday);
    IDIO_SYMBOL_DEF ("tm_mon", tm_mon);
    IDIO_SYMBOL_DEF ("tm_year", tm_year);
    IDIO_SYMBOL_DEF ("tm_wday", tm_wday);
    IDIO_SYMBOL_DEF ("tm_yday", tm_yday);
    IDIO_SYMBOL_DEF ("tm_isdst", tm_isdst);
#if defined (__sun) && defined (__SVR4)
#else
    IDIO_SYMBOL_DEF ("tm_gmtoff", tm_gmtoff);
    IDIO_SYMBOL_DEF ("tm_zone", tm_zone);
#endif

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_tm_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct tm", libc_struct_tm, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_tm_set);

    /* /usr/include/bits/struct_stat.h */
    IDIO_SYMBOL_DEF ("st_dev", st_dev);
    IDIO_SYMBOL_DEF ("st_ino", st_ino);
    IDIO_SYMBOL_DEF ("st_nlink", st_nlink);
    IDIO_SYMBOL_DEF ("st_mode", st_mode);
    IDIO_SYMBOL_DEF ("st_uid", st_uid);
    IDIO_SYMBOL_DEF ("st_gid", st_gid);
    IDIO_SYMBOL_DEF ("st_rdev", st_rdev);
    IDIO_SYMBOL_DEF ("st_size", st_size);
    IDIO_SYMBOL_DEF ("st_blksize", st_blksize);
    IDIO_SYMBOL_DEF ("st_blocks", st_blocks);
    IDIO_SYMBOL_DEF ("st_atim", st_atim);
    IDIO_SYMBOL_DEF ("st_mtim", st_mtim);
    IDIO_SYMBOL_DEF ("st_ctim", st_ctim);

    /* specials */
    IDIO_SYMBOL_DEF ("st_atime", st_atime);
    IDIO_SYMBOL_DEF ("st_mtime", st_mtime);
    IDIO_SYMBOL_DEF ("st_ctime", st_ctime);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_stat_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct stat", libc_struct_stat, fgvi);

    /* /usr/include/bits/types/struct_timespec.h */
    IDIO_SYMBOL_DEF ("tv_sec", tv_sec);
    IDIO_SYMBOL_DEF ("tv_nsec", tv_nsec);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timespec_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct timespec", libc_struct_timespec, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timespec_set);

    /* /usr/include/bits/resource.h */
    IDIO_SYMBOL_DEF ("rlim_cur", rlim_cur);
    IDIO_SYMBOL_DEF ("rlim_max", rlim_max);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_rlimit_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct rlimit", libc_struct_rlimit, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_rlimit_set);

    /* /usr/include/bits/types/struct_timeval.h */
    /* tv_sec already declared */
    IDIO_SYMBOL_DEF ("tv_usec", tv_usec);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timeval_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct timeval", libc_struct_timeval, fgvi);
    IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_timeval_set);

    /* /usr/include/bits/types/struct_rusage.h */
    IDIO_SYMBOL_DEF ("ru_utime", ru_utime);
    IDIO_SYMBOL_DEF ("ru_stime", ru_stime);

    fgvi = IDIO_EXPORT_MODULE_PRIMITIVE (idio_libc_module, libc_struct_rusage_ref);
    IDIO_C_STRUCT_IDENT_DEF ("struct rusage", libc_struct_rusage, fgvi);

}
