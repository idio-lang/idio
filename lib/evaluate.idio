#*

Copyright (c) 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

evaluate.idio

*#

module evaluate
export (
	 evaluate
)
import expander operator codegen threading vm

define (meaning-error-location src) {
  lo := #f
  if (not (null? src)) {
    lo = hash-ref %idio-src-properties src #f
  }

  if lo {
    sprintf "%s:line %d" (%idio-lexical-object-name lo) (%idio-lexical-object-line lo)
  } {
    sprintf "<no lexobj>"
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; all evaluation errors are derived from ^evaluation-error
;
; most of the specific errors just add some pertinent text

define (meaning-base-error src msg expr) {
  c := make-condition ^evaluation-error msg (meaning-error-location src) #n expr
  raise c
}

define (meaning-error-param-type src msg expr) {
  meaning-base-error src (sprintf "parameter type: %s" msg) expr
}

define (meaning-error-param src msg expr) {
  meaning-base-error src (sprintf "%s: %s" expr msg) expr
}

define (meaning-evaluation-error src msg expr) {
  meaning-base-error src msg expr
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; some of the various static errors should only occur in broken
; internal code
define (meaning-error-static-redefine src msg name cv new) {
  det := sprintf "%s: %s is currently %s: proposed %s" msg name cv new
  c := make-condition ^st-variable-error msg (meaning-error-location src) det name
  raise c
}

define (meaning-error-static-variable src msg name) {
  c := make-condition ^st-variable-error msg (meaning-error-location src) name name
  raise c
}

define (meaning-error-static-unbound src name) {
  meaning-error-static-variable src "unbound" name
}

define (meaning-error-static-immutable src name) {
  meaning-error-static-variable src "immutable" name
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define (meaning-error-static-primitive-arity src msg f args name primdata) {
  arity := sprintf "%d" (primitive-arity primdata)
  if (primitive-varargs? primdata) {
    arity = append-string arity "*"
  }
  det := sprintf "arity != %s; primitive (%s %s) was called as (%s %@)" arity f (%property f :sigstr) f args
  c := make-condition ^st-function-arity-error msg (meaning-error-location src) det
  raise c
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define-struct eval-flags tailp scope define
no-flags := make-eval-flags #f #n #f

define (set-tailp flags) {
  make-eval-flags #t (eval-flags-scope flags) (eval-flags-define flags)
}

define (clear-tailp flags) {
  make-eval-flags #f (eval-flags-scope flags) (eval-flags-define flags)
}

define (clear-define flags) {
  make-eval-flags (eval-flags-tailp flags) (eval-flags-scope flags) #f
}

define (set-scope scope flags) {
  make-eval-flags (eval-flags-tailp flags) scope (eval-flags-define flags)
}

define (define-scope scope flags) {
  make-eval-flags (eval-flags-tailp flags) scope #t
}

;; symbol-info is a tuple: (scope ci vi mod creator)

define (meaning-toplevel-extend src name flags cs cm) {
  flag-scope := (eval-flags-scope flags)

  si := find-symbol name cm

  if (pair? si) {
    cur-scope := ph si

    if (not (eq? cur-scope flag-scope)) {
      meaning-error-static-redefine src "toplevel-extend: type change" name si flag-scope
    } {
      pht si
    }
  } {
    if (and (eq? flag-scope 'toplevel)
	    (not (eval-flags-define flags))) {
	      eprintf "toplevel-extend: forward reference: %s at %s\n" name (meaning-error-location src)
	      if (not (hash-ref %idio-src-properties src #f)) {
		eprintf "src=%s\n" src
	      }
    }
    ci := codegen-constants-lookup-or-extend cs name

    set-symbol! name (list flag-scope ci 0 cm "meaning-toplevel-extend") cm
  }
}

define (meaning-environ-extend src name val cs) {
  ; environment variables are only defined in 'Idio module
  im := find-module 'Idio

  si := find-symbol name im

  if (pair? si) {
    cur-scope := ph si

    if (not (eq? cur-scope 'environ)) {
      meaning-error-static-redefine src "environ-extend: type change" name si cur-scope
    } {
      pht si
    }
  } {
    ci := codegen-constants-lookup-or-extend cs name
    vi := (vm-extend-values)

    ;; I don't like these two statements.  They should be the concern
    ;; of the VM but there's no explicit instruction to the VM to
    ;; create an environ variable.  Perhaps there should be?
    set-module-vci! 'Idio ci ci
    set-module-vvi! 'Idio ci vi

    set-symbol! name (list 'environ ci vi im "idio-environ-extend") im
    set-symbol-value! name val im
  }
}

#*

meaning-lexical-lookup

{nametree} is a list of association lists with each association list
representing the names of variables introduced at some level with
newer levels preceding older ones with the effect that at the time of
lookup the innermost level is the first association list and will
therefore be searched first.

formal parameters for a given level are stashed as (name 'param j)
where {name} is the {j}th formal parameter introduced at that level.

local variables for a given level are stashed as (name 'local j) where
{name} is the {j}th variable introduced at that level -- j starts at
length(formals)+1 (for varargs)

Nominally, you would walk through each "level" of names looking for
your variable name.  If you found it at depth {i} then you can combine
that with the corresponding {j} to give a SHALLOW (for {i} == 0) or
DEEP (for {i} > 0) variable reference.

The return for a name is ('param {i} {j}) or ('local {i} {j})

It is interspersed with dynamic and environ variables.  They are
one-at-a-time variable introductions and they should not increment
{i}!

The return is, say, ('dynamic {ci}) where {ci} is the constant index
associated with the dynamic/environ variable.

*#
define (meaning-lexical-lookup src nametree name) {
  loop :+ function (nt i) {
	    if (null? nt) #f {
	      name* := ph nt

	      if (pair? name*) {
		l := assq name name*
		if l {
		  scope := pht l	; ({name} 'param {j})
		  (case scope
			((param local) (list scope i (phtt l)))
			((dynamic environ) (pt l))
			(else (meaning-error-static-variable src "unexpected local variant" name)))
		} {
		  ;; only bump i if these were formal parameters
		  if (eq? 'param (phth name*)) {
		    loop (pt nt) (i + 1)
		  } {
		    loop (pt nt) i
		  }
		}
	      } {
		loop (pt nt) (i + 1)
	      }
	    }
  }

  loop nametree 0
}

define (meaning-nametree->list nametree) {
  r := #n
  loop-nametree :+ function (nt done) {
		     if done #n {
		       loop-names :+ function (names) {
				       if (null? names) #n {
					 name-info := ph names
					 if (and (not done)
						 (pair? name-info)
						 (pair? (pt name-info))
						 (eq? 'param (pht name-info))) {
						   done = #t
						 }
					 r = pair (ph name-info) r
					 loop-names (pt names)
				       }
		       }
		       loop-names (ph nt)

		       loop-nametree (pt nt) done
		     }
  }

  loop-nametree nametree #f
  r
}

define (meaning-nametree-extend-vparams nametree name*) {
  i := 0
  loop :+ function (ns r) {
	    if (null? ns) r {
	      tuple := list (ph ns) 'param i
	      i = i + 1
	      loop (pt ns) (pair tuple r)
	    }
  }

  pair (loop name* #n) nametree
}

define (meaning-nametree-extend-params nametree name*) {
  ;; consume a slot for varargs
  name* = append name* '(#f)

  meaning-nametree-extend-vparams nametree name*
}

define (meaning-nametree-extend-locals nametree name*) {
  ;; the correct value of i depends on what the params to the current
  ;; scope are.

  ;; Given n params plus 1 varargs the starting value of i for a local
  ;; is n+1 (remembering the slots start at 0)
  alist := #n
  i := 0
  i-loop :+ function (nt) {
	    if (null? nt) #n {
	      name* := ph nt
	      if (null? name*) {
		;; a thunk
		alist = list #f 'param 0
	      } {
		(case (phth name*)
		      ((local) {
			i = i + 1
			i-loop (pt nt)
		      })
		      ((param) {
			i = i + (length name*)
		      }))
	      }
	    }
  }
  i-loop nametree

  loop :+ function (ns r) {
	    if (null? ns) (reverse r) {
	      i = i + 1
	      loop (pt ns) (pair (list (ph ns) 'local i) r)
	    }
  }

  ;; we don't have the i++ feature from C so we need to decrement i
  ;; first
  i = i - 1
  pair (loop name* alist) nametree
}

define (meaning-nametree-dynamic-extend nametree name index scope) {
  pair (list (list name scope index)) nametree
}

define (meaning-variable-info src nametree name flags cs cm) {
  r := meaning-lexical-lookup src nametree name

  if (not r) {
    r = find-symbol name cm
    if (not r) {
      ; is name M/S ?
      r = symbol-direct-reference name
      if r {
	r = phtt r
	set-symbol! name r cm
      } {
	; not found -> (auto) extend toplevel
	meaning-toplevel-extend src name flags cs cm

	; meaning-toplevel-extend only returns a ci
	r = find-symbol name cm
      }
    }
  }

  r
}

define (meaning-prefer-properties e src) {
  if (and (pair? e)
	  (not (hash-ref %idio-src-properties src #f))) {
    e
  } {
    src
  }
}

mpp := meaning-prefer-properties

define (meaning-copy-src-properties src dst) {
  if (pair? dst) {
    dst-lo := hash-ref %idio-src-properties dst #f
    if (not dst-lo) {
      if (pair? src) {
	src-lo := hash-ref %idio-src-properties src #f
	if src-lo {
	  dst-lo = copy-value src-lo 'shallow
	  set-%idio-lexical-object-expr! dst-lo dst
	  hash-set! %idio-src-properties dst dst-lo
	}
      }
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; let's find some meaning in all of this!

define (meaning-reference src name nametree escapes flags cs cm) {
  si := meaning-variable-info src nametree name flags cs cm

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := ph si
  i := pht si

  (case scope
	((param local) {
	  ; ('param {i} {j})
	  j := phtt si
	  (if (i gt 0)
	      (list I-DEEP-ARGUMENT-REF i j)
	      (list I-SHALLOW-ARGUMENT-REF j))
	})
	((toplevel) {
	  ; ('toplevel ci vi)
	  vi := phtt si
	  (if (vi gt 0)
	      (list I-CHECKED-GLOBAL-VAL-REF vi)
	      (list I-GLOBAL-SYM-REF i))
	})
	((dynamic) (list I-DYNAMIC-SYM-REF i))
	((environ) (list I-ENVIRON-SYM-REF i))
	((computed) (list I-COMPUTED-SYM-REF i))
	((predef) {
	  vi := phtt si
	  list I-PREDEFINED vi
	})
	(else {
	  ;; Shouldn't get here unless the if clauses above don't
	  ;; cover everything.  Developer error?
	  meaning-error-static-unbound src name
	}))
}

define (meaning-function-reference src name nametree escapes flags cs cm) {
  si := meaning-variable-info src nametree name flags cs cm

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := ph si
  i := pht si

  (case scope
	((param local) {
	  ; ('param {i} {j})
	  j := phtt si
	  (if (i gt 0)
	      (list I-DEEP-ARGUMENT-REF i j)
	      (list I-SHALLOW-ARGUMENT-REF j))
	})
	((toplevel) {
	  ; ('toplevel ci vi)
	  vi := phtt si
	  (if (vi gt 0)
	      (list I-CHECKED-GLOBAL-FUNCTION-VAL-REF vi)
	      (list I-GLOBAL-FUNCTION-SYM-REF i))
	})
	((dynamic) (list I-DYNAMIC-FUNCTION-SYM-REF i))
	((environ) (list I-ENVIRON-SYM-REF i))
	((computed) (list I-COMPUTED-SYM-REF i))
	((predef) {
	  vi := phtt si
	  list I-PREDEFINED vi
	})
	(else {
	  ;; Shouldn't get here unless the if clauses above don't
	  ;; cover everything.  Developer error?
	  meaning-error-static-unbound src name
	}))
}

define (meaning-escape src e nametree escapes flags cs cm) {
  meaning (mpp e src) e nametree escapes flags cs cm
}

define (meaning-quotation src v nametree escapes flags) {
  list I-CONSTANT-SYM-REF v
}

; a couple of helper functions from Alan Bawden's Quasiquotation in
; Lisp paper -- reworked slightly

define (eps-qq-expand-list e) {
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		#T{ (list $(pht e)) })
	  ((eq? 'unquotesplicing sym)	(pht e))
	  ((eq? 'quasiquote sym)	(eps-qq-expand-list
					 (eps-qq-expand (pht e))))
	  (else				#T{ (list (append
						   $(eps-qq-expand-list (ph e))
						   $(eps-qq-expand (pt e)))) }))
  } {
    #T{ '($e) }
  }
}

define (eps-qq-expand e) {
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		(pht e))
	  ((eq? 'unquotesplicing sym)	(error 'eps-qq-expand "illegal use of $@ at head" e))
	  ((eq? 'quasiquote sym)	(eps-qq-expand
					 (eps-qq-expand (pht e))))
	  (else				#T{ (append $(eps-qq-expand-list (ph e))
						    $(eps-qq-expand (pt e))) }))
  } {
    #T{ '$e }
  }
}

define (qq-expand e) {
  eps-qq-expand e
}

define (STklos-backquotify e level) {
  ;printf "              bq    p?=%s e=%s\n" (pair? e) e
  (cond
   ((pair? e)
    (cond
     ((eq? (ph e) 'quasiquote)
      (list 'list ''quasiquote
		  (STklos-backquotify (pht e) (+ level 1))))
     ((eq? (ph e) 'unquote)
      (if (level le 0)
	  (pht e)
	  (list 'list ''unquote
		      (STklos-backquotify (pht e) (- level 1)))))
     ((eq? (ph e) 'unquotesplicing)
      (if (level le 0)
	  (list 'pair
		(STklos-backquotify (ph e) level)
		(STklos-backquotify (pt e) level))
	  (list 'list ''unquotesplicing
		      (STklos-backquotify (pht e) (- level 1)))))
     ((and (level le 0) (pair? (ph e)) (eq? (phh e) 'unquotesplicing))
      (if (null? (pt e))
	  (phth e)
	  (list 'append (phth e)
                        (STklos-backquotify (pt e) level))))
     (else
      (list 'pair
	    (STklos-backquotify (ph e) level)
	    (STklos-backquotify (pt e) level)))))
   ((symbol? e)
    (list 'quote e))
   (else
    e))
}

define (STklos-expand e) {
  STklos-backquotify e 0
}

define (meaning-quasiquotation src e nametree escapes flags cs cm) {
  ee := qq-expand e
  meaning-copy-src-properties src ee

  meaning ee ee nametree escapes flags cs cm
}

define (meaning-alternative src e1 e2 e3 nametree escapes flags cs cm) {
  m1 := meaning (mpp e1 src) e1 nametree escapes (clear-tailp flags) cs cm
  m2 := meaning (mpp e2 src) e2 nametree escapes flags cs cm
  m3 := meaning (mpp e3 src) e3 nametree escapes flags cs cm

  list I-ALTERNATIVE m1 m2 m3
}

#*

validate & rewrite the cond clauses, {clauses}, noting the special
cases of {=>}, {else}

*#

define (meaning-rewrite-cond prev src clause*) {
  (cond ((null? clause*) (void))

	((not (pair? clause*))
	 ;; Shouldn't get here, eg. "(cond)", as we test that the cond
	 ;; clause* are a pair in the main idio_meaning loop.
	 (meaning-evaluation-error src "cond: no clauses" clause*))

	((not (pair? (ph clause*))) {
	  if (and (pair? (pt clause*))
		  (pair? (pht clause*))) {
		    ;; Test Cases:
		    ;; evaluation-errors/rewrite-cond-isa-pair-only.idio
		    ;; evaluation-errors/rewrite-cond-isa-pair-before.idio
		    ;; evaluation-errors/rewrite-cond-isa-pair-after.idio

		    ;; cond #t
		    ;; cond #t (#f 1)
		    ;; cond (#f 1) #t
		    meaning-error-param-type (pht clause*) "cond: clause is not a pair (before)" clause*
		  } {
		    ;; Test Case: ??
		    meaning-error-param-type prev "cond: clause is not a pair (in/after)" clause*
		  }
	})

	((eq? 'else (phh clause*)) {
	  if (null? (pt clause*)) {
	    c* := append (list 'begin) (pth clause*)
	    meaning-copy-src-properties (mpp (pth clause*) src) c*
	    c*
	  } {
	    ;; Test Case: evaluation-errors/rewrite-cond-else-not-last.idio

	    ;; cond (else 1) (#t 2)
	    meaning-evaluation-error (ph clause*) "cond: else not in last clause" clause*
	  }
	})

	((and (pair? (pth clause*))
	      (eq? '=> (phth clause*))) {
		;; XXX We've just accessed the {phth clause*} so *of
		;; course* it's a list...the only useful thing we're
		;; doing here is checking there's explicitly three
		;; elements.

		ph-clause* := ph clause*

		if (and (list? ph-clause*)
			(3 eq (length ph-clause*))) {
			  ;; The {=>} operator is a bit of a
			  ;; Scheme-ism in that the clause says {(c =>
			  ;; f)} and means that if {c} is true then
			  ;; apply {f} to {c} and return the result of
			  ;; that.  Of course we need to stage the
			  ;; (result of the) evaluation of {c} in a
			  ;; temporary variable because we don't want
			  ;; it evaluated twice.

			  ;; There is an unhelpful indirection
			  ;; complication in that we are looking at
			  ;; {clause*} so this clause is {ph clause*}
			  ;; and then {c} and {f} are the {ph clause}
			  ;; (therefore {phh clause*}) and {phtt
			  ;; clause} (and therefore {phtth clause*})
			  ;; respectively.

			  ;; Finally, this clause is just one of many,
			  ;; so we need to keep rewriting all the
			  ;; remaining clause* ({pt clause*}).

			  gs := (gensym)

			  ;; `(let ((gs ,(phh clause*)))
			  ;;	(if gs
			  ;;	    (,(phtth clause*) gs)
			  ;;	    ,(rewrite-cond-clause* (pt clause*))))
			  pt-clause* := pt clause*

			  appl := list (phtth clause*) gs

			  c := (list 'let
				     (list (list gs (phh clause*)))
				     (list 'if
					   gs
					   appl
					   (meaning-rewrite-cond ph-clause*
								 (mpp pt-clause* src)
								 pt-clause*)))
			  meaning-copy-src-properties (mpp ph-clause* src) c
			  c
			} {
			  if (pair? src) {
			    ;; Test Cases:
			    ;; evaluation-errors/rewrite-cond-apply-two-args.idio
			    ;; evaluation-errors/rewrite-cond-apply-four-args.idio

			    ;; cond (1 =>)
			    ;; cond (1 => a b)
			    meaning-evaluation-error (ph src) "cond: invalid => clause" clause*
			  } {
			    ;; Test Case: ??
			    meaning-evaluation-error src "cond: invalid => clause" clause*
			  }
			}
	      })

	((null? (pth clause*)) {
	  gs := (gensym)
	  ;; `(let ((gs ,(phh clause*)))
	  ;;	   (or gs
	  ;;	       ,(rewrite-cond-clause* (pt clause*))))

	  ph-clause* := ph clause*
	  pt-clause* := pt clause*

	  c* := (list 'let
		      (list (list gs (phh clause*)))
		      (list 'or
			    gs
			    (meaning-rewrite-cond ph-clause*
						  (mpp pt-clause* src)
						  pt-clause*)))
	  meaning-copy-src-properties (mpp ph-clause* src) c*
	  c*
	})

	(else {
	  ph-clause* := ph clause*
	  pt-clause* := pt clause*

	  c := (list 'if
		     (phh clause* )
		     (append (list 'begin) (pth clause*))
		     (meaning-rewrite-cond ph-clause*
					   (mpp pt-clause* src)
					   pt-clause*))
	  meaning-copy-src-properties (mpp ph-clause* src) c
	  c
	}))
}

define (meaning-assignment src name e nametree escapes flags cs cm) {
  (cond
   ((pair? name) {
     ;; setter

     ;; append will deconstruct the (setter name) construct so we need
     ;; extra levels of list
     args := pt name

     setter := list 'setter (ph name)

     se := append (list setter) args (list e)

     meaning src se nametree escapes (clear-define flags) cs cm
   })
   ((symbol? name) {
     mflags := make-eval-flags #f (eval-flags-scope flags) #f

     if (and (pair? e)
	     (eq? (ph e) 'function)) {
	       docstr := #f
	       body := phtt e
	       if (and (string? body)
		       (pair? (pttt e))) {
			 body = phttt e
			 docstr = #t
		       }
	       body = append (list 'escape-block 'return) (list body)
	       body = append (list 'escape-block name) (list body)

	       if docstr {
		 set-ph! (pttt e) body
	       } {
		 set-ph! (ptt e) body
	       }
	     }

     m := meaning (mpp e src) e nametree escapes mflags cs cm

     si := meaning-variable-info src nametree name flags cs cm

     if (not si) {
       ; shouldn't get here as unknowns are automatically made toplevel
       meaning-error-static-unbound src name
     }

     scope := ph si
     ci := pht si

     ; without being able to return early we can presume that if
     ; someone has set the intermediate code {i-code} then they
     ; intended to return immediately
     i-code := #f

     ; otherwise set {assign} to the intermediate code for the
     ; assignment part and we'll also check the {define} flag for all
     ; three callers
     assign := #n

     (case scope
	   ((param local) {
	     vi := phtt si
	     if (0 eq ci) {
	       i-code = list I-SHALLOW-ARGUMENT-SET vi m
	     } {
	       i-code = list I-DEEP-ARGUMENT-SET ci vi m
	     }
	   })
	   ((toplevel) {
	     vi := phtt si
	     if (0 eq vi) {
	       assign = list I-GLOBAL-SYM-SET ci m
	     } {
	       assign = list I-GLOBAL-VAL-SET vi m
	     }
	   })
	   ((dynamic environ) {
	     assign = list I-GLOBAL-SYM-SET ci m
	   })
	   ((computed) {
	     if (eval-flags-define flags) {
	       i-code = (list (list I-GLOBAL-SYM-DEF name scope ci)
			      (list I-COMPUTED-SYM-DEF ci m))
	     } {
	       i-code = list I-COMPUTED-SYM-SET ci m
	     }
	   })
	   ((predef) {
	     new-ci := meaning-toplevel-extend src name (define-scope 'toplevel flags) cs cm

	     vi := phtt si
	     set-symbol-value! name (vm-values-ref vi) cm
	     assign = list I-GLOBAL-SYM-SET new-ci m
	     ci = new-ci
	   })
	   (else {
	     ;; Shouldn't get here unless the if clauses above don't
	     ;; cover everything.  Developer error?
	     meaning-error-static-unbound src name
	   }))

     (cond (i-code i-code)
	   ((eval-flags-define flags) {
	     (list (list I-GLOBAL-SYM-DEF name scope ci)
		   assign)
	   })
	   (else assign))
   })
   (else
    ;; Test Case: evaluation-errors/assign-non-symbol.idio

    ;; 1 = 3
    (meaning-evaluation-error src "cannot assign to" name)))
}

define (meaning-define src name e nametree escapes flags cs cm) {
  if (pair? name) {
    ;; (define (func arg) ...) => (define func (function (arg) ...))
    e = append (list 'function (pt name)) e
    name = ph name

    meaning-copy-src-properties src e
  } {
    if (pair? e) {
      e = ph e

      meaning-copy-src-properties src e
    }
  }

  define-flags := make-eval-flags (eval-flags-tailp flags) 'toplevel #t
  si := meaning-variable-info src nametree name define-flags cs cm

  ;; if the act of looking the variable up auto-created it then
  ;; actually give it a value slot as this *is* the definition of it
  scope :=  ph si
  vi := phtt si
  if (and (eq? 'toplevel scope)
	  (0 eq vi)) {
	    vi = (vm-extend-values)
	    si = list scope (pht si) vi cm "meaning-define/gvi=0"
	    set-symbol! name si cm
	  }

  meaning-assignment src name e nametree escapes define-flags cs cm
}

define (meaning-define-template src name e nametree escapes flags cs cm) {

  if (and (symbol? e)
	  (expander? e)) {
	    ;; In general (define-template a ...) means that "a" is
	    ;; associated with an expander and that expander takes the
	    ;; pt of the expression it is passed, "(a ...)" (ie. it
	    ;; skips over its own name).

	    ;; It happens that people (S9fES) say

	    ;; (define-template %b ...)
	    ;; (define-template b %b)

	    ;; (in particular where they are creating an enhanced
	    ;; version of b which may require using the existing b to
	    ;; define itself hence defining some other name, "%b",
	    ;; which can use "b" freely then redefine b to this new
	    ;; version)

	    ;; However, we can't just use the current value of "%b" in
	    ;; (define-template b %b) as this template-expander
	    ;; association means we are replacing the nominal
	    ;; definition of a template with an expander which takes
	    ;; two arguments and the body of which will take the pt of
	    ;; its first argument.  Left alone, expander "b" will take
	    ;; the pt then expander "%b" will take the pt....  "A
	    ;; Pair-Tail Too Far", one would say, in hindsight and
	    ;; thinking of the big budget movie potential.

	    ;; So catch the case where the value is already an
	    ;; expander and replace it with the (obvious?) assignment
	    ;; with some *expander-list* copying.

	    copy-expander! name e
	    meaning-assignment src name e nametree escapes (define-scope 'toplevel flags) cs cm
	  } {
	    ;; (define-template (name formal*) ...) => (define-template name (function (formal*) ...))
	    if (pair? name) {
	      e = (list 'function
			(pt name)
			e)
	      name = ph name

	      meaning-copy-src-properties src e
	    }

	    ;; create an expander: (function (x e) (apply proc (pt x)))

	    ;; where proc is (function (formal*) ...) from above,
	    ;; ie. e

	    docstr := sprintf "define-template: %s (x e)" name
	    expander := (list 'function
			      '(x e)
			      docstr
			      (list 'apply e '(pt x)))

	    meaning-copy-src-properties src expander

	    ;; XXX define-template bootstrap

	    ;; Option 1 (when I was dealing with file contents "all in
	    ;; one"):

	    ;; We really want the entry in *expander-list* to be some
	    ;; compiled code but we don't know what that code is yet
	    ;; because we have't processed the source code of the
	    ;; expander -- we only invented it a couple of lines above
	    ;; -- let alone compiled it!

	    ;; So, we'll drop the "source" code of the expander into
	    ;; *expander-list* and later, when someone calls expander?
	    ;; for this name we'll notice the value is a pair and do a
	    ;; symbol lookup for the closure that was created via
	    ;; meaning-assignment.

	    ;; Option 2 (noted at the time but not implemented):

	    ;; As an alternative we could evaluate the source to the expander
	    ;; now and install that code in *expander-list* directly -- but
	    ;; watch out for embedded calls to regular functions defined in
	    ;; the code (see comment above).

	    ;; In fact, because the evaluator changed to
	    ;; expression-by-expression we effectively implement
	    ;; Option 2 (which handles the regular function calls as
	    ;; well).

	    ;; Requirement either way:

	    ;; As a further twist, we really need to embed a call to
	    ;; install-expander in the *object* code too!  When
	    ;; someone in the future loads the object file containing
	    ;; this define-template who will have called
	    ;; install-expander?

	    ;; In summary: we need the expander in the here and now as
	    ;; someone might use it in the next line of source and we
	    ;; need to embed a call to install-expander in the object
	    ;; code for future users.

	    ;; this is a define at the toplevel and not tailp
	    ma := meaning-assignment expander name expander nametree escapes (make-eval-flags #f 'toplevel #t) cs cm

	    install-expander/source! name expander expander

	    ;; Generate a ci/vi for name

	    ;; The ci is required so that the EXPANDER opcode can call
	    ;; install-expander to overwrite the proc from the
	    ;; install-expander/source! call we just made

	    ;; The vi is because this is definitely a define
	    ci := codegen-constants-lookup-or-extend cs name
	    vi := (vm-extend-values)

	    set-symbol! name (list 'toplevel ci vi cm docstr) cm

	    list I-EXPANDER ci ma
	  }
}

define (meaning-define-infix-operator src name pri e nametree escapes flags cs cm) {
  if (pri lt 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol for {name} or create a new one
  ci := codegen-constants-lookup-or-extend cs name

  ;; XXX the plain use of operator gets a symbol in set-symbol! ??
  op-mod := find-module 'operator

  set-symbol! name (list 'toplevel ci 0 op-mod (sprintf "meaning-define-infix-operator %s" name)) op-mod

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-infix-operator X pri Y

    if (infix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *infix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve

      copy-infix-operator! name pri e
      m = meaning-assignment src name sve nametree escapes (define-scope 'toplevel flags) cs cm
    } {
      ;; Test Case: evaluation-errors/infix-op-not-an-operator.idio

      ;; define-infix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-infix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-infix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function
		'(op before after)
		(sprintf "infix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    m = meaning fe fe nametree escapes flags cs cm
  }

  list I-INFIX-OPERATOR ci pri m
}

define (meaning-define-postfix-operator src name pri e nametree escapes flags cs cm) {
  if (pri lt 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol for {name} or create a new one
  ci := codegen-constants-lookup-or-extend cs name

  ;; XXX the plain use of operator gets a symbol in set-symbol! ??
  op-mod := find-module 'operator

  set-symbol! name (list 'toplevel ci 0 op-mod (sprintf "meaning-define-postfix-operator %s" name)) op-mod

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-postfix-operator X pri Y

    if (postfix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *postfix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve

      copy-postfix-operator! name pri e
      m = meaning-assignment src name sve nametree escapes (define-scope 'toplevel flags) cs cm
    } {
      ;; Test Case: evaluation-errors/postfix-op-not-an-operator.idio

      ;; define-postfix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-postfix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-postfix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function
		'(op before after)
		(sprintf "postfix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    m = meaning fe fe nametree escapes flags cs cm
  }

  list I-POSTFIX-OPERATOR ci pri m
}

define (meaning-define-dynamic src name e nametree escapes flags cs cm) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree escapes (define-scope 'dynamic flags) cs cm
}

define (meaning-define-environ src name e nametree escapes flags cs cm) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree escapes (define-scope 'environ flags) cs cm
}

;; A computed variable's value should be a pair, (getter & setter).
;; Either of getter or setter can be #n.
;;
;; We shouldn't have both #n as it wouldn't be much use.

define (meaning-define-computed src name e nametree escapes flags cs cm) {
  getter := #n
  setter := #n

  if (pair? e) {
    he := ph e

    if (pair? he) {
      getter = ph he
      setter = pht he
    } {
      getter = he
    }
  } {
    ;; Not sure we can get here as {e} is either #n or a list
    meaning-evaluation-error src "define-computed: no getter/setter" e
  }

  if (and (null? getter)
	  (null? setter)) {
	    ;; Test Case: evaluation-errors/define-computed-no-args.idio

	    ;; C :$ #n
	    meaning-evaluation-error src "define-computed: no getter/setter" name
	  }

  #*

  There are no property lists associated with variables so we can't
  pull the same (set! (proc ...) v) => ((setter proc) ... v) trick as
  we can with procs.

  So, to set the actual getter/setter pair, as opposed to setting the
  variable (which is a call to the setter proc), we need a magic flag
  for meaning-assignment: IDIO_MEANING_FLAG_DEFINE.  Here, then, this
  is a re-definition rather than an assignment per se.

  *#

  meaning-assignment src name (list 'pair getter setter) nametree escapes (define-scope 'computed flags) cs cm
}

define (meaning*-single-sequence src e nametree escapes flags cs cm) {
  meaning (mpp e src) e nametree escapes flags cs cm
}

define (meaning*-multiple-sequence src e e+ nametree escapes flags keyword cs cm) {
  m := meaning (mpp e src) e nametree escapes (clear-tailp flags) cs cm
  m+ := meaning-sequence src e+ nametree escapes flags keyword cs cm

  (case keyword
	((and)		(list I-AND m m+))
	((or)		(list I-OR m m+))
	((begin)	(list I-BEGIN m m+))
	(else
	  ;; Shouldn't get here unless the clauses above don't cover
	  ;; everything.  Developer error?
	 (meaning-evaluation-error src "unexpected sequence keyword" keyword)))
}

define (meaning-sequence src e+ nametree escapes flags keyword cs cm) {
  if (pair? e+) {
    he+ := ph e+
    if (pair? (pt e+)) {
      meaning*-multiple-sequence src he+ (pt e+) nametree escapes flags keyword cs cm
    } {
      meaning*-single-sequence src he+ nametree escapes flags cs cm
    }
  } {
    ;; Shouldn't get here as the args were checked in meaning.
    ;; Developer error?
    meaning-evaluation-error keyword "sequence: not a pair" e+
  }
}

define (meaning-fix-abstraction src formal* arg-name* docstr e+ nametree escapes flags cs cm) {
  arity := length formal*
  nt+ := meaning-nametree-extend-params nametree formal*

  m+ := meaning-sequence src e+ nt+ escapes (set-tailp flags) 'begin cs cm

  list I-FIX-CLOSURE m+ arity (meaning-nametree->list nt+) docstr
}

define (meaning-dotted-abstraction src formal* vararg arg-name* docstr e+ nametree escapes flags cs cm) {
  arity := length formal*
  fix-formal* := append formal* (list vararg)

  nt+ := meaning-nametree-extend-vparams nametree fix-formal*

  m+ := meaning-sequence src e+ nt+ escapes (set-tailp flags) 'begin cs cm

  list I-NARY-CLOSURE m+ arity (meaning-nametree->list nt+) docstr
}

#*

With meaning-rewrite-body/meaning-rewrite-body-letrec we want to
massage the code to support some semantic trickery.

The two broad swathes are:

1. multiple function defines in (Scheme: at the start of) the body.

   {
     define (f) { ... }
     define (g) { ... }
     ...
   }

   Here, these two are expected to be self or mutually recursive
   (as well as being of local scope) and so the body is rewritten such
   that these are letrec definitions (and can safely be self/mutually
   recursive) and rest of the the body becomes the body of the letrec

   In Scheme these are only allowed at the start of the body whereas
   Idio allows them to appear anywhere in the body and when one
   appears we combine them with any immediately following.

2. new variable introductions

   a. := (let*)

      This is an extension of the letrec mechanism above so that the
      remaining body is transformed into a let* of the variable
      assignment.

      In fact, if we have an existing nametree then we can start using
      local variables in the existing frame.

   b. :* :~ !* !~

      These require a similar transform as the introduction of
      (potentially shadowing) environment/dynamic variables requires
      that their definitions be removed from the stack at the end of
      the body.

      Essentially the same as introducing environment/dynamic
      variables we can unset them which requires the same technique.

3. source properties

   If we're inventing code snippets then we should make some small
   effort to ensure that the source properties of the original code
   are propagated to our snippet.  This is especially important when
   several of these snippets invoke expanders -- which need to do much
   the same themselves!

---

meaning-rewrite-body is the main entry point and this will perform the
let* rewrites for := (and similar for dynamic/environ variables)

meaning-rewrite-body-letrec is called if we see an internal define/:+

*#

define (meaning-rewrite-body src e nametree) {
  loop :+ function (l r) {
	    cur := (cond
		    ((null? l) {
		      reverse r
		    })

		    ((and (pair? l)
			  (pair? (ph l))
			  (expander? (phh l))) {
			    template-expand* (ph l)
			  })

		    (else {
		      ph l
		    }))

	    if (pair? l) {
	      meaning-copy-src-properties (mpp (ph l) src) cur
	    }

	    (cond
	     ((null? l) {
	       cur
	     })

	     ((and (pair? cur)
		   (eq? 'begin (ph cur))) {
		     ;; redundant begin
		     loop (append (pt cur) (pt l)) r
		   })

	     ((and (pair? cur)
		   (or (eq? 'define (ph cur))
		       (eq? ':+ (ph cur)))) {
			 ;; :+ or define ==> letrec
			 reverse (pair (meaning-rewrite-body-letrec (mpp l src) l nametree) r)
		       })

	     ((and (pair? cur)
		   (eq? ':= (ph cur))) {
		     ;; := ==> let*

		     ;; we have ((:= name value-expr) ...)

		     ;; which we can rewrite as

		     ;; (let ((name value-expr))
		     ;;      (begin
		     ;;       ...
		     ;;       ))

		     ;; and recurse on ..., which is now the body of
		     ;; our (let)

		     binding := pt cur

		     assign := 'let
		     if (not (null? nametree)) {
		       assign = 'function+
		     }

		     body := meaning-rewrite-body (mpp cur src) (pt l) nametree

		     if (null? body) {
		       ;; what if value-expr has side-effects?
		       eprintf "mrb :=	OPT: empty body for let* => no eval of value-expr\n"
		       eprintf "src=%s\n" src
		       reverse r
		     } {

		       body-seq := append (list 'begin) body

		       r-cur := false

		       if (eq? 'let assign) {
			 r-cur = (list 'let
				       (list binding)
				       body-seq)
		       } {
			 r-cur = list assign (ph binding) (pht binding) body-seq
		       }

		       meaning-copy-src-properties (mpp cur src) r-cur

		       r = append (list r-cur) r
		       reverse r
		     }
		   })

	     ((and (pair? cur)
		   (or (eq? ':* (ph cur))
		       (eq? '!* (ph cur))
		       (eq? ':~ (ph cur))
		       (eq? '!~ (ph cur)))) {

			 op := (case ((':*) 'environ-let)
				     (('!*) 'environ-unset)
				     ((':~) 'dynamic-let)
				     (('!~) 'dynamic-unset)
				     (else (meaning-error-param src "bad operator" cur)))

			 body := meaning-rewrite-body (mpp cur src) (pt l) nametree

			 if (null? body) {
			   ;; what if value-expr has side-effects?
			   eprintf "mrb :=	OPT: empty body for %s => no eval of value-expr\n" op
			   eprintf "src=%s\n" src
			   reverse r
			 } {

			   body-seq := append (list 'begin) body

			   binding := pt cur
			   value-expr := pht binding

			   r-cur := (list op
					  binding
					  body-seq)

			   meaning-copy-src-properties (mpp cur src) r-cur

			   append (reverse r) (list r-cur)
			 }
		       })

	     ((and (pair? cur)
		   (eq? 'define-template (ph cur))) {

		     meaning-error-param src "internal define-template" cur
		   })

	     (else {
	       loop (pt l) (pair cur r)
	     }))
  }

  loop e #n
}

#*

meaning-rewrite-body-letrec is slightly more sophisticated than
meaning-rewrite-body in that it needs to accumulate
consecutive "define"s to produce the letrec statement.

The algorithm was inspired by rewrite-body in STklos
.../lib/compiler.stk

*#

define (meaning-rewrite-body-letrec src e nametree) {
  loop :+ function (l defs r) {
	    cur := (cond
		    ((null? l) {
		      #*

		      Test Case: evaluation-errors/letrec-empty-body.idio

		      {
		        bar :+ "foo"

		      }

		      NB The point is that there is nothing else in
		      the block after the creation of {bar}, so there
		      is no "body" for the (generated) letrec of
		      {bar}.

		      Regardless of whether {bar} is a (faintly)
		      pointless sort of letrec, notably not involving
		      a function.

		      There's an argument that it could be optimised
		      away (if the value-expression has no
		      side-effects, etc.).

		      *#
		      meaning-evaluation-error src "letrec: empty body" l
		    })

		    ((and (pair? l)
			  (pair? (ph l))
			  (expander? (phh l))) {
			    te := template-expand* (ph l)
			    te
			  })

		    (else {
		      ph l
		    }))

	    if (pair? l) {
	      meaning-copy-src-properties (mpp (ph l) src) cur
	    }

	    (cond
	     ((null? l) {
	       reverse r
	     })

	     ((and (pair? cur)
		   (eq? 'begin (ph cur))) {
		     ;; redundant begin
		     loop (append (pt cur) (pt l)) defs r
		   })

	     ((and (pair? cur)
		   (or (eq? 'define (ph cur))
		       (eq? ':+ (ph cur)))) {
			 ;; cur	~ (define (name formal*) ...)
			 ;; cur	~ (:+ name value-expr)

			 bindings := pht cur
			 form := #f

			 if (pair? bindings) {
			   ;; cur	~ (define (name formal*) ...)

			   ;; form	~ (name (function (formal*)) ...)

			   fn := (append (list 'function
					       (pt bindings)
					       (sprintf "rewrite body letrec: %s" bindings))
				  (ptt cur))

			   form = list (ph bindings) fn
			 } {
			   ;; cur	~ (:+ name value-expr)

			   ;; form	~ (name value-expr)
			   form = pt cur
			 }
			 meaning-copy-src-properties (mpp cur src) form

			 loop (pt l) (pair form defs) r
		       })

	     ((and (pair? cur)
		   (eq? 'define-template (ph cur))) {

		     ;; Test Case: (nominally) evaluation-errors/letrec-internal-define-template.idio

		     ;; bar :+ define-template (baz) { #T{ 1 } }

		     ;; XXX I can't get this to trigger the error
		     meaning-error-param src "internal define-template" cur
		   })

	     (else {
	       ;; body proper

	       cur-props := mpp cur src
	       l = meaning-rewrite-body cur-props l nametree

	       ;; if no defs just return l
	       if (null? defs) l {
		 #*

		 poor man's letrec*

		 We are aiming for:

		 {
		   v1 :+ a1
		   v2 :+ a2
		   body
		 }

		 to become

		 (let ((v1 #f)
		       (v2 #f))
		   (set! v1 a1)
		   (set1 v2 a2)
		   body)

		 but we return it as a list of one, ((let ... body)),
		 so that idio_meaning_sequence will re-read the first
		 element in the list and interpret it as the
		 expander "let"

		 NB Leave defs reversed as creating the
		 bindings/assignments will implicitly re-order them

		 *#

		 bindings := #n
		 for-each (function (formal) {
			     bindings = pair (list formal #f) bindings
		 }) (map ph defs)

		 #*

		 Remember {defs} is the list of tuples

		 ((v1 a1) (v2 a2))

		 so that (ph vs) is (v1 a1) and therefore

		 (append (set!) (v1 a1))

		 gives us the desired

		 (set! v1 a1)

		 and that as we walk down {vs} we'll get a (reversed)
		 list of assignments in {body}

		 ((set! v2 a2)
		  (set! v1 a1))

		 *#

		 body := #n
		 for-each (function (def) {
			     assign := append (list 'set!) def
			     body = append (list assign) body
		 }) defs
		 body = append body l

		 stmt := append (list 'let bindings) body
		 meaning-copy-src-properties cur-props stmt

		 stmt
	       }
	     }))
  }

  loop e #n #n
}

define (meaning-abstraction src formal* docstr e+ nametree escapes flags cs cm) {
  e+ := meaning-rewrite-body (mpp e+ src) e+ nametree
  meaning-copy-src-properties src e+

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction
  formals-loop :+ function (f* regular) {
		    (cond
		     ((pair? f*) (formals-loop (pt f*) (pair (ph f*) regular)))
		     ((null? f*) (meaning-fix-abstraction src formal* formal* docstr e+ nametree escapes flags cs cm))
		     (else (meaning-dotted-abstraction src (reverse regular) f* formal* docstr e+ nametree escapes flags cs cm)))
  }

  formals-loop formal* #n
}

define (meaning-block src e* nametree escapes flags cs cm) {
  e* = meaning-rewrite-body (mpp e* src) e* nametree
  meaning-copy-src-properties src e*

  meaning-sequence (mpp e* src) e* nametree escapes flags 'begin cs cm
}

define (meaning-some-arguments src ae ae* nametree escapes arity flags cs cm) {
  am := meaning (mpp ae src) ae nametree escapes (clear-tailp flags) cs cm
  am* := meaning-arguments src ae* nametree escapes arity flags cs cm

  rank := arity - ((length ae*) + 1)

  list I-STORE-ARGUMENT am am* rank
}

define (meaning-no-argument src nametree escapes arity flags cs) {
  list I-ALLOCATE-FRAME arity
}

define (meaning-arguments src ae* nametree escapes arity flags cs cm) {
  if (pair? ae*) {
    meaning-some-arguments src (ph ae*) (pt ae*) nametree escapes arity flags cs cm
  } {
    meaning-no-argument src nametree escapes arity flags cs
  }
}

define (meaning-fix-closed-application src formal* body ae* nametree escapes flags cs cm) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am* := meaning-arguments src ae* nametree escapes (length ae*) (clear-tailp flags) cs cm
  nt+ := meaning-nametree-extend-params nametree formal*

  mbody := meaning-sequence (mpp body src) body nt+ escapes flags 'begin cs cm

  if (eval-flags-tailp flags) {
    list I-TR-FIX-LET am* mbody (meaning-nametree->list nt+)
  } {
    list I-FIX-LET am* mbody (meaning-nametree->list nt+)
  }
}

define (meaning-some-dotted-arguments src ae ae* nametree escapes nargs arity flags cs cm) {
  am := meaning (mpp ae src) ae nametree escapes (clear-tailp flags) cs cm
  am* := meaning-dotted-arguments src ae* nametree escapes nargs arity flags cs cm
  rank := nargs - ((length ae*) + 1)

  if (rank lt arity) {
    list I-STORE-ARGUMENT am am* rank
  } {
    list I-LIST-ARGUMENT am am* arity
  }
}

define (meaning-no-dotted-argument src nametree escapes nargs arity flags cs) {
  list I-ALLOCATE-FRAME arity
}

define (meaning-dotted-arguments src ae* nametree escapes nargs arity flags cs cm) {
  if (pair? ae*) {
    meaning-some-dotted-arguments src (ph ae*) (pt ae*) nametree escapes nargs arity flags cs cm
  } {
    meaning-no-dotted-argument src nametree escapes nargs arity flags cs
  }
}

define (meaning-dotted-closed-application src formal* vararg body ae* nametree escapes flags cs cm) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am* := meaning-dotted-arguments src ae* nametree escapes (length ae*) (length formal*) (clear-tailp flags) cs cm

  fix-formal* := append formal* (list vararg)
  nt+ := meaning-nametree-extend-vparams nametree fix-formal*

  mbody := meaning-sequence (mpp body src) body nt+ escapes flags 'begin cs cm

  if (eval-flags-tailp flags) {
    list I-TR-FIX-LET am* mbody (meaning-nametree->list nt+)
  } {
    list I-FIX-LET am* mbody (meaning-nametree->list nt+)
  }
}

define (meaning-closed-application src fe ae* nametree escapes flags cs cm) {
  ;; ((function ...) args)
  ;;
  ;; fe		~ (function ...)
  ;; (ph fe)	~ 'function
  ;; (pt fe)	~ ...		~ (formals* body)
  ;; (pht fe)	~ formals*
  ;; (ptt fe)	~ (body)

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction

  ;; unlike meaning-abstraction above, we need to check the arguments
  ;; being supplied at the same time

  formal* := pht fe

  formals-loop :+ function (f* a* fixed-args) {
		    (cond
		     ((pair? f*) {
		       if (pair? a*) {
			 formals-loop (pt f*) (pt a*) (pair (ph f*) fixed-args)
		       } {
			 ;; Test Cases:
			 ;; evaluation-errors/closed-function-not-enough-args-{0,1}.idio

			 ;; ((function (x) x) )
			 ;; (function (x y) x) 1

			 ;; XXX Note that in the first case we must
			 ;; wrap the putative ``func-defn args`` in
			 ;; parens otherwise we're simply writing
			 ;; ``func-defn`` which defines and
			 ;; immediately throws away the function.

			 ;; In the second case the system can see
			 ;; there's an arg!
			 meaning-evaluation-error src "closed application: not enough arguments" (list formal* ae*)
		       }
		     })
		     ((null? f*) {
		       if (null? a*) {
			 meaning-nametree-extend-locals nametree formal*
			 meaning-fix-closed-application fe formal* (ptt fe) ae* nametree escapes flags cs cm
		       } {
			 ;; Test Cases:
			 ;; evaluation-errors/closed-function-too-many-args-{0,1}.idio

			 ;; (function () 1) 2
			 ;; (function (x) x) 1 2
			 meaning-evaluation-error src "closed application: too many arguments" (list formal* ae*)
		       }
		     })
		     (else (meaning-dotted-closed-application fe (reverse fixed-args) f* (ptt fe) ae* nametree escapes flags cs cm)))
  }

  formals-loop formal* ae* #n
}

define (meaning-local-application src n ae body nametree escapes flags cs cm) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am := meaning (mpp ae src) ae nametree escapes (clear-tailp flags) cs cm

  nt+ := meaning-nametree-extend-locals nametree (list n)

  mbody := meaning-sequence (mpp body src) body nt+ escapes flags 'begin cs cm

  ll := meaning-lexical-lookup src nt+ n

  list I-LOCAL (phtt ll) am mbody (meaning-nametree->list nt+)
}

#*

We used to follow LiSP and specialise PRIMCALLn with PRIMCALLn_X but
in practice we should just call the primitives and save a run around
with frames etc.

One thing we need to be leery of is ensuring that we set the *func*
register -- which would have been done by the full function call
protocol.

The problem here is incredibly subtle.  We had relied on the *func*
register being reset with every (true) function call which meant that
after a continuation had been called then the continuation's value
would have been flushed away by the next function call.

If we don't do that with primitive calls then we can leave a
continuation lying around in *func* which means it won't get GC'd and
in turn the values in that continuation's embedded stack won't get
GC'd.

It just so happens that our "use all the file descriptors" test will
have had the array of file descriptors on the stack of the wrappering
continuation (via the saved *frame*?).  If we don't flush the
continuation from *func* then the array of fds won't get flushed and
we won't get to use any more file descriptors.  Not ideal.

Need to figure out run-in-thread too...

*#

define (meaning-primitive-application src fe ae* nametree escapes flags arity vi cs cm) {
  primdata := vm-values-ref vi

  if (primitive-varargs? primdata) {
    ;; only a full function call protocol can cope with varargs!
    meaning-regular-application src fe ae* nametree escapes flags cs cm
  } {
    name := primitive-name primdata

    i-code := #f

    (case arity
	  ((0) {
	    i-code = list I-PRIMCALL0 A-PRIMCALL0 vi
	  })
	  ((1) {
	    m1 := meaning (mpp (ph ae*) src) (ph ae*) nametree escapes (clear-tailp flags) cs cm

	    i-code = list I-PRIMCALL1 A-PRIMCALL1 m1 vi
	  })
	  ((2) {
	    m1 := meaning (mpp (ph ae*) src) (ph ae*) nametree escapes (clear-tailp flags) cs cm
	    m2 := meaning (mpp (pht ae*) src) (pht ae*) nametree escapes (clear-tailp flags) cs cm

	    ;; XXX run-in-thread?
	    i-code = list I-PRIMCALL2 A-PRIMCALL2 m1 m2 vi
	  }))

    if i-code i-code {
      meaning-regular-application src fe ae* nametree escapes flags cs cm
    }
  }
}

define (meaning-regular-application src fe ae* nametree escapes flags cs cm) {
  fm := #n
  if (symbol? fe) {
    fm = meaning-function-reference src fe nametree escapes flags cs cm
  } {
    fm = meaning fe fe nametree escapes (clear-tailp flags) cs cm
  }

  am* := meaning-arguments src ae* nametree escapes (length ae*) (clear-tailp flags) cs cm

  if (eval-flags-tailp flags) {
    list I-TR-REGULAR-CALL src fm am*
  } {
    list I-REGULAR-CALL src fm am*
  }
}

define (meaning-application src fe ae* nametree escapes flags cs cm) {
  i-code := #f

  ;; check for a primitive
  if (symbol? fe) {
    si := meaning-variable-info src nametree fe (set-scope 'toplevel flags) cs cm

    if (pair? si) {
      scope := ph si

      if (eq? 'predef scope) {
	primdata := vm-values-ref (phtt si)

	if (primitive? primdata) {
	  arity := primitive-arity primdata
	  n-args := length ae*

	  if (or (and (primitive-varargs? primdata)
		      (n-args ge arity))
	      (n-args eq arity)) {
		i-code = meaning-primitive-application src fe ae* nametree escapes flags arity (phtt si) cs cm
	      } {
		;; Test Case: evaluation-errors/primitive-arity.idio

		;; pair 1
		meaning-evaluation-error src "wrong arity for primitive" (list fe ae*)
	      }
	} {
	  ;; Can we get here?  We'd need to be a predef but those are
	  ;; all, uh, primitives.  Developer error?
	  meaning-evaluation-error src "BAD application: not a primitive" fe
	}
      }
    }
  }

  if i-code i-code {
    ;; check for a closed application
    if (and (pair? fe)
	    (eq? 'function (ph fe))) {
	      ;; check for a documentation string and forge one to
	      ;; help debugging
	      if (not (string? (phtt fe))) {
		fe = append (list (ph fe) (pht fe) (sprintf "closed application: %s" (pht fe))) (ptt fe)
	      }
	      meaning-copy-src-properties src fe

	      meaning-closed-application src fe ae* nametree escapes flags cs cm
	    } {
	      meaning-regular-application src fe ae* nametree escapes flags cs cm
	    }
  }
}

define (meaning-dynamic-reference src name nametree escapes flags cs cm) {
  meaning-reference src name nametree escapes (set-scope 'dynamic flags) cs cm
}

define (meaning-dynamic-let src name e e+ nametree escapes flags cs cm) {
  m := meaning (mpp e src) e nametree escapes (clear-tailp flags) cs cm

  si := find-symbol name cm

  ci := #f

  if si {
    ci = pht si
  } {
    ci = meaning-toplevel-extend src name (set-scope 'dynamic flags) cs cm
  }

  nt+ := meaning-nametree-dynamic-extend nametree name ci 'dynamic

  m+ := meaning-sequence src e+ nt+ escapes (clear-tailp flags) 'begin cs cm

  dynamic-wrap := (list (list I-PUSH-DYNAMIC ci m)
			m+
			(list I-POP-DYNAMIC))

  (list (list I-GLOBAL-SYM-DEF name 'dynamic ci)
	dynamic-wrap)
}

define (meaning-dynamic-unset src name e+ nametree escapes flags cs cm) {
  meaning-dynamic-let src name 'undef e+ nametree escapes flags cs cm
}

define (meaning-environ-reference src name nametree escapes flags cs cm) {
  meaning-reference src name nametree escapes (set-scope 'environ flags) cs cm
}

define (meaning-environ-let src name e e+ nametree escapes flags cs cm) {
  m := meaning (mpp e src) e nametree escapes (clear-tailp flags) cs cm

  si := find-symbol name cm

  ci := #f

  if si {
    ci = pht si
  } {
    ci = meaning-toplevel-extend src name (set-scope 'environ flags) cs cm
  }

  nt+ := meaning-nametree-dynamic-extend nametree name ci 'environ

  m+ := meaning-sequence src e+ nt+ escapes (clear-tailp flags) 'begin cs cm

  environ-wrap := (list (list I-PUSH-ENVIRON ci m)
			m+
			(list I-POP-ENVIRON))

  (list (list I-GLOBAL-SYM-DEF name 'environ ci)
	environ-wrap)
}

define (meaning-environ-unset src name e+ nametree escapes flags cs cm) {
  meaning-environ-let src name 'undef e+ nametree escapes flags cs cm
}

define (meaning-computed-reference src name nametree escapes flags cs cm) {
  meaning-reference src name nametree escapes (set-scope 'computed flags) cs cm
}

define (meaning-trap src ce he be nametree escapes flags cs cm) {
  he = meaning-rewrite-body (mpp he src) he nametree
  meaning-copy-src-properties src he

  hm := meaning (mpp he src) he nametree escapes (clear-tailp flags) cs cm

  ;; if the condition expression is not a list then make it one
  if (not (pair? ce)) {
    ce = list ce
  }

  ;; For each condition, resolve/discover the condition's name then
  ;; build pushs with the fci.

  ;; pushs is now the the reverse order of ce

  pushs := #n
  pops := #n

  c-loop :+ function (c*) {
	      if (null? c*) #n {
		c-sym := ph c*

		ci := #f

		si := find-symbol c-sym cm
		if (pair? si) {
		  ci = pht si
		} {
		  eprintf "meaning-trap: condition name unknown: '%s'\n" c-sym
		  ci = meaning-toplevel-extend src c-sym (set-scope 'toplevel flags) cs cm
		}

		pushs = pair (list I-PUSH-TRAP ci) pushs
		pops = pair (list I-POP-TRAP) pops

		c-loop (pt c*)
	      }
  }

  c-loop ce

  be = meaning-rewrite-body (mpp be src) be nametree
  meaning-copy-src-properties src be

  bm := meaning-sequence (mpp be src) be nametree escapes (clear-tailp flags) 'begin cs cm

  append (list hm) pushs (list bm) pops
}

define (meaning-escape-block src label be nametree escapes flags cs cm) {
  ci := codegen-constants-lookup-or-extend cs label

  be = meaning-rewrite-body (mpp be src) be nametree
  meaning-copy-src-properties src be

  ee := pair label escapes

  bm := meaning-sequence (mpp be src) be nametree ee (clear-tailp flags) 'begin cs cm

  (list (list I-PUSH-ESCAPER ci bm)
	(list I-POP-ESCAPER))
}

define (meaning-escape-from src label ve nametree escapes flags cs cm) {
  if (not (memq label escapes)) {
    meaning-error-static-unbound src label
  }

  ci := codegen-constants-lookup-or-extend cs label

  vm := meaning (mpp ve src) ve nametree escapes (clear-tailp flags) cs cm

  list I-ESCAPER-LABEL-REF ci vm
}

define (meaning-escape-label src label ve nametree escapes flags cs cm) {
  if (not (memq label escapes)) {
    meaning-error-static-unbound src label
  }

  ci := codegen-constants-lookup-or-extend cs label

  if (pair? ve) {
    ve = ph ve
  } {
    ve = (void)
  }

  vm := meaning (mpp ve src) ve nametree escapes (clear-tailp flags) cs cm

  list I-ESCAPER-LABEL-REF ci vm
}

define (evaluate-include-file fh cs) {
  c := *primitives*/read fh
  if (not (eof? fh)) {
    m := evaluate c
    pc := codegen (current-thread) m cs
    r := vm-run (current-thread) pc
    evaluate-include-file fh cs
  }
}

define (meaning-include src e nametree escapes flags cs cm) {
  fh := open-input-file (find-lib e)
  unwind-protect {
    evaluate-include-file fh cs
  } {
    close-handle fh
  }
}

define (meaning-expander src e nametree escapes flags cs cm) {
  te := expander/template-expand e
  meaning-copy-src-properties src te

  meaning te te nametree escapes flags cs cm
}

define (meaning src e nametree escapes flags cs cm) {
  if (pair? e) {
    he := ph e
    te := pt e

    (case he
	  ((begin \and \or) {
	    if (pair? te) {
	      meaning-sequence src te nametree escapes flags he cs cm
	    } {
	      (case he
		    ((begin) (meaning src (void) nametree escapes flags cs cm))
		    ((and) (meaning src #t nametree escapes flags cs cm))
		    ((or) (meaning src #f nametree escapes flags cs cm))
		    (else
		     ;; can we even get here?
		     (meaning-evaluation-error src "unexpected sequence keyword" he)))
	    }
	  })

	  ((escape) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/escape-multiple-args.idio

		;; (escape 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-escape src (ph te) nametree escapes flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/escape-nil.idio

	      ;; (escape)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((quote) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/quote-multiple-args.idio

		;; (quote 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-quotation src (ph te) nametree escapes flags
	      }
	    } {
	      ;; Test Case: evaluation-errors/quote-nil.idio

	      ;; (quote)

	      ;; XXX is (quote) actually '#n ??
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((quasiquote) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/quasiquote-multiple-args.idio

		;; (quasiquote 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-quasiquotation src (ph te) nametree escapes flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/quasiquote-nil.idio

	      ;; (quasiquote)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((function) {
	    ;; (function bindings [docstr] body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		htte := ph tte
		ttte := pt tte
		if (and (string? htte)
			(not (null? ttte))) {
			  ;; (function bindings "docstr" body ...)
			  meaning-abstraction src (ph te) htte ttte nametree escapes flags cs cm
			} {
			  ;; (function bindings body ...)
			  ;; (function bindings "...")

			  ;; The second is a function whose body is a
			  ;; string

			  meaning-abstraction src (ph te) #n tte nametree escapes flags cs cm
			}
	      } {
		;; (function bindings body ...)
		meaning-abstraction src (ph te) #n tte nametree escapes flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/function-nil.idio

	      ;; (function)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((function+) {
	    ;; (function+ var val body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  ;; (function+ var val body ...)
		  meaning-local-application src (ph te) (ph tte) ttte nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/function+-no-body.idio
		  
		  ;; (function+ var val)
		  meaning-error-param src "no body" he
		}
	      } {
		  ;; Test Case: evaluation-errors/function+-no-val.idio
		  
		;; (function+ var)
		meaning-error-param src "no value" he
	      }
	    } {
	      ;; Test Case: evaluation-errors/function+-nil.idio

	      ;; (function+)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((if) {
	    ;; (if condition consequent alternative)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		httte := (void)		; default: (if #f e) -> #void
		if (pair? ttte) {
		  httte = ph ttte
		}
		meaning-alternative src (ph te) (ph tte) httte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/if-cond-nil.idio

		;; (if 1)
		meaning-error-param src "no consequent/alternative" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/if-nil.idio

	      ;; (if)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((cond) {
	    ;; (cond clause ...)
	    if (pair? te) {
	      ;; What was I thinking here...
	      if (null? (pt te)) {
		hte := ph te
		if (and (pair? hte)
			(eq? 'block (ph hte))) {
			  ;; (cond )
			  te = pt hte
			}
	      }

	      ce := meaning-rewrite-cond e (mpp te src) te nametree
	      meaning-copy-src-properties src ce

	      meaning ce ce nametree escapes flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/cond-nil.idio

	      ;; (cond)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((set! \=) {
	    ;; (set! var expr)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-assignment src (ph te) (ph tte) nametree escapes (set-scope 'toplevel flags) cs cm
	      } {
		;; Test Case: evaluation-errors/set-symbol-nil.idio

		;; (set! x )
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/set-nil.idio

	      ;; (set!)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-template) {
	    ;; (define-template bindings body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-template src (ph te) (ph tte) nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/define-template-bindings-nil.idio

		;; define-template (m)
		meaning-error-param src "no body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-template-nil.idio

	      ;; (define-template)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-infix-operator) {
	    ;; (define-infix-operator sym pri body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-define-infix-operator src (ph te) (ph tte) (ph ttte) nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/define-infix-op-symbol-pri-nil.idio

		  ;; define-infix-operator sym pri
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/define-infix-op-symbol-nil.idio

		;; define-infix-operator sym
		meaning-error-param src "no pri body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-infix-op-nil.idio

	      ;; (define-infix-operator)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-postfix-operator) {
	    ;; (define-postfix-operator sym pri body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-define-postfix-operator src (ph te) (ph tte) (ph ttte) nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/define-postfix-op-symbol-pri-nil.idio

		  ;; define-postfix-operator sym pri
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/define-postfix-op-symbol-nil.idio

		;; define-postfix-operator sym
		meaning-error-param src "no pri body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-postfix-op-nil.idio

	      ;; (define-postfix-operator)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define) {
	    ;; (define var expr)
	    ;; (define bindings body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/define-sym-nil.idio

		;; define sym
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-nil.idio

	      ;; (define)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:=) {
	    ;; (:= var expr)
	    ;; (:= bindings body ...)

	    ;; (:= vars expr)	;; ?? cf. let-values (call-with-values producer consumer)

	    ;; in the short term => define
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/toplevel-define-sym-nil.idio

		;; := sym

		;; XXX can't do ``sym :=`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/toplevel-define-nil.idio

	      ;; (:=)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:*) {
	    ;; (:* var expr)

	    ;; in the short term => define-environ
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-environ src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/environ-define-sym-nil.idio

		;; :* sym

		;; XXX can't do ``sym :*`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-define-nil.idio

	      ;; (:*)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:~) {
	    ;; (:~ var expr)

	    ;; in the short term => define-dynamic
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-dynamic src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/dynamic-define-sym-nil.idio

		;; :~ sym

		;; XXX can't do ``sym :~`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-define-nil.idio

	      ;; (:~)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:$) {
	    ;; (:$ var getter setter)
	    ;; (:$ var getter)

	    ;; in the short term => define-computed
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-computed src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/computed-define-sym-nil.idio

		;; :$ sym

		;; XXX can't do ``sym :$`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no getter [setter]" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/computed-define-nil.idio

	      ;; (:$)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((block) {
	    ;; { ... }
	    if (pair? te) {
	      meaning-block src te nametree escapes flags cs cm
	    } {
	      eprintf "empty body for block => void\n"
	      meaning src (void) nametree escapes flags cs cm
	    }
	  })

	  ((dynamic) {
	    ;; (dynamic var)
	    if (pair? te) {
	      meaning-dynamic-reference src (ph te) nametree escapes flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/dynamic-nil.idio

	      ;; (dynamic)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((dynamic-let) {
	    ;; (dynamic-let (var expr) body)
	    if (pair? te) {
	      hte := ph te
	      if (pair? hte) {
		thte := pt hte
		if (pair? thte) {
		  meaning-dynamic-let src (ph hte) (ph thte) (pt te) nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/dynamic-let-bindings-not-tuple.idio

		  ;; dynamic-let (d)
		  meaning-error-param src "bindings not a tuple" e
		}
	      } {
		;; Test Case: evaluation-errors/dynamic-let-bindings-not-pair.idio

		;; dynamic-let #n
		meaning-error-param src "bindings not a pair" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-let-nil.idio

	      ;; (dynamic-let)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((dynamic-unset) {
	    ;; (dynamic-unset var body)
	    if (pair? te) {
	      hte := ph te
	      if (symbol? hte) {
		meaning-dynamic-unset src hte (pt te) nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/dynamic-unset-non-sym.idio

		;; dynamic-unset 1
		meaning-error-param src "not a symbol" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-unset-nil.idio

	      ;; (dynamic-unset)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((environ-let) {
	    ;; (environ-let (var expr) body)
	    if (pair? te) {
	      hte := ph te
	      if (pair? hte) {
		thte := pt hte
		if (pair? thte) {
		  meaning-environ-let src (ph hte) (ph thte) (pt te) nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/environ-let-bindings-not-tuple.idio

		  ;; environ-let (d)
		  meaning-error-param src "bindings not a tuple" e
		}
	      } {
		;; Test Case: evaluation-errors/environ-let-bindings-not-pair.idio

		;; environ-let #n
		meaning-error-param src "bindings not a pair" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-let-nil.idio

	      ;; (environ-let)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((environ-unset) {
	    ;; (environ-unset var body)
	    if (pair? te) {
	      hte := ph te
	      if (symbol? hte) {
		meaning-environ-unset src hte (pt te) nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/environ-unset-non-sym.idio

		;; environ-unset 1
		meaning-error-param src "not a symbol" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-unset-nil.idio

	      ;; (environ-unset)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((trap) {
	    ;; (trap condition		handler body ...)
	    ;; (trap (condition ...)	handler body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-trap src (ph te) (ph tte) ttte nametree escapes flags cs cm
		} {
		  ;; Test Case: evaluation-errors/trap-condition-handler-nil.idio

		  ;; trap condition handler
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/trap-condition-nil.idio

		;; trap condition
		meaning-error-param src "no handler" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/trap-nil.idio

	      ;; (trap)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((escape-block) {
	    ;; (escape-block label body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-escape-block src (ph te) tte nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/escape-block-condition-nil.idio

		;; escape-block label
		meaning-error-param src "no body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/escape-block-nil.idio

	      ;; (escape-block)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((escape-from) {
	    ;; (escape-from label val)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-escape-from src (ph te) (ph tte) nametree escapes flags cs cm
	      } {
		;; Test Case: evaluation-errors/escape-from-condition-nil.idio

		;; escape-from condition
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/escape-from-nil.idio

	      ;; (escape-from)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((include) {
	    ;; (include filename)
	    if (pair? te) {
	      meaning-include src (ph te) nametree escapes flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/include-nil.idio

	      ;; (include)
	      meaning-error-param src "no argument" he
	    }
	  })

	  (else {
	    ;; not a special form

	    ;; check if {he} is a symbol and if so, if it has been
	    ;; flagged as an expander

	    ;; otherwise it is a derived form, ie. an application
	    if (symbol? he) {
	      si := meaning-variable-info src nametree he (set-scope 'toplevel flags) cs cm

	      if (and si
		      (expander? he)) {
			meaning-expander src e nametree escapes flags cs cm
		      } {
			meaning-application src he te nametree escapes flags cs cm
		      }
	    } {
	      meaning-application src he te nametree escapes flags cs cm
	    }
	  }))
  } {
    ;; {e} is not a pair so is mostly a constant unless it is a symbol
    ;; in which case (de-)reference it
    (cond ((or (fixnum? e)
	       (boolean? e)
	       (null? e)
	       (string? e)
	       (unicode? e)
	       (keyword? e)
	       (array? e)
	       (hash? e)
	       (bignum? e)
	       (bignum? e)
	       (struct-instance? e)
	       (void? e))
	    (meaning-quotation src e nametree escapes flags))
     ((symbol? e) {
       (case e
	     ((return break continue) {
	       meaning-escape-from src e (void) nametree escapes flags cs cm
	     })
	     (else {
	       meaning-reference src e nametree escapes (set-scope 'toplevel flags) cs cm
	     }))
     })
     (else
      ;; anything else is something the user shouldn't be dealing
      ;; with!
      idio-dump e
      eprintf "unexpected expression: %s\n" e
      eprintf "\n\n"
      libc/sleep 10
      (meaning-error-param src "invalid constant type" e)))
  }
}

define (evaluate src & constants) {
  c* := #n
  if (pair? constants) {
    c* = ph constants
  } {
    c* = (vm-constants)
  }
  m := meaning src src #n #n no-flags c* (current-module)

  list I-ABORT m
}

;; done
provide evaluate
