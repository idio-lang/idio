#*

Copyright (c) 2020-2022 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

evaluate.idio

*#

module evaluate
export (
	 evaluate
	 si-si
	 si-ci
)
import read expander operator codegen threading vm

;; symbol-info is a tuple: (scope xi si ci vi module description)
define (si-scope si)                 (ph si)
define (si-xi si)                    (pht si)
define (si-si si)                    (nth si 2)
define (si-ci si)                    (nth si 3)
define (si-vi si)                    (nth si 4)
define (set-si-vi! si vi)            (set! si.4 vi)
define (si-module si)                (nth si 5)
define (si-description si)           (nth si 6)
define (set-si-description! si desc) (set! si.6 desc)

define (nt-param-i si)     (pht si)
define (nt-param-j si)     (phtt si)

(export-struct-accessors-only %eenv
			      desc
			      file	; of the source (not any compiled variant)
			      aot?
			      chksum
			      symbols	; alist of (symbol symbol-info)
			      operators	; alist of (operator-symbol symbol-info)
			      predefs   ; alist of (si symbol module-name)
			      ph        ; hash of si to (si symbol module-name)
			      st	; symbol table for VM
			      cs	; constants table for VM
			      ch	; constants hash for VM
			      vt	; value table for VM
			      module
			      escapes
			      ses	; source expressions for VM
			      sps	; source properties for VM
			      byte-code	; for VM
			      pcs	; list of initial PCs
			      xi	; set when imported as xenv
)

define (eenv-as-string eenv seen) {
  if (%eenv? eenv) {
    r := (open-output-string)
    hprintf r "#<SI %%eenv %s [%s] " (%eenv-desc eenv) (%eenv-file eenv)

    hprintf r "st #%s " (length (%eenv-symbols eenv))
    hprintf r "ct #%s " (array-length (%eenv-cs eenv))
    hprintf r "vt #%s " (array-length (%eenv-vt eenv))
    hprintf r "sp #%s " (array-length (%eenv-sps eenv))
    hprintf r "bc #%s " (idio-ia-length (%eenv-byte-code eenv))
    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string %eenv eenv-as-string

define (dump-eenv eenv file) {
  fh := open-output-file file

  hprintf fh "Symbol Table: %s\n" (%eenv-desc eenv)
  loop :+ function (st) {
    if (null? st) #n {
      hprintf fh "  %s\n" (ph st)
      loop (pt st)
    }
  }
  loop (reverse (%eenv-symbols eenv))

  close-handle fh
}

define (meaning-src-location e) {
  lo := #f
  if (pair? e) {
    lo = hash-ref %idio-src-properties e #f
  }

  if lo {
    sprintf "%s:line %d" (%idio-lexical-object-name lo) (%idio-lexical-object-line lo)
  } {
    #f
  }
}

define (meaning-error-location src) {
  (or (meaning-src-location src) "<no lexobj>")
}

define (meaning-warning prefix msg e) {
  eprintf "WARNING: %s: %s: %s: %s\n" prefix msg (meaning-error-location e) e
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; all evaluation errors are derived from ^evaluation-error
;
; most of the specific errors just add some pertinent text

define (meaning-base-error src msg expr) {
  c := make-condition ^evaluation-error msg (meaning-error-location src) #n expr
  raise c
}

define (meaning-error-param-type src msg expr) {
  meaning-base-error src (sprintf "parameter type: %s" msg) expr
}

define (meaning-error-param src msg expr) {
  meaning-base-error src (sprintf "%s: %s" expr msg) expr
}

define (meaning-evaluation-error src msg expr) {
  meaning-base-error src msg expr
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; some of the various static errors should only occur in broken
; internal code
define (meaning-error-static-redefine src msg name cv new) {
  det := sprintf "%s: %s is currently %s: proposed %s" msg name cv new
  c := make-condition ^st-variable-error msg (meaning-error-location src) det name
  raise c
}

define (meaning-error-static-variable src msg name) {
  c := make-condition ^st-variable-error msg (meaning-error-location src) name name
  raise c
}

define (meaning-error-static-unbound src name) {
  meaning-error-static-variable src "unbound" name
}

define (meaning-error-static-immutable src name) {
  meaning-error-static-variable src "immutable" name
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define (meaning-error-static-primitive-arity src msg f args name primdata) {
  arity := sprintf "%d" (primitive-arity primdata)
  if (primitive-varargs? primdata) {
    arity = append-string arity "*"
  }
  det := sprintf "arity != %s; primitive (%s %s) was called as (%s %@)" arity f (%property f :sigstr) f args
  c := make-condition ^st-function-arity-error msg (meaning-error-location src) det
  raise c
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define-struct eval-flags tailp scope define
no-flags := make-eval-flags #f #n #f

define (set-tailp flags) {
  make-eval-flags #t (eval-flags-scope flags) (eval-flags-define flags)
}

define (clear-tailp flags) {
  make-eval-flags #f (eval-flags-scope flags) (eval-flags-define flags)
}

define (clear-define flags) {
  make-eval-flags (eval-flags-tailp flags) (eval-flags-scope flags) #f
}

define (set-scope scope flags) {
  make-eval-flags (eval-flags-tailp flags) scope (eval-flags-define flags)
}

define (define-scope scope flags) {
  make-eval-flags (eval-flags-tailp flags) scope #t
}

define (meaning-constants-lookup-or-extend eenv name) {
  ci := -1

  cs := %eenv-cs eenv
  ch := %eenv-ch eenv

  if (not (null? name)) {
    ci = hash-ref ch name #f

    if (not ci) {
      ci = array-find-eq? cs name
    }
  }

  if (-1 eq ci) {
    ci = array-length cs
    array-push! cs name

    if (not (null? name)) {
      hash-set! ch name ci
    }
  }

  ci
}

define (meaning-extend-tables eenv name scope ci module desc set-symbol?) "

" {
  array-push! (%eenv-st eenv) ci

  vt := %eenv-vt eenv
  vi := array-length vt

  if (not module) {
    module = (%eenv-module eenv)
  }

  array-push! vt 0

  sym-si := (list
	     name
	     scope
	     (%eenv-xi eenv)
	     vi
	     ci
	     0
	     module
	     desc)

  set-%eenv-symbols! eenv (pair sym-si (%eenv-symbols eenv))

  if set-symbol? {
    set-symbol! name (pt sym-si) module
  }

  vi
}

define (meaning-extend-operators eenv name desc) "

" {
  op-mod := find-module 'operator

  ci := meaning-constants-lookup-or-extend eenv name

  array-push! (%eenv-st eenv) ci

  vt := %eenv-vt eenv
  vi := array-length vt

  array-push! vt 0

  op-si := (list
	    name
	    scope
	    (%eenv-xi eenv)
	    vi
	    ci
	    0
	    op-mod
	    desc)

  set-%eenv-operators! eenv (pair op-si (%eenv-operators eenv))

  set-symbol! name (pt op-si) op-mod

  vi
}

define (meaning-find-symbol-recurse name eenv scope recurse) {
  ;; We want to return the name-si for (what will be baseline)
  ;; primitives otherwise they'll become like the regular lookup of a
  ;; function (via the execution environment symbol table) with a full
  ;; function calling protocol (via frame creation etc.).  If it's a
  ;; (well known) primitive we should just be calling it directly.
  symbols-sym-si := assq name (%eenv-symbols eenv)

  if (not symbols-sym-si) {
    ci := meaning-constants-lookup-or-extend eenv name

    name-si := find-symbol name (%eenv-module eenv) recurse

    if (pair? name-si) {
      scope = si-scope name-si

      meaning-extend-tables eenv name scope ci (si-module name-si) "idio-precompilation" #f

      if (eq? 'predef scope) {
	;; Notionally we don't care about the (future) vi right now
	;; just that we reserve a slot for ourselves.
	;;
	;; However, we want the running vi as later on we'll need to
	;; access the underlying primdata.
	symbols-sym-si = assq name (%eenv-symbols eenv)
	symbols-si := pt symbols-sym-si

	predef-vi := si-vi name-si
	set-si-vi! symbols-si predef-vi

	;; also change the vt entry
	vt := %eenv-vt eenv
	sym-idx := si-si symbols-si
	vt.sym-idx = predef-vi
      }
    } {
      ; is name M/S ?
      sdr := symbol-direct-reference name
      if sdr {
	;; (M S si)
	sdr-si := phtt sdr

	;; The chances are that the existing scope, in sdr, is
	;; 'predef, however if we reuse that then subsequent lookups
	;; will try to run the 'predef code in meaning-application
	;; which gets us in a mess for pre-compilation.
	;;
	;; From our future compiled code's perspective we're looking
	;; up another 'toplevel (which will be resolved in the
	;; running code into the predef).
	;;
	;; If it's a dynamic/environ/computed we want to retain that
	;; information (as it generates different byte code).
	new-scope := si-scope sdr-si
	if (eq? new-scope 'predef) {
	  new-scope = 'toplevel
	}

	meaning-extend-tables eenv name new-scope ci (si-module sdr-si) (si-description sdr-si) #t
      } {

	meaning-extend-tables eenv name scope ci #f "idio-precompilation" #f
      }
    }

    symbols-sym-si = assq name (%eenv-symbols eenv)
  }

  pt symbols-sym-si
}

define (meaning-find-symbol name eenv scope) {
  meaning-find-symbol-recurse name eenv scope #f
}

define (meaning-find-toplevel-symbol name eenv) {
  meaning-find-symbol-recurse name eenv 'toplevel #f
}

define (meaning-find-dynamic-symbol name eenv) {
  meaning-find-symbol-recurse name eenv 'dynamic #f
}

define (meaning-find-environ-symbol name eenv) {
  meaning-find-symbol-recurse name eenv 'environ #f
}

define (meaning-find-operator-symbol name eenv) {
  operators-sym-si := assq name (%eenv-operators eenv)

  if (not operators-sym-si) {
    meaning-extend-operators eenv name "idio-precompilation"

    operators-sym-si = assq name (%eenv-operators eenv)
  }

  pt operators-sym-si
}

;; No meaning-predef-extend in Idio-land, C-land only

define (meaning-toplevel-extend src name flags eenv) {
  scope := eval-flags-scope flags

  (case scope
   ((toplevel dynamic environ computed) #t)
   (else {
     meaning-evaluation-error src (sprintf "unexpected toplevel scope: flags %s\n" flags) name
   }))

  si := meaning-find-symbol name eenv scope

  cur-scope := si-scope si

  if (not (eq? cur-scope scope)) {
    meaning-error-static-redefine src "toplevel-extend: type change" name si scope
  } {
    si-si si
  }

  (cond-expand
   (IDIO_EVALUATE_DEBUG {
     if (and (eq? scope 'toplevel)
	     (not (eval-flags-define flags))) {
       eprintf "toplevel-extend: forward reference: %s at %s\n" name (meaning-error-location src)
     }
   }))

  ;; We get here in the C codebase when we shadow predefs
  ci := meaning-constants-lookup-or-extend eenv name

  ;; NB a vi of 0 indicates an unresolved value index to be resolved
  ;; (based on the current set of imports) during runtime
  meaning-extend-tables eenv name scope ci #f "meaning-toplevel-extend" #t

  si = meaning-find-symbol name eenv scope

  si-si si
}

;; idio_dynamic_extend() is only called from C

define (meaning-environ-extend src name val eenv) {
  ;; All environ symbols live in the Idio module -- it doesn't make
  ;; any sense for environ symbols to be different in other modules as
  ;; the stack (and environ(3P)), where environ variables live, is
  ;; shared by all modules
  im := find-module 'Idio
  environ-eenv := hash-ref %%eenv-map im

  si := meaning-find-environ-symbol name environ-eenv

  gvi := 0

  cur-scope := si-scope si

  if (not (eq? cur-scope 'environ)) {
    meaning-error-static-redefine src "environ-extend: type change" name si cur-scope
  } {
    gvi = si-vi si
  }

  if (eq? gvi 0) {
    ci := meaning-constants-lookup-or-extend environ-eenv name
    meaning-extend-tables environ-eenv name 'environ ci #f "meaning-environ-extend" #t

    si = meaning-find-environ-symbol name environ-eenv
  }

  set-symbol-value! name val im

  si
}

#*

meaning-lexical-lookup

{nametree} is a list of association lists with each association list
representing the names of variables introduced at some level with
newer levels preceding older ones with the effect that at the time of
lookup the innermost level is the first association list and will
therefore be searched first.

formal parameters for a given level are stashed as (name 'param j)
where {name} is the {j}th formal parameter introduced at that level.

local variables for a given level are stashed as (name 'local j) where
{name} is the {j}th variable introduced at that level -- j starts at
length(formals)+1 (for varargs)

Nominally, you would walk through each "level" of names looking for
your variable name.  If you found it at depth {i} then you can combine
that with the corresponding {j} to give a SHALLOW (for {i} == 0) or
DEEP (for {i} > 0) variable reference.

The return for a name is ('param {i} {j}) or ('local {i} {j})

It is interspersed with dynamic and environ variables.  They are
one-at-a-time variable introductions and they should not increment
{i}!

The return is, say, ('dynamic {ci} {ci}) where {ci} is the constant
index associated with the dynamic/environ variable.  {ci} is added
twice to avoid inconsistencies with a top level dynamic variable which
will have a regular symbol information tuple.

*#
define (meaning-lexical-lookup src nametree name) {
  loop :+ function (nt i) {
    if (null? nt) #f {
      name* := ph nt

      if (pair? name*) {
	l := assq name name*
	if l {
	  scope := pht l	; ({name} 'param {j})
	  (case scope
	   ((param local)     (list scope i (phtt l)))
	   ((dynamic environ) (list (pht l) (phtt l) (phtt l)))
	   (else (meaning-error-static-variable src "unexpected local variant" name)))
	} {
	  ;; only bump i if these were formal parameters
	  if (eq? 'param (phth name*)) {
	    loop (pt nt) (i + 1)
	  } {
	    loop (pt nt) i
	  }
	}
      } {
	loop (pt nt) (i + 1)
      }
    }
  }

  loop nametree 0
}

define (meaning-nametree->list nametree) {
  r := #n
  loop-nametree :+ function (nt done) {
    if done #n {
      loop-names :+ function (names) {
	if (null? names) #n {
	  name-info := ph names
	  if (and (not done)
		  (pair? name-info)
		  (pair? (pt name-info))
		  (eq? 'param (pht name-info))) {
	    done = #t
	  }
	  r = pair (ph name-info) r
	  loop-names (pt names)
	}
      }
      loop-names (ph nt)

      loop-nametree (pt nt) done
    }
  }

  loop-nametree nametree #f
  r
}

define (meaning-nametree-extend-vparams nametree name*) {
  i := 0
  loop :+ function (ns r) {
    if (null? ns) r {
      tuple := list (ph ns) 'param i
      i = i + 1
      loop (pt ns) (pair tuple r)
    }
  }

  pair (loop name* #n) nametree
}

define (meaning-nametree-extend-params nametree name*) {
  ;; consume a slot for varargs
  name* = append name* '(#f)

  meaning-nametree-extend-vparams nametree name*
}

define (meaning-nametree-extend-locals nametree name*) {
  ;; the correct value of i depends on what the params to the current
  ;; scope are.

  ;; Given n params plus 1 varargs the starting value of i for a local
  ;; is n+1 (remembering the slots start at 0)
  alist := #n
  i := 0
  i-loop :+ function (nt) {
    if (null? nt) #n {
      name* := ph nt
      if (null? name*) {
	;; a thunk
	alist = list #f 'param 0
      } {
	(case (phth name*)
	 ((local) {
	   i = i + 1
	   i-loop (pt nt)
	 })
	 ((param) {
	   i = i + (length name*)
	 }))
      }
    }
  }
  i-loop nametree

  loop :+ function (ns r) {
    if (null? ns) (reverse! r) {
      i = i + 1
      loop (pt ns) (pair (list (ph ns) 'local i) r)
    }
  }

  ;; we don't have the i++ feature from C so we need to decrement i
  ;; first
  i = i - 1
  pair (loop name* alist) nametree
}

define (meaning-nametree-dynamic-extend nametree name index scope) {
  pair (list (list name scope index)) nametree
}

define* (meaning-variable-info src nametree name flags eenv (recurse? #t)) {
  si := meaning-lexical-lookup src nametree name

  if (not si) {
    ;; NOTICE This must be a recursive lookup.  Otherwise we'll not
    ;; see any bindings in Idio.
    ;;
    ;; Unless we're defining something in which case we must NOT
    ;; recurse...although that's down to our caller to decide
    si = meaning-find-symbol-recurse name eenv (eval-flags-scope flags) recurse?

    ;; The "semantically dubious" act of shadowing predefs catches us
    ;; out here too and the problem is more subtle.
    ;;
    ;; In this case a different eenv to us has shadowed the predef and
    ;; the only way for us to know is to look the symbol up in the
    ;; module and see if the scope has changed from (our) 'predef to
    ;; (their) 'toplevel.  If so we need to extend our own tables and
    ;; swap in the gvi from the newer_si (otherwise we get the symbol
    ;; itself).

    if (eq? 'predef (si-scope si)) {
      newer-si := find-symbol name (%eenv-module eenv) #f

      if (and newer-si
	      (eq? 'toplevel (si-scope newer-si))) {
	;; extend toplevel of this eenv
	meaning-toplevel-extend src name flags eenv

	;; meaning-toplevel-extend only returns a ci
	si = meaning-find-toplevel-symbol name eenv

	;; overwrite the gvi
	set-si-vi! si (si-vi newer-si)
      }
    }
  }

  si
}

define (meaning-prefer-properties e src) {
  if (and (pair? e)
	  (hash-ref %idio-src-properties e #f)) {
    e
  } {
    src
  }
}

mpp := meaning-prefer-properties

define (meaning-copy-src-properties src dst) {
  if (pair? dst) {
    dst-lo := hash-ref %idio-src-properties dst #f
    if (not dst-lo) {
      if (pair? src) {
	src-lo := hash-ref %idio-src-properties src #f
	if src-lo {
	  dst-lo = copy-value src-lo 'shallow
	  set-%idio-lexical-object-expr! dst-lo dst
	  hash-set! %idio-src-properties dst dst-lo
	}
      }
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; let's find some meaning in all of this!

define (meaning-reference src name nametree flags eenv) {
  si := meaning-variable-info src nametree name flags eenv

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := si-scope si

  (case scope
   ((param local) {
     i := nt-param-i si
     j := nt-param-j si
     (if (i gt 0)
      (list I-DEEP-ARGUMENT-REF i j)
      (list I-SHALLOW-ARGUMENT-REF j))
   })
   ((toplevel) (list I-SYM-REF          (si-si si)))
   ((dynamic)  (list I-DYNAMIC-SYM-REF  (si-si si)))
   ((environ)  (list I-ENVIRON-SYM-REF  (si-si si)))
   ((computed) (list I-COMPUTED-SYM-REF (si-si si)))
   ((predef)   (list I-PREDEFINED       (si-si si)))
   (else {
     ;; Shouldn't get here unless the if clauses above don't
     ;; cover everything.  Developer error?
     meaning-error-static-unbound src name
   }))
}

define (meaning-function-reference src name nametree flags eenv) {
  si := meaning-variable-info src nametree name (set-scope 'toplevel flags) eenv

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := si-scope si

  (case scope
   ((param local) {
     i := nt-param-i si
     j := nt-param-j si
     (if (i gt 0)
      (list I-DEEP-ARGUMENT-REF i j)
      (list I-SHALLOW-ARGUMENT-REF j))
   })
   ((toplevel) (list I-FUNCTION-SYM-REF         (si-si si)))
   ((dynamic)  (list I-DYNAMIC-FUNCTION-SYM-REF (si-si si)))
   ((environ)  (list I-ENVIRON-SYM-REF          (si-si si)))
   ((computed) (list I-COMPUTED-SYM-REF         (si-si si)))
   ((predef)   (list I-PREDEFINED		(si-si si)))
   (else {
     ;; Shouldn't get here unless the if clauses above don't
     ;; cover everything.  Developer error?
     meaning-error-static-unbound src name
   }))
}

define (meaning-not src e nametree flags eenv) {
  list I-NOT (eval-flags-tailp flags) (meaning (mpp e src) e nametree (clear-tailp flags) eenv)
}

define (meaning-escape src e nametree flags eenv) {
  meaning (mpp e src) e nametree flags eenv
}

define (meaning-quotation src v nametree flags) {
  list I-CONSTANT-REF v
}

; a couple of helper functions from Appendix A of Alan Bawden's
; Quasiquotation in Lisp paper -- reworked slightly

define (eps-qq-expand-list e) {
  (cond
   ((pair? e) {
     sym := ph e
     (cond
      ((eq? 'unquote sym)		#T{ (list $(pht e)) })
      ((eq? 'unquotesplicing sym)	(pht e))
      ((eq? 'quasiquote sym)		(eps-qq-expand-list
					 (eps-qq-expand (pht e))))
      (else				#T{ (list (append
						   $(eps-qq-expand-list (ph e))
						   $(eps-qq-expand      (pt e)))) }))
   })
   ((array? e) {
     list 'list->array (eps-qq-expand-list (array->list e))
   })
   (else {
     #T{ '($e) }
   }))
}

define (eps-qq-expand e) {
  (cond
   ((pair? e) {
     sym := ph e
     (cond
      ((eq? 'unquote sym)		(pht e))
      ((eq? 'unquotesplicing sym)	(error/type ^rt-parameter-value-error 'eps-qq-expand "illegal use of $@ at head" e))
      ((eq? 'quasiquote sym)		(eps-qq-expand
					 (eps-qq-expand (pht e))))
      (else				#T{ (append $(eps-qq-expand-list (ph e))
						    $(eps-qq-expand      (pt e))) }))
   })
   ((array? e) {
     list 'list->array (eps-qq-expand (array->list e))
   })
   (else {
     #T{ '$e }
   }))
}

define (qq-expand e) {
  eps-qq-expand e
}

define (STklos-backquotify e level) {
  ;printf "              bq    p?=%s e=%s\n" (pair? e) e
  (cond
   ((pair? e)
    (cond
     ((eq? (ph e) 'quasiquote)
      (list 'list ''quasiquote
		  (STklos-backquotify (pht e) (+ level 1))))
     ((eq? (ph e) 'unquote)
      (if (level le 0)
       (pht e)
       (list 'list ''unquote
		   (STklos-backquotify (pht e) (- level 1)))))
     ((eq? (ph e) 'unquotesplicing)
      (if (level le 0)
       (list 'pair
	     (STklos-backquotify (ph e) level)
	     (STklos-backquotify (pt e) level))
       (list 'list ''unquotesplicing
		   (STklos-backquotify (pht e) (- level 1)))))
     ((and (level le 0) (pair? (ph e)) (eq? (phh e) 'unquotesplicing))
      (if (null? (pt e))
       (phth e)
       (list 'append (phth e)
		     (STklos-backquotify (pt e) level))))
     (else
      (list 'pair
	    (STklos-backquotify (ph e) level)
	    (STklos-backquotify (pt e) level)))))
   ((symbol? e)
    (list 'quote e))
   (else
    e))
}

define (STklos-expand e) {
  STklos-backquotify e 0
}

define (meaning-quasiquotation src e nametree flags eenv) {
  ee := qq-expand e
  meaning-copy-src-properties src ee

  meaning ee ee nametree flags eenv
}

define (meaning-alternative src e1 e2 e3 nametree flags eenv) {
  m1 := meaning (mpp e1 src) e1 nametree (clear-tailp flags) eenv
  m2 := meaning (mpp e2 src) e2 nametree flags eenv
  m3 := meaning (mpp e3 src) e3 nametree flags eenv

  list I-ALTERNATIVE src m1 m2 m3
}

#*

validate & rewrite the cond clauses, {clauses}, noting the special
cases of {=>}, {else}

*#

define (meaning-rewrite-cond prev src clause*) {
  (cond ((null? clause*) (void))

   ((not (pair? clause*))
    ;; Shouldn't get here, eg. "(cond)", as we test that the cond
    ;; clause* are a pair in the main idio_meaning loop.
    (meaning-evaluation-error src "cond: no clauses" clause*))

   ((not (pair? (ph clause*))) {
     if (and (pair? (pt clause*))
	     (pair? (pht clause*))) {
       ;; Test Cases:
       ;; evaluation-errors/rewrite-cond-isa-pair-only.idio
       ;; evaluation-errors/rewrite-cond-isa-pair-before.idio
       ;; evaluation-errors/rewrite-cond-isa-pair-after.idio

       ;; cond #t
       ;; cond #t (#f 1)
       ;; cond (#f 1) #t
       meaning-error-param-type (pht clause*) "cond: clause is not a pair (before)" clause*
     } {
       ;; Test Case: ??
       meaning-error-param-type prev "cond: clause is not a pair (in/after)" clause*
     }
   })

   ((eq? 'else (phh clause*)) {
     if (null? (pt clause*)) {
       c* := append (list 'begin) (pth clause*)
       meaning-copy-src-properties (mpp (pth clause*) src) c*
       c*
     } {
       ;; Test Case: evaluation-errors/rewrite-cond-else-not-last.idio

       ;; cond (else 1) (#t 2)
       meaning-evaluation-error (ph clause*) "cond: else not in last clause" clause*
     }
   })

   ((and (pair? (pth clause*))
	 (eq? '=> (phth clause*))) {
     ;; XXX We've just accessed the {phth clause*} so *of course* it's
     ;; a list...the only useful thing we're doing here is checking
     ;; there's explicitly three elements.

     ph-clause* := ph clause*

     if (and (list? ph-clause*)
	     (3 eq (length ph-clause*))) {
       ;; The {=>} operator is a bit of a Scheme-ism in that the
       ;; clause says {(c => f)} and means that if {c} is true then
       ;; apply {f} to {c} and return the result of that.  Of course
       ;; we need to stage the (result of the) evaluation of {c} in a
       ;; temporary variable because we don't want it evaluated twice.

       ;; There is an unhelpful indirection complication in that we
       ;; are looking at {clause*} so this clause is {ph clause*} and
       ;; then {c} and {f} are the {ph clause} (therefore {phh
       ;; clause*}) and {phtt clause} (and therefore {phtth clause*})
       ;; respectively.

       ;; Finally, this clause is just one of many, so we need to keep
       ;; rewriting all the remaining clause* ({pt clause*}).

       gs := (gensym)

       ;; `(let ((gs ,(phh clause*)))
       ;;	(if gs
       ;;	    (,(phtth clause*) gs)
       ;;	    ,(rewrite-cond-clause* (pt clause*))))
       pt-clause* := pt clause*

       appl := list (phtth clause*) gs

       c := (list 'let
		  (list (list gs (phh clause*)))
		  (list 'if
			gs
			appl
			(meaning-rewrite-cond ph-clause*
					      (mpp pt-clause* src)
					      pt-clause*)))
       meaning-copy-src-properties (mpp ph-clause* src) c
       c
     } {
       if (pair? src) {
	 ;; Test Cases:
	 ;; evaluation-errors/rewrite-cond-apply-two-args.idio
	 ;; evaluation-errors/rewrite-cond-apply-four-args.idio

	 ;; cond (1 =>)
	 ;; cond (1 => a b)
	 meaning-evaluation-error (ph src) "cond: invalid => clause" clause*
       } {
	 ;; Test Case: ??
	 meaning-evaluation-error src "cond: invalid => clause" clause*
       }
     }
   })

   ((null? (pth clause*)) {
     gs := (gensym)
     ;; `(let ((gs ,(phh clause*)))
     ;;	   (or gs
     ;;	       ,(rewrite-cond-clause* (pt clause*))))

     ph-clause* := ph clause*
     pt-clause* := pt clause*

     c* := (list 'let
		 (list (list gs (phh clause*)))
		 (list 'or
		       gs
		       (meaning-rewrite-cond ph-clause*
					     (mpp pt-clause* src)
					     pt-clause*)))
     meaning-copy-src-properties (mpp ph-clause* src) c*
     c*
   })

   (else {
     ph-clause* := ph clause*
     pt-clause* := pt clause*

     c := (list 'if
		(phh clause* )
		(append (list 'begin) (pth clause*))
		(meaning-rewrite-cond ph-clause*
				      (mpp pt-clause* src)
				      pt-clause*))
     meaning-copy-src-properties (mpp ph-clause* src) c
     c
   }))
}

define (meaning-assignment src name e nametree flags eenv) {
  (cond
   ((pair? name) {
     ;; setter

     ;; append will deconstruct the (setter name) construct so we need
     ;; extra levels of list
     args := pt name

     setter := list 'setter (ph name)
     meaning-copy-src-properties src setter

     se := append (list setter) args (list e)

     meaning src se nametree (clear-define flags) eenv
   })
   ((symbol? name) {
     mflags := make-eval-flags #f (eval-flags-scope flags) #f

     m := meaning (mpp e src) e nametree mflags eenv

     si := meaning-variable-info src nametree name flags eenv (not (eval-flags-define flags))

     if (not si) {
       ; shouldn't get here as unknowns are automatically made toplevel
       meaning-error-static-unbound src name
     }

     scope := si-scope si
     sym-idx := si-si si

     ci := #f

     ; without being able to return early we can presume that if
     ; someone has set the intermediate code {i-code} then they
     ; intended to return immediately
     i-code := #f

     ; otherwise set {assign} to the intermediate code for the
     ; assignment part and we'll also check the {define} flag for all
     ; three callers
     assign := #n

     (case scope
      ((param local) {
	i := nt-param-i si
	j := nt-param-j si
	if (0 eq i) {
	  i-code = list I-SHALLOW-ARGUMENT-SET j m
	} {
	  i-code = list I-DEEP-ARGUMENT-SET i j m
	}
      })
      ((toplevel) {
	assign = list I-SYM-SET src sym-idx m
      })
      ((dynamic environ) {
	assign = list I-SYM-SET src sym-idx m
      })
      ((computed) {
	if (eval-flags-define flags) {
	  i-code = (list (list I-SYM-DEF name scope sym-idx)
			 (list I-COMPUTED-SYM-DEF sym-idx m))
	} {
	  i-code = list I-COMPUTED-SYM-SET sym-idx m
	}
      })
      ((predef) {
	;; We can shadow predefs...semantically dubious!
	;;
	;; Dubious because many (most?) functions use, say, ph,
	;; eg. map.  If you redefine ph should map be affected?  Is it
	;; your intention that by changing ph everything should use
	;; the new definition of ph immediately or just that functions
	;; defined after this should use the new definition?
	;;
	;; We need a new symbol index as the existing one is tagged as
	;; a predef.  This new one will be tagged as a toplevel.
	sym-idx = meaning-toplevel-extend src name (define-scope 'toplevel flags) eenv
	scope = 'toplevel

	;; But now we have a problem.
	;;
	;; As we *compile* regular code, any subsequent reference to
	;; {name} will find this new toplevel and we'll embed SYM-REFs
	;; to it etc..  All good for the future when we *run* the
	;; compiled code.
	;;
	;; However, if any templates in the here and now refer to
	;; {name} then we have a problem.  All we've done is extend
	;; the VM's table of known toplevels and given it a value of
	;; #undef.  If a template tries to use {name} it'll get back
	;; #undef and things will start to go wrong.
	;;
	;; What we need to do is patch up the toplevel with the
	;; current primitive value we're overriding.
	vi := si-vi si
	set-symbol-value! name (vm-values-ref vi 0) (%eenv-module eenv)
	assign = list I-SYM-SET src sym-idx m
      })
      (else {
	;; Shouldn't get here unless the if clauses above don't
	;; cover everything.  Developer error?
	meaning-error-static-unbound src name
      }))

     (cond
      (i-code i-code)
      ((eval-flags-define flags)
       (list (list I-SYM-DEF name scope sym-idx)
	     assign))
      (else assign))
   })
   (else
    ;; Test Case: evaluation-errors/assign-non-symbol.idio

    ;; 1 = 3
    (meaning-evaluation-error src "cannot assign to" name)))
}

define (meaning-define src name e nametree flags eenv) {
  if (pair? name) {
    ;; (define (func arg) ...) =>
    ;; (define func (function/name func (arg) ...))
    e = append (list 'function/name (ph name) (pt name)) e
    name = ph name

    meaning-copy-src-properties src e
  } {
    if (pair? e) {
      e = ph e

      meaning-copy-src-properties src e
    }
  }

  define-flags := make-eval-flags (eval-flags-tailp flags) 'toplevel #t

  ;; Careful!  Don't recurse when defining variables.
  si := meaning-variable-info src nametree name define-flags eenv #f

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  ;; if the act of looking the variable up auto-created it then
  ;; actually give it a value slot as this *is* the definition of it
  scope :=  si-scope si
  ci := si-ci si
  vi := si-vi si

  if (and (eq? 'toplevel scope)
	  (eq? 0 vi)
	  (not (%eenv-aot? eenv))) {
    set-si-vi! si (vm-extend-values)
    set-si-description! si "meaning-define/gvi=0"
  }

  meaning-assignment src name e nametree define-flags eenv
}

define (meaning-define-template src name e nametree flags eenv) {

  ;; Possible docstr
  ;;
  ;; (define-template (name formal*) ["docstr"] ...)

  docstr := #n
  if (and (pair? e)
	  (string? (ph e))
	  (not (null? (pt e)))) {
    docstr = ph e
    e = pt e
  } {
    docstr = sprintf "define-template: %s (x e)" name
  }

  ;; XXX only a single expression
  e = ph e

  if (pair? name) {
    ;; (define-template (name formal*) ...) =>
    ;; (define-template name (function/name name (formal*) ...))
    e = list 'function/name (ph name) (pt name) e
    name = ph name

    meaning-copy-src-properties src e
  }

  ;; create an expander: (function/name {name-expander} (x e) (apply proc (pt x)))

  ;; where proc is (function/name name (formal*) ...) from above,
  ;; ie. e
  pt-x := '(pt x)
  meaning-copy-src-properties src pt-x

  appl := list 'apply e pt-x
  meaning-copy-src-properties src appl

  expander := (list 'function/name
		    (string->symbol (sprintf "%s-expander" name))
		    '(x e)
		    docstr
		    appl)

  meaning-copy-src-properties src expander

  ;; In general (define-template a ...) means that "a" is associated
  ;; with an expander and that expander takes the pt of the expression
  ;; it is passed, "(a ...)" (ie. it skips over its own name).

  ;; It happens that people (S9fES) say

  ;; (define-template %b ...)
  ;; (define-template b %b)

  ;; (in particular where they are creating an enhanced version of b
  ;; which may require using the existing b to define itself hence
  ;; defining some other name, "%b", which can use "b" freely then
  ;; redefine b to this new version)

  ;; However, we can't just use the current value of "%b" in
  ;; (define-template b %b) as this template-expander association
  ;; means we are replacing the nominal definition of a template with
  ;; an expander which takes two arguments and the body of which will
  ;; take the pt of its first argument.  Left alone, expander "b" will
  ;; take the pt then expander "%b" will take the pt....  "A Pair-Tail
  ;; Too Far", one would say, in hindsight and thinking of the big
  ;; budget movie potential.

  ;; So catch the case where the value is already an expander and
  ;; replace it with the (obvious?) assignment with some
  ;; *expander-list* copying.

  if (and (symbol? e)
	  (expander? e)) {
    install-expander/source! name (expander? e) expander

    meaning-assignment src name e nametree (define-scope 'toplevel flags) eenv
  } {
    ;; XXX define-template bootstrap

    ;; Option 1 (when I was dealing with file contents "all in one"):

    ;; We really want the entry in *expander-list* to be some compiled
    ;; code but we don't know what that code is yet because we have't
    ;; processed the source code of the expander -- we only invented
    ;; it a couple of lines above -- let alone compiled it!

    ;; So, we'll drop the "source" code of the expander into
    ;; *expander-list* and later, when someone calls expander?  for
    ;; this name we'll notice the value is a pair and do a symbol
    ;; lookup for the closure that was created via meaning-assignment.

    ;; Option 2 (noted at the time but not implemented):

    ;; As an alternative we could evaluate the source to the expander
    ;; now and install that code in *expander-list* directly -- but
    ;; watch out for embedded calls to regular functions defined in
    ;; the code (see comment above).

    ;; In fact, because the evaluator changed to
    ;; expression-by-expression we effectively implement Option 2
    ;; (which handles the regular function calls as well).

    ;; Requirement either way:

    ;; As a further twist, we really need to embed a call to
    ;; install-expander in the *object* code too!  When someone in the
    ;; future loads the object file containing this define-template
    ;; who will have called install-expander?

    ;; In summary: we need the expander in the here and now as someone
    ;; might use it in the next line of source and we need to embed a
    ;; call to install-expander in the object code for future users.

    ;; this is a define at the toplevel and not tailp
    ma := meaning-assignment expander name expander nametree (make-eval-flags #f 'toplevel #t) eenv

    install-expander/source! name expander expander

    ;; Generate a ci/vi for name

    si := meaning-find-toplevel-symbol name eenv

    ;; The ci is required so that the EXPANDER opcode can call
    ;; install-expander to overwrite the proc from the
    ;; install-expander/source! call we just made
    ci := meaning-constants-lookup-or-extend eenv name

    ex-id := si-si si

    cm := (current-module)

    sym-si := list 'toplevel (%eenv-xi eenv) ex-id ci 0 cm docstr

    set-symbol! name sym-si cm

    list I-EXPANDER ex-id ma
  }
}

define (meaning-define-infix-operator src name pri e nametree flags eenv) {
  if (pri lt 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol information for {name} or create
  ;; a new one
  si := meaning-find-operator-symbol name eenv

  set-symbol! name si (find-module 'operator)

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-infix-operator X pri Y

    if (infix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *infix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve

      pre-compilation-restore-operator! name pri 'infix

      m = meaning src sve nametree flags eenv
    } {
      ;; Test Case: evaluation-errors/infix-op-not-an-operator.idio

      ;; define-infix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-infix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-infix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function/name
		name
		'(op before after)
		(sprintf "infix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    pre-compilation-restore-operator! name pri 'infix

    m = meaning src fe nametree flags eenv
  }

  list I-INFIX-OPERATOR (si-si si) pri m
}

define (meaning-define-postfix-operator src name pri e nametree flags eenv) {
  if (pri lt 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol information for {name} or create
  ;; a new one
  si := meaning-find-operator-symbol name eenv

  set-symbol! name si (find-module 'operator)

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-postfix-operator X pri Y

    if (postfix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *postfix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve

      pre-compilation-restore-operator! name pri 'postfix

      m = meaning src sve nametree flags eenv
    } {
      ;; Test Case: evaluation-errors/postfix-op-not-an-operator.idio

      ;; define-postfix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-postfix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-postfix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function/name
		name
		'(op before after)
		(sprintf "postfix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    pre-compilation-restore-operator! name pri 'postfix

    m = meaning src fe nametree flags eenv
  }

  list I-POSTFIX-OPERATOR (si-si si) pri m
}

define (meaning-define-dynamic src name e nametree flags eenv) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree (define-scope 'dynamic flags) eenv
}

define (meaning-define-environ src name e nametree flags eenv) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree (define-scope 'environ flags) eenv
}

;; A computed variable's value should be a pair, (getter & setter).
;; Either of getter or setter can be #n.
;;
;; We shouldn't have both #n as it wouldn't be much use.

define (meaning-define-computed src name e nametree flags eenv) {
  getter := #n
  setter := #n

  if (pair? e) {
    he := ph e

    if (pair? he) {
      getter = ph he
      setter = pht he
    } {
      getter = he
    }
  } {
    ;; Not sure we can get here as {e} is either #n or a list
    meaning-evaluation-error src "define-computed: no getter/setter" e
  }

  if (and (null? getter)
	  (null? setter)) {
    ;; Test Case: evaluation-errors/define-computed-no-args.idio

    ;; C :$ #n
    meaning-evaluation-error src "define-computed: no getter/setter" name
  }

  #*

  There are no property lists associated with variables so we can't
  pull the same (set! (proc ...) v) => ((setter proc) ... v) trick as
  we can with procs.

  So, to set the actual getter/setter pair, as opposed to setting the
  variable (which is a call to the setter proc), we need a magic flag
  for meaning-assignment: IDIO_MEANING_FLAG_DEFINE.  Here, then, this
  is a re-definition rather than an assignment per se.

  *#

  meaning-assignment src name (list 'pair getter setter) nametree (define-scope 'computed flags) eenv
}

define (meaning*-single-sequence src e nametree flags eenv) {
  meaning (mpp e src) e nametree flags eenv
}

define (meaning*-multiple-sequence src e e+ nametree flags keyword eenv) {
  ;; The C code handles meaning*-multiple-sequence directly in
  ;; idio_meaning_sequence() by using a while loop (to avoid
  ;; recursion) which, as a side-effect, means it can identify the
  ;; trailing #n in a list
  ;;
  ;; We'll have to test for #n first and set up the arguments for the
  ;; I-cmd accordingly

  loop :+ function (e e+ r) {
    seq-flags := clear-tailp flags
    if (null? e+) {
      seq-flags = flags
    }

    m := meaning (mpp e src) e nametree seq-flags eenv

    if (pair? e+) {
      loop (ph e+) (pt e+) (pair m r)
    } {
      pair m r
    }
  }

  m+ := reverse! (loop e e+ #n)

  (case keyword
   ((begin)		(append (list I-BEGIN (eval-flags-tailp flags)) m+))
   ((and)		(append (list I-AND   (eval-flags-tailp flags)) m+))
   ((or)		(append (list I-OR    (eval-flags-tailp flags)) m+))
   (else
    ;; Shouldn't get here unless the clauses above don't cover
    ;; everything.  Developer error?
    (meaning-evaluation-error src "unexpected sequence keyword" keyword)))
}

define (meaning-sequence src e+ nametree flags keyword eenv) {
  if (pair? e+) {
    ;; We're going to deviate here from LiSP which differentiates
    ;; between multiple and single expression sequences.
    ;;
    ;; We choose not to do that because we want AND/OR to
    ;; suppress-rcse thus handling external-command logic.
    meaning*-multiple-sequence src (ph e+) (pt e+) nametree flags keyword eenv
    #*
    he+ := ph e+
    if (pair? (pt e+)) {
    meaning*-multiple-sequence src he+ (pt e+) nametree flags keyword eenv
    } {
    meaning*-single-sequence src he+ nametree flags eenv
    }
    *#
  } {
    ;; Shouldn't get here as the args were checked in meaning.
    ;; Developer error?
    meaning-evaluation-error keyword "sequence: not a pair" e+
  }
}

define (meaning-fix-abstraction src name formal* arg-name* docstr e+ nametree flags eenv) {
  arity := length formal*
  nt+ := meaning-nametree-extend-params nametree formal*

  m+ := meaning-sequence src e+ nt+ (set-tailp flags) 'begin eenv

  ;; CREATE-FUNCTION is going to consume a vi which we create here so
  ;; that subsequent references line up.
  ;;
  ;; Do not give this entry a name as it is not for this symbol but a
  ;; side-effect of CREATE-IFUNCTION.
  vi := meaning-extend-tables eenv #f 'toplevel #f #f "fix-abstraction" #f

  list I-FIX-CLOSURE m+ name arity (meaning-nametree->list nt+) docstr src vi
}

define (meaning-dotted-abstraction src name formal* vararg arg-name* docstr e+ nametree flags eenv) {
  arity := length formal*
  fix-formal* := append formal* (list vararg)

  nt+ := meaning-nametree-extend-vparams nametree fix-formal*

  m+ := meaning-sequence src e+ nt+ (set-tailp flags) 'begin eenv

  ;; CREATE-FUNCTION is going to consume a vi which we create here so
  ;; that subsequent references line up
  ;;
  ;; Do not give this entry a name as it is not for this symbol but a
  ;; side-effect of CREATE-IFUNCTION.
  vi := meaning-extend-tables eenv #f 'toplevel #f #f "dotted-abstraction" #f

  list I-NARY-CLOSURE m+ name arity (meaning-nametree->list nt+) docstr src vi
}

define (meaning-rewrite-assign-anon-function src e) {
  if (and (pair? (pt e))
	  (pair? (pht e))
	  (eq? 'function (phht e))) {
    e = (list (ph e)
	      (append
	       (list 'function/name
		     (ph e)
		     (phtht e))
	       (pttht e)))
    meaning-copy-src-properties src e
  }

  e
}

#*

With meaning-rewrite-body/meaning-rewrite-body-letrec we want to
massage the code to support some semantic trickery.

The two broad swathes are:

1. multiple function defines in (Scheme: at the start of) the body.

   {
     define (f) { ... }
     define (g) { ... }
     ...
   }

   Here, these two are expected to be self or mutually recursive
   (as well as being of local scope) and so the body is rewritten such
   that these are letrec definitions (and can safely be self/mutually
   recursive) and rest of the the body becomes the body of the letrec

   In Scheme these are only allowed at the start of the body whereas
   Idio allows them to appear anywhere in the body and when one
   appears we combine them with any immediately following.

2. new variable introductions

   a. := (let*)

      This is an extension of the letrec mechanism above so that the
      remaining body is transformed into a let* of the variable
      assignment.

      In fact, if we have an existing nametree then we can start using
      local variables in the existing frame.

   b. :* :~ !* !~

      These require a similar transform as the introduction of
      (potentially shadowing) environment/dynamic variables requires
      that their definitions be removed from the stack at the end of
      the body.

      Essentially the same as introducing environment/dynamic
      variables we can unset them which requires the same technique.

3. source properties

   If we're inventing code snippets then we should make some small
   effort to ensure that the source properties of the original code
   are propagated to our snippet.  This is especially important when
   several of these snippets invoke expanders -- which need to do much
   the same themselves!

---

meaning-rewrite-body is the main entry point and this will perform the
let* rewrites for := (and similar for dynamic/environ variables)

meaning-rewrite-body-letrec is called if we see an internal define/:+

*#

define (meaning-rewrite-body src e nametree) {
  (cond
   ((pair? e) {
     loop :+ function (l r) {
       cur := (cond
	       ((null? l) {
		 reverse! r
	       })

	       ((and (pair? l)
		     (pair? (ph l))
		     (expander? (phh l))) {
		 template-expand* (ph l)
	       })

	       ((pair? l) {
		 ph l
	       })

	       (else {
		 eprintf "meaning-rewrite-body: unexpected atom: %s\nsrc %s\n" l src
		 l
	       }))

       if (pair? l) {
	 meaning-copy-src-properties (mpp (ph l) src) cur
       }

       (cond
	((null? l) {
	  cur
	})

	((and (pair? cur)
	      (eq? 'begin (ph cur))) {
	  ;; redundant begin
	  new-l := append (pt cur) (pt l)
	  meaning-copy-src-properties cur new-l
	  loop new-l r
	})

	((and (pair? cur)
	      (or (eq? 'define (ph cur))
		  (eq? ':+ (ph cur)))) {
	  ;; :+ or define ==> letrec
	  reverse! (pair (meaning-rewrite-body-letrec (mpp l src) l nametree) r)
	})

	((and (pair? cur)
	      (eq? ':= (ph cur))) {
	  ;; := ==> let*

	  ;; we have ((:= name value-expr) ...)

	  ;; which we can rewrite as

	  ;; (let ((name value-expr))
	  ;;      (begin
	  ;;       ...
	  ;;       ))

	  ;; and recurse on ..., which is now the body of
	  ;; our (let)

	  binding := meaning-rewrite-assign-anon-function src (pt cur)

	  assign := 'function
	  if (not (null? nametree)) {
	    assign = 'function+
	  }

	  body := meaning-rewrite-body (mpp cur src) (pt l) nametree
	  meaning-copy-src-properties cur body

	  if (null? body) {
	    ;; what if value-expr has side-effects?
	    meaning-warning "rewrite-body" "empty body for let/function+" cur
	    reverse! r
	  } {

	    body-seq := append (list 'begin) body
	    meaning-copy-src-properties cur body-seq

	    r-cur := #f

	    (cond
	     ((eq? 'let assign) {
	       r-cur = (list assign
			     (list binding)
			     body-seq)
	     })
	     ((eq? 'function assign) {
	       r-cur = (list (list assign (list (ph binding))
					  body-seq)
			     (pht binding))
	     })
	     ((eq? 'function+ assign) {
	       r-cur = list assign (ph binding) (pht binding) body-seq
	     }))

	    meaning-copy-src-properties (mpp cur src) r-cur

	    reverse! (append (list r-cur) r)
	  }
	})

	((and (pair? cur)
	      (or (eq? ':* (ph cur))
		  (eq? '!* (ph cur))
		  (eq? ':~ (ph cur))
		  (eq? '!~ (ph cur)))) {

	  op := (case (ph cur)
	   ((:*) 'environ-let)
	   ((!*) 'environ-unset)
	   ((:~) 'dynamic-let)
	   ((!~) 'dynamic-unset)
	   (else (meaning-error-param src "bad operator" (ph cur))))

	  body := meaning-rewrite-body (mpp cur src) (pt l) nametree

	  if (null? body) {
	    ;; what if value-expr has side-effects?
	    meaning-warning "rewrite-body" (sprintf "empty body for %s" op) cur
	    reverse! r
	  } {
	    body-seq := append (list 'begin) body

	    ;; binding should be (var val) or just var
	    binding := pt cur
	    (case (ph cur)
	     ((!* !~) (binding = ph binding)))

	    r-cur := (list op
			   binding
			   body-seq)

	    meaning-copy-src-properties (mpp cur src) r-cur

	    reverse! (append (list r-cur) r)
	  }
	})

	((and (pair? cur)
	      (eq? 'define-template (ph cur))) {

	  meaning-evaluation-error src "internal define-template" cur
	})

	(else {
	  loop (pt l) (pair cur r)
	}))
     }

     loop e #n
   })

   ;; this else clause should have been added in 8c590f92 tests:
   ;; condition coverage
   (else e))
}

#*

meaning-rewrite-body-letrec is slightly more sophisticated than
meaning-rewrite-body in that it needs to accumulate
consecutive "define"s to produce the letrec statement.

The algorithm was inspired by rewrite-body in STklos
.../lib/compiler.stk

*#

define (meaning-rewrite-body-letrec src e nametree) {
  loop :+ function (l defs r) {
    cur := (cond
	    ((null? l) {
	      #*

	      Test Case: evaluation-errors/letrec-empty-body.idio

	      {
	        bar :+ "foo"

	      }

	      NB The point is that there is nothing else in the block
	      after the creation of {bar}, so there is no "body" for
	      the (generated) letrec of {bar}.

	      Regardless of whether {bar} is a (faintly) pointless
	      sort of letrec, notably not involving a function.

	      There's an argument that it could be optimised away (if
	      the value-expression has no side-effects, etc.).

	      *#
	      meaning-evaluation-error src "empty body after definition" src
	    })

	    ((and (pair? l)
		  (pair? (ph l))
		  (expander? (phh l))) {
	      te := template-expand* (ph l)
	      meaning-copy-src-properties src te
	      te
	    })

	    ((pair? l) {
	      ph l
	    })

	    (else {
	      eprintf "meaning-rewrite-body-letrec: unexpected atom: %s\nsrc %s\n" l src
	      l
	    }))

    if (pair? l) {
      meaning-copy-src-properties (mpp (ph l) src) cur
    }

    (cond

     ((and (pair? cur)
	   (eq? 'begin (ph cur))) {
       ;; redundant begin
       new-l := append (pt cur) (pt l)
       meaning-copy-src-properties cur new-l
       loop new-l defs r
     })

     ((and (pair? cur)
	   (or (eq? 'define (ph cur))
	       (eq? ':+ (ph cur)))) {
       ;; cur	~ (define (name formal*) ...)
       ;; cur	~ (:+ name value-expr)

       bindings := pht cur
       form := #f

       if (pair? bindings) {
	 ;; cur		~ (define (name formal*) ...)

	 ;; form	~ (name (function (formal*)) ...)

	 fn := #n

	 ;; create a docstr if there isn't one already
	 if (or (not (string? (phtt cur)))
		(not (pair? (pttt cur)))) {
	   fn = (append (list 'function/name
			      (ph bindings)
			      (pt bindings)
			      (sprintf "rewrite body letrec: %s" bindings))
		 (ptt cur))
	 } {
	   fn = (append (list 'function/name
			      (ph bindings)
			      (pt bindings))
		 (ptt cur))
	 }
	 meaning-copy-src-properties (mpp cur src) fn

	 form = list (ph bindings) fn
       } {
	 ;; cur	~ (:+ name value-expr)

	 ;; form	~ (name value-expr)
	 form = meaning-rewrite-assign-anon-function src (pt cur)
       }
       meaning-copy-src-properties (mpp cur src) form

       loop (pt l) (pair form defs) r
     })

     ((and (pair? cur)
	   (eq? 'define-template (ph cur))) {

       ;; Test Case: (nominally) evaluation-errors/letrec-internal-define-template.idio

       ;; bar :+ define-template (baz) { #T{ 1 } }

       ;; XXX I can't get this to trigger the error
       meaning-error-param src "internal define-template" cur
     })

     (else {
       ;; body proper

       cur-props := mpp cur src
       l = meaning-rewrite-body cur-props l nametree

       ;; if no defs just return l
       if (null? defs) l {
	 #*

	 poor man's letrec*

	 We are aiming for:

	 {
	   v1 :+ a1
	   v2 :+ a2
	   body
	 }

	 to become

	 (let ((v1 #f)
	       (v2 #f))
	   (set! v1 a1)
	   (set1 v2 a2)
	   body)

	 but we return it as a list of one, ((let ... body)), so that
	 idio_meaning_sequence will re-read the first element in the
	 list and interpret it as the expander "let"

	 NB Leave defs reversed as creating the bindings/assignments
	 will implicitly re-order them

	 *#

	 bindings := #n
	 for-each (function (formal) {
	   bindings = pair (list formal #f) bindings
	 }) (map ph defs)

	 #*

	 Remember {defs} is the list of tuples

	 ((v1 a1) (v2 a2))

	 so that (ph vs) is (v1 a1) and therefore

	 (append (set!) (v1 a1))

	 gives us the desired

	 (set! v1 a1)

	 and that as we walk down {vs} we'll get a (reversed) list of
	 assignments in {body}

	 ((set! v2 a2)
	  (set! v1 a1))

	 *#

	 body := #n
	 for-each (function (def) {
	   assign := append (list 'set!) def
	   body = append (list assign) body
	 }) defs
	 body = append body l

	 stmt := append (list 'let bindings) body
	 meaning-copy-src-properties cur-props stmt

	 stmt
       }
     }))
  }

  loop e #n #n
}

define (meaning-abstraction src name formal* docstr e+ nametree flags eenv) {
  e+ := meaning-rewrite-body (mpp e+ src) e+ nametree
  meaning-copy-src-properties src e+

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction
  formals-loop :+ function (f* regular) {
    (cond
     ((pair? f*) (formals-loop (pt f*) (pair (ph f*) regular)))
     ((null? f*) (meaning-fix-abstraction src name formal* formal* docstr e+ nametree flags eenv))
     (else (meaning-dotted-abstraction src name (reverse! regular) f* formal* docstr e+ nametree flags eenv)))
  }

  formals-loop formal* #n
}

define (meaning-block src e* nametree flags eenv) {
  e* = meaning-rewrite-body (mpp e* src) e* nametree
  meaning-copy-src-properties src e*

  meaning-sequence (mpp e* src) e* nametree flags 'begin eenv
}

define (meaning-some-arguments src ae ae* nametree arity flags eenv) {
  am := meaning (mpp ae src) ae nametree (clear-tailp flags) eenv
  am* := meaning-arguments src ae* nametree arity flags eenv

  rank := arity - ((length ae*) + 1)

  list I-STORE-ARGUMENT am am* rank
}

define (meaning-no-argument src nametree arity flags eenv) {
  list I-ALLOCATE-FRAME arity
}

define (meaning-arguments src ae* nametree arity flags eenv) {
  if (pair? ae*) {
    meaning-some-arguments src (ph ae*) (pt ae*) nametree arity flags eenv
  } {
    meaning-no-argument src nametree arity flags eenv
  }
}

define (meaning-fix-closed-application src formal* body ae* nametree flags eenv) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am* := meaning-arguments src ae* nametree (length ae*) (clear-tailp flags) eenv
  nt+ := meaning-nametree-extend-params nametree formal*

  mbody := meaning-sequence (mpp body src) body nt+ flags 'begin eenv

  if (eval-flags-tailp flags) {
    list I-TR-FIX-LET am* mbody (meaning-nametree->list nt+)
  } {
    list I-FIX-LET am* mbody (meaning-nametree->list nt+)
  }
}

define (meaning-some-dotted-arguments src ae ae* nametree nargs arity flags eenv) {
  am := meaning (mpp ae src) ae nametree (clear-tailp flags) eenv
  am* := meaning-dotted-arguments src ae* nametree nargs arity flags eenv
  rank := nargs - ((length ae*) + 1)

  if (rank lt arity) {
    list I-STORE-ARGUMENT am am* rank
  } {
    list I-LIST-ARGUMENT am am* arity
  }
}

define (meaning-no-dotted-argument src nametree nargs arity flags eenv) {
  list I-ALLOCATE-FRAME arity
}

define (meaning-dotted-arguments src ae* nametree nargs arity flags eenv) {
  if (pair? ae*) {
    meaning-some-dotted-arguments src (ph ae*) (pt ae*) nametree nargs arity flags eenv
  } {
    meaning-no-dotted-argument src nametree nargs arity flags eenv
  }
}

define (meaning-dotted-closed-application src formal* vararg body ae* nametree flags eenv) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am* := meaning-dotted-arguments src ae* nametree (length ae*) (length formal*) (clear-tailp flags) eenv

  fix-formal* := append formal* (list vararg)
  nt+ := meaning-nametree-extend-vparams nametree fix-formal*

  mbody := meaning-sequence (mpp body src) body nt+ flags 'begin eenv

  if (eval-flags-tailp flags) {
    list I-TR-FIX-LET am* mbody (meaning-nametree->list nt+)
  } {
    list I-FIX-LET am* mbody (meaning-nametree->list nt+)
  }
}

define (meaning-closed-application src fe ae* nametree flags eenv) {
  ;; ((function ...) args)
  ;;
  ;; fe		~ (function ...)
  ;; (ph fe)	~ 'function
  ;; (pt fe)	~ ...		~ (formals* body)
  ;; (pht fe)	~ formals*
  ;; (ptt fe)	~ (body)

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction

  ;; unlike meaning-abstraction above, we need to check the arguments
  ;; being supplied at the same time

  formal* := pht fe

  formals-loop :+ function (f* a* fixed-args) {
    (cond
     ((pair? f*) {
       if (pair? a*) {
	 formals-loop (pt f*) (pt a*) (pair (ph f*) fixed-args)
       } {
	 ;; Test Cases:
	 ;; evaluation-errors/closed-function-not-enough-args-{0,1}.idio

	 ;; ((function (x) x) )
	 ;; (function (x y) x) 1

	 ;; XXX Note that in the first case we must wrap the putative
	 ;; ``func-defn args`` in parens otherwise we're simply
	 ;; writing ``func-defn`` which defines and immediately throws
	 ;; away the function.

	 ;; In the second case the system can see there's an arg!
	 meaning-evaluation-error src "closed function: not enough arguments" (list formal* ae*)
       }
     })
     ((null? f*) {
       if (null? a*) {
	 meaning-nametree-extend-locals nametree formal*
	 meaning-fix-closed-application fe formal* (ptt fe) ae* nametree flags eenv
       } {
	 ;; Test Cases:
	 ;; evaluation-errors/closed-function-too-many-args-{0,1}.idio

	 ;; (function () 1) 2
	 ;; (function (x) x) 1 2
	 meaning-evaluation-error src "closed function: too many arguments" (list formal* ae*)
       }
     })
     (else (meaning-dotted-closed-application fe (reverse! fixed-args) f* (ptt fe) ae* nametree flags eenv)))
  }

  formals-loop formal* ae* #n
}

define (meaning-local-application src n ae body nametree flags eenv) {
  body = meaning-rewrite-body (mpp body src) body nametree
  meaning-copy-src-properties src body

  am := meaning (mpp ae src) ae nametree (clear-tailp flags) eenv

  nt+ := meaning-nametree-extend-locals nametree (list n)

  mbody := meaning-sequence (mpp body src) body nt+ flags 'begin eenv

  ll := meaning-lexical-lookup src nt+ n

  list I-LOCAL src (phtt ll) am mbody (meaning-nametree->list nt+)
}

#*

We used to follow LiSP and specialise PRIMCALLn with PRIMCALLn_X but
in practice we should just call the primitives and save a run around
with frames etc.

One thing we need to be leery of is ensuring that we set the *func*
register -- which would have been done by the full function call
protocol.

The problem here is incredibly subtle.  We had relied on the *func*
register being reset with every (true) function call which meant that
after a continuation had been called then the continuation's value
would have been flushed away by the next function call.

If we don't do that with primitive calls then we can leave a
continuation lying around in *func* which means it won't get GC'd and
in turn the values in that continuation's embedded stack won't get
GC'd.

It just so happens that our "use all the file descriptors" test will
have had the array of file descriptors on the stack of the wrappering
continuation (via the saved *frame*?).  If we don't flush the
continuation from *func* then the array of fds won't get flushed and
we won't get to use any more file descriptors.  Not ideal.

Need to figure out run-in-thread too...

*#

define (meaning-primitive-application src fe ae* nametree flags arity si vi eenv) {
  primdata := vm-values-ref vi 0
  pd-vi := si

  if (not (primitive? primdata)) {
    error/type ^rt-parameter-value-error 'meaning-primitive-application "bad vi?" vi primdata
  }

  if (primitive-varargs? primdata) {
    ;; only a full function call protocol can cope with varargs!
    meaning-regular-application src fe ae* nametree flags eenv
  } {
    name := primitive-name primdata

    i-code := #f

    (case arity
     ((0) {
       i-code = list I-PRIMCALL0 src A-PRIMCALL0 pd-vi
     })
     ((1) {
       m1 := meaning (mpp (ph  ae*) src) (ph  ae*) nametree (clear-tailp flags) eenv

       i-code = list I-PRIMCALL1 src A-PRIMCALL1 m1 pd-vi
     })
     ((2) {
       m1 := meaning (mpp (ph  ae*) src) (ph  ae*) nametree (clear-tailp flags) eenv
       m2 := meaning (mpp (pht ae*) src) (pht ae*) nametree (clear-tailp flags) eenv

       ;; XXX run-in-thread?
       i-code = list I-PRIMCALL2 src A-PRIMCALL2 m1 m2 pd-vi
     }))

    if i-code i-code {
      meaning-regular-application src fe ae* nametree flags eenv
    }
  }
}

define (meaning-regular-application src fe ae* nametree flags eenv) {
  fm := #n
  if (symbol? fe) {
    fm = meaning-function-reference src fe nametree flags eenv
  } {
    fm = meaning fe fe nametree (clear-tailp flags) eenv
  }

  am* := meaning-arguments src ae* nametree (length ae*) (clear-tailp flags) eenv

  if (eval-flags-tailp flags) {
    list I-TR-REGULAR-CALL src fm am*
  } {
    list I-REGULAR-CALL src fm am*
  }
}

define (meaning-application src fe ae* nametree flags eenv) {
  i-code := #f

  ;; check for a primitive
  if (symbol? fe) {
    si := meaning-variable-info src nametree fe (set-scope 'toplevel flags) eenv

    if (pair? si) {
      scope := si-scope si

      if (eq? 'predef scope) {
	;; we used the running vi of the primitive whereas the code
	;; generator should use si for pre-compilation
	primdata := symbol-value fe (%eenv-module eenv)

	arity := primitive-arity primdata
	n-args := length ae*

	if (or (and (primitive-varargs? primdata)
		    (n-args ge arity))
	    (n-args eq arity)) {
	  i-code = meaning-primitive-application src fe ae* nametree flags arity (si-si si) (si-vi si) eenv
	} {
	  ;; Test Case: evaluation-errors/primitive-arity.idio

	  ;; pair 1
	  meaning-evaluation-error src "wrong arity for primitive" (list fe ae*)
	}
      }
    }
  }

  if i-code i-code {
    ;; check for a closed application
    if (and (pair? fe)
	    (or (eq? 'function (ph fe))
		(eq? 'function/name (ph fe)))) {
      ;; check for a documentation string and forge one to
      ;; help debugging
      if (not (string? (phtt fe))) {
	fe = append (list (ph fe) (pht fe) (sprintf "closed application: %s" (pht fe))) (ptt fe)
      }
      meaning-copy-src-properties src fe

      meaning-closed-application src fe ae* nametree flags eenv
    } {
      if (pair? fe) {
	;; (symbol-value 'load 'Idio) filename
	meaning-copy-src-properties src fe
      }
      meaning-regular-application src fe ae* nametree flags eenv
    }
  }
}

define (meaning-dynamic-reference src name nametree flags eenv) {
  meaning-reference src name nametree (set-scope 'dynamic flags) eenv
}

define (meaning-dynamic-let src name e e+ nametree flags eenv) {
  m := meaning (mpp e src) e nametree (clear-tailp flags) eenv

  si := meaning-find-symbol-recurse name eenv 'dynamic #t

  sym-idx := #f

  sym-idx = si-si si

  nt+ := meaning-nametree-dynamic-extend nametree name sym-idx 'dynamic

  m+ := meaning-sequence src e+ nt+ (clear-tailp flags) 'begin eenv

  dynamic-wrap := (list (list I-PUSH-DYNAMIC sym-idx m)
			m+
			(list I-POP-DYNAMIC))

  (list (list I-SYM-DEF name 'dynamic sym-idx)
	dynamic-wrap)
}

define (meaning-dynamic-unset src name e+ nametree flags eenv) {
  meaning-dynamic-let src name (undef) e+ nametree flags eenv
}

define (meaning-environ-reference src name nametree flags eenv) {
  meaning-reference src name nametree (set-scope 'environ flags) eenv
}

define (meaning-environ-let src name e e+ nametree flags eenv) {
  m := meaning (mpp e src) e nametree (clear-tailp flags) eenv

  si := meaning-find-symbol-recurse name eenv 'environ #t

  sym-idx := #f

  sym-idx = si-si si

  nt+ := meaning-nametree-dynamic-extend nametree name sym-idx 'environ

  m+ := meaning-sequence src e+ nt+ (clear-tailp flags) 'begin eenv

  environ-wrap := (list (list I-PUSH-ENVIRON sym-idx m)
			m+
			(list I-POP-ENVIRON))

  (list (list I-SYM-DEF name 'environ sym-idx)
	environ-wrap)
}

define (meaning-environ-unset src name e+ nametree flags eenv) {
  meaning-environ-let src name (undef) e+ nametree flags eenv
}

define (meaning-computed-reference src name nametree flags eenv) {
  meaning-reference src name nametree (set-scope 'computed flags) eenv
}

;; (trap condition       handler body ...)
;; (trap (condition ...) handler body ...)
;;
;; This is a bit complicated as condition can be a list.  For each
;; condition in the list we want to use *the same* handler code.  So
;; our intermediate code wants to leave the closure for the handler in
;; *val* then have a sequence of "PUSH-TRAP n" statements all re-using
;; the handler in *val* then the body code then a matching sequence of
;; POP-TRAP statements.
define (meaning-trap src ce he be nametree flags eenv) {
  he = meaning-rewrite-body (mpp he src) he nametree
  meaning-copy-src-properties src he

  hm := meaning (mpp he src) he nametree (clear-tailp flags) eenv

  ;; if the condition expression is not a list then make it one
  if (not (pair? ce)) {
    ce = list ce
  }

  ;; For each condition, resolve/discover the condition's name then
  ;; build pushs with the fci.

  ;; pushs is now the the reverse order of ce

  pushs := #n
  pops := #n

  c-loop :+ function (c*) {
    if (null? c*) #n {
      c-sym := ph c*

      ci := #f

      si := meaning-find-symbol-recurse c-sym eenv 'toplevel #t
      sym-idx = si-si si

      pushs = pair (list I-PUSH-TRAP sym-idx) pushs
      pops = pair (list I-POP-TRAP) pops

      c-loop (pt c*)
    }
  }

  c-loop ce

  be = meaning-rewrite-body (mpp be src) be nametree
  meaning-copy-src-properties src be

  bm := meaning-sequence (mpp be src) be nametree (clear-tailp flags) 'begin eenv

  append (list hm) pushs (list bm) pops
}

define (meaning-escape-block src label be nametree flags eenv) {
  ci := meaning-constants-lookup-or-extend eenv label

  be = meaning-rewrite-body (mpp be src) be nametree
  meaning-copy-src-properties src be

  escapes-eenv := copy-value eenv 'shallow
  set-%eenv-escapes! escapes-eenv (pair label (%eenv-escapes eenv))

  bm := meaning-sequence (mpp be src) be nametree (clear-tailp flags) 'begin escapes-eenv

  (list (list I-PUSH-ESCAPER ci bm)
	(list I-POP-ESCAPER))
}

define (meaning-escape-from src label ve nametree flags eenv) {
  if (not (memq label (%eenv-escapes eenv))) {
    meaning-error-static-unbound src label
  }

  ci := meaning-constants-lookup-or-extend eenv label

  vm := meaning (mpp ve src) ve nametree (clear-tailp flags) eenv

  list I-ESCAPER-LABEL-REF ci vm
}

define (meaning-escape-label src label ve nametree flags eenv) {
  if (not (memq label (%eenv-escapes eenv))) {
    meaning-error-static-unbound src label
  }

  ci := meaning-constants-lookup-or-extend eenv label

  if (pair? ve) {
    ve = ph ve
  } {
    ve = (void)
  }

  vm := meaning (mpp ve src) ve nametree (clear-tailp flags) eenv

  list I-ESCAPER-LABEL-REF ci vm
}

;; XXX is this the C code's "load e"?
define (evaluate-include-file fh eenv) {
  e := Idio/read fh
  if (not (eof? fh)) {
    m := evaluate e eenv
    pc := codegen m eenv
    ;r := vm-run (current-thread) pc
    evaluate-include-file fh eenv
  }
}

define (meaning-include src e nametree flags eenv) {
  lib := (find-lib e)
  load lib

  ;; we need to return some meaning
  list I-NOP
}

define (meaning-expander src e nametree flags eenv) {
  te := expander/template-expand e
  meaning-copy-src-properties src te

  meaning te te nametree flags eenv
}

define (meaning src e nametree flags eenv) {
  if (pair? e) {
    he := ph e
    te := pt e

    (case he
     ((begin \and \or) {
       if (pair? te) {
	 meaning-sequence src te nametree flags he eenv
       } {
	 (case he
	  ((begin) (meaning src (void) nametree flags eenv))
	  ((and)   (meaning src #t     nametree flags eenv))
	  ((or)    (meaning src #f     nametree flags eenv))
	  (else
	   ;; can we even get here?
	   (meaning-evaluation-error src "unexpected sequence keyword" he)))
       }
     })

     ((not) {
       if (pair? te) {
	 if (pair? (pt te)) {
	   ;; Test Case: evaluation-errors/not-multiple-args.idio

	   ;; (not 1 2)
	   meaning-error-param src "too many arguments" te
	 } {
	   meaning-not src (ph te) nametree flags eenv
	 }
       } {
	 ;; Test Case: evaluation-errors/not-nil.idio

	 ;; (not)
	 meaning-error-param src "no argument" he
       }
     })

     ((escape) {
       if (pair? te) {
	 if (pair? (pt te)) {
	   ;; Test Case: evaluation-errors/escape-multiple-args.idio

	   ;; (escape 1 2)
	   meaning-error-param src "too many arguments" te
	 } {
	   meaning-escape src (ph te) nametree flags eenv
	 }
       } {
	 ;; Test Case: evaluation-errors/escape-nil.idio

	 ;; (escape)
	 meaning-error-param src "no argument" he
       }
     })

     ((quote) {
       if (pair? te) {
	 if (pair? (pt te)) {
	   ;; Test Case: evaluation-errors/quote-multiple-args.idio

	   ;; (quote 1 2)
	   meaning-error-param src "too many arguments" te
	 } {
	   meaning-quotation src (ph te) nametree flags
	 }
       } {
	 ;; Test Case: evaluation-errors/quote-nil.idio

	 ;; (quote)

	 ;; XXX is (quote) actually '#n ??
	 meaning-error-param src "no argument" he
       }
     })

     ((quasiquote) {
       if (pair? te) {
	 if (pair? (pt te)) {
	   ;; Test Case: evaluation-errors/quasiquote-multiple-args.idio

	   ;; (quasiquote 1 2)
	   meaning-error-param src "too many arguments" te
	 } {
	   meaning-quasiquotation src (ph te) nametree flags eenv
	 }
       } {
	 ;; Test Case: evaluation-errors/quasiquote-nil.idio

	 ;; (quasiquote)
	 meaning-error-param src "no argument" he
       }
     })

     ((function) {
       ;; (function bindings [docstr] body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   htte := ph tte
	   ttte := pt tte
	   if (and (string? htte)
		   (not (null? ttte))) {
	     ;; (function bindings "docstr" body ...)
	     meaning-abstraction src (gensym 'anon) (ph te) htte ttte nametree flags eenv
	   } {
	     ;; (function bindings body ...)
	     ;; (function bindings "...")

	     ;; The second is a function whose body is a
	     ;; string

	     meaning-abstraction src (gensym 'anon) (ph te) #n tte nametree flags eenv
	   }
	 } {
	   ;; Test Case: evaluation-errors/function-nil.idio

	   ;; (function bindings)
	   meaning-error-param src "no body" he
	 }
       } {
	 ;; Test Case: evaluation-errors/function-nil.idio

	 ;; (function)
	 meaning-error-param src "no arguments" he
       }
     })

     ((function/name) {
       ;; (function/name name bindings [docstr] body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   htte := ph tte
	   ttte := pt tte
	   if (pair? ttte) {
	     httte := ph ttte
	     tttte := pt ttte
	     if (and (string? httte)
		     (not (null? tttte))) {
	       ;; (function/name name bindings "docstr" body ...)
	       meaning-abstraction src (ph te) htte httte tttte nametree flags eenv
	     } {
	       ;; (function/name name bindings body ...)
	       ;; (function/name name bindings "...")

	       ;; The second is a function whose body is a
	       ;; string

	       meaning-abstraction src (ph te) htte #n ttte nametree flags eenv
	     }
	   } {
	     ;; Test Case: evaluation-errors/function-no-body.idio

	     ;; (function/name name bindings)
	     meaning-error-param src "no body" he
	   }
	 } {
	   ;; Test Case: evaluation-errors/function-no-bindings.idio

	   ;; (function/name name)
	   meaning-error-param src "no bindings" he
	 }
       } {
	 ;; Test Case: evaluation-errors/function-nil.idio

	 ;; (function)
	 meaning-error-param src "no arguments" he
       }
     })

     ((function+) {
       ;; (function+ var val body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   ttte := pt tte
	   if (pair? ttte) {
	     ;; (function+ var val body ...)
	     meaning-local-application src (ph te) (ph tte) ttte nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/function+-no-body.idio

	     ;; (function+ var val)
	     meaning-error-param src "no body" he
	   }
	 } {
	   ;; Test Case: evaluation-errors/function+-no-val.idio

	   ;; (function+ var)
	   meaning-error-param src "no value" he
	 }
       } {
	 ;; Test Case: evaluation-errors/function+-nil.idio

	 ;; (function+)
	 meaning-error-param src "no arguments" he
       }
     })

     ((if) {
       ;; (if condition consequent alternative)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   ttte := pt tte
	   httte := (void)		; default: (if #f e) -> #void
	   if (pair? ttte) {
	     httte = ph ttte
	   }
	   meaning-alternative src (ph te) (ph tte) httte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/if-cond-nil.idio

	   ;; (if 1)
	   meaning-error-param src "no consequent/alternative" e
	 }
       } {
	 ;; Test Case: evaluation-errors/if-nil.idio

	 ;; (if)
	 meaning-error-param src "no arguments" he
       }
     })

     ((cond) {
       ;; (cond clause ...)
       if (pair? te) {
	 ;; What was I thinking here...
	 if (null? (pt te)) {
	   hte := ph te
	   if (and (pair? hte)
		   (eq? 'block (ph hte))) {
	     ;; (cond )
	     te = pt hte
	   }
	 }

	 ce := meaning-rewrite-cond e (mpp te src) te
	 meaning-copy-src-properties src ce

	 meaning ce ce nametree flags eenv
       } {
	 ;; Test Case: evaluation-errors/cond-nil.idio

	 ;; (cond)
	 meaning-error-param src "no clauses" he
       }
     })

     ((set! \=) {
       ;; (set! var expr)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-assignment src (ph te) (ph tte) nametree (set-scope 'toplevel flags) eenv
	 } {
	   ;; Test Case: evaluation-errors/set-symbol-nil.idio

	   ;; (set! x )
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/set-nil.idio

	 ;; (set!)
	 meaning-error-param src "no arguments" he
       }
     })

     ((define-template) {
       ;; (define-template bindings [doc] body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define-template src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/define-template-bindings-nil.idio

	   ;; define-template (m)
	   meaning-error-param src "no body" e
	 }
       } {
	 ;; Test Case: evaluation-errors/define-template-nil.idio

	 ;; (define-template)
	 meaning-error-param src "no arguments" he
       }
     })

     ((define-infix-operator) {
       ;; (define-infix-operator sym pri body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   ttte := pt tte
	   if (pair? ttte) {
	     meaning-define-infix-operator src (ph te) (ph tte) (ph ttte) nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/define-infix-op-symbol-pri-nil.idio

	     ;; define-infix-operator sym pri
	     meaning-error-param src "no body" e
	   }
	 } {
	   ;; Test Case: evaluation-errors/define-infix-op-symbol-nil.idio

	   ;; define-infix-operator sym
	   meaning-error-param src "no pri body" e
	 }
       } {
	 ;; Test Case: evaluation-errors/define-infix-op-nil.idio

	 ;; (define-infix-operator)
	 meaning-error-param src "no arguments" e
       }
     })

     ((define-postfix-operator) {
       ;; (define-postfix-operator sym pri body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   ttte := pt tte
	   if (pair? ttte) {
	     meaning-define-postfix-operator src (ph te) (ph tte) (ph ttte) nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/define-postfix-op-symbol-pri-nil.idio

	     ;; define-postfix-operator sym pri
	     meaning-error-param src "no body" e
	   }
	 } {
	   ;; Test Case: evaluation-errors/define-postfix-op-symbol-nil.idio

	   ;; define-postfix-operator sym
	   meaning-error-param src "no pri body" e
	 }
       } {
	 ;; Test Case: evaluation-errors/define-postfix-op-nil.idio

	 ;; (define-postfix-operator)
	 meaning-error-param src "no arguments" e
       }
     })

     ((define) {
       ;; (define var expr)
       ;; (define bindings body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/define-sym-nil.idio

	   ;; define sym
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/define-nil.idio

	 ;; (define)
	 meaning-error-param src "no arguments" he
       }
     })

     ((:=) {
       ;; (:= var expr)
       ;; (:= bindings body ...)

       ;; (:= vars expr)	;; ?? cf. let-values (call-with-values producer consumer)

       ;; in the short term => define
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/toplevel-define-sym-nil.idio

	   ;; := sym

	   ;; XXX can't do ``sym :=`` as you'll get the EOF in
	   ;; list error from the reader
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/toplevel-define-nil.idio

	 ;; (:=)
	 meaning-error-param src "no arguments" he
       }
     })

     ((:*) {
       ;; (:* var expr)

       ;; in the short term => define-environ
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define-environ src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/environ-define-sym-nil.idio

	   ;; :* sym

	   ;; XXX can't do ``sym :*`` as you'll get the EOF in
	   ;; list error from the reader
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/environ-define-nil.idio

	 ;; (:*)
	 meaning-error-param src "no arguments" he
       }
     })

     ((:~) {
       ;; (:~ var expr)

       ;; in the short term => define-dynamic
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define-dynamic src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/dynamic-define-sym-nil.idio

	   ;; :~ sym

	   ;; XXX can't do ``sym :~`` as you'll get the EOF in
	   ;; list error from the reader
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/dynamic-define-nil.idio

	 ;; (:~)
	 meaning-error-param src "no arguments" he
       }
     })

     ((:$) {
       ;; (:$ var getter setter)
       ;; (:$ var getter)

       ;; in the short term => define-computed
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-define-computed src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/computed-define-sym-nil.idio

	   ;; :$ sym

	   ;; XXX can't do ``sym :$`` as you'll get the EOF in
	   ;; list error from the reader
	   meaning-error-param src "no getter [setter]" e
	 }
       } {
	 ;; Test Case: evaluation-errors/computed-define-nil.idio

	 ;; (:$)
	 meaning-error-param src "no arguments" he
       }
     })

     ((block) {
       ;; { ... }
       if (pair? te) {
	 meaning-block src te nametree flags eenv
       } {
	 meaning-warning "meaning" "empty body for block => void" src
	 meaning src (void) nametree flags eenv
       }
     })

     ((dynamic) {
       ;; (dynamic var)
       if (pair? te) {
	 meaning-dynamic-reference src (ph te) nametree flags eenv
       } {
	 ;; Test Case: evaluation-errors/dynamic-nil.idio

	 ;; (dynamic)
	 meaning-error-param src "no argument" he
       }
     })

     ((dynamic-let) {
       ;; (dynamic-let (var expr) body)
       if (pair? te) {
	 hte := ph te
	 if (pair? hte) {
	   thte := pt hte
	   if (pair? thte) {
	     meaning-dynamic-let src (ph hte) (ph thte) (pt te) nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/dynamic-let-bindings-not-tuple.idio

	     ;; dynamic-let (d)
	     meaning-error-param src "bindings not a tuple" e
	   }
	 } {
	   ;; Test Case: evaluation-errors/dynamic-let-bindings-not-pair.idio

	   ;; dynamic-let #n
	   meaning-error-param src "bindings not a pair" e
	 }
       } {
	 ;; Test Case: evaluation-errors/dynamic-let-nil.idio

	 ;; (dynamic-let)
	 meaning-error-param src "no arguments" he
       }
     })

     ((dynamic-unset) {
       ;; (dynamic-unset var body)
       if (pair? te) {
	 hte := ph te
	 if (symbol? hte) {
	   meaning-dynamic-unset src hte (pt te) nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/dynamic-unset-non-sym.idio

	   ;; dynamic-unset 1
	   meaning-error-param src "not a symbol" e
	 }
       } {
	 ;; Test Case: evaluation-errors/dynamic-unset-nil.idio

	 ;; (dynamic-unset)
	 meaning-error-param src "no arguments" he
       }
     })

     ((environ-let) {
       ;; (environ-let (var expr) body)
       if (pair? te) {
	 hte := ph te
	 if (pair? hte) {
	   thte := pt hte
	   if (pair? thte) {
	     meaning-environ-let src (ph hte) (ph thte) (pt te) nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/environ-let-bindings-not-tuple.idio

	     ;; environ-let (d)
	     meaning-error-param src "bindings not a tuple" e
	   }
	 } {
	   ;; Test Case: evaluation-errors/environ-let-bindings-not-pair.idio

	   ;; environ-let #n
	   meaning-error-param src "bindings not a pair" e
	 }
       } {
	 ;; Test Case: evaluation-errors/environ-let-nil.idio

	 ;; (environ-let)
	 meaning-error-param src "no arguments" he
       }
     })

     ((environ-unset) {
       ;; (environ-unset var body)
       if (pair? te) {
	 hte := ph te
	 if (symbol? hte) {
	   meaning-environ-unset src hte (pt te) nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/environ-unset-non-sym.idio

	   ;; environ-unset 1
	   meaning-error-param src "not a symbol" e
	 }
       } {
	 ;; Test Case: evaluation-errors/environ-unset-nil.idio

	 ;; (environ-unset)
	 meaning-error-param src "no arguments" he
       }
     })

     ((%trap) {
       ;; (trap condition		handler body ...)
       ;; (trap (condition ...)	handler body ...)
       ;;
       ;; NB {trap}, itself, is a syntax trasformer, partly to allow
       ;; (trap ...) to be wrapped in a prompt-at giving us
       ;; trap-return.  All of that means that we need a distinct
       ;; symbol, %trap, to be the special form.
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   ttte := pt tte
	   if (pair? ttte) {
	     meaning-trap src (ph te) (ph tte) ttte nametree flags eenv
	   } {
	     ;; Test Case: evaluation-errors/trap-condition-handler-nil.idio

	     ;; trap condition handler
	     meaning-error-param src "no body" e
	   }
	 } {
	   ;; Test Case: evaluation-errors/trap-condition-nil.idio

	   ;; trap condition
	   meaning-error-param src "no handler" e
	 }
       } {
	 ;; Test Case: evaluation-errors/trap-nil.idio

	 ;; (trap)
	 meaning-error-param src "no arguments" he
       }
     })

     ((escape-block) {
       ;; (escape-block label body ...)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-escape-block src (ph te) tte nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/escape-block-condition-nil.idio

	   ;; escape-block label
	   meaning-error-param src "no body" e
	 }
       } {
	 ;; Test Case: evaluation-errors/escape-block-nil.idio

	 ;; (escape-block)
	 meaning-error-param src "no arguments" he
       }
     })

     ((escape-from) {
       ;; (escape-from label val)
       if (pair? te) {
	 tte := pt te
	 if (pair? tte) {
	   meaning-escape-from src (ph te) (ph tte) nametree flags eenv
	 } {
	   ;; Test Case: evaluation-errors/escape-from-condition-nil.idio

	   ;; escape-from condition
	   meaning-error-param src "no value" e
	 }
       } {
	 ;; Test Case: evaluation-errors/escape-from-nil.idio

	 ;; (escape-from)
	 meaning-error-param src "no arguments" he
       }
     })

     ((include) {
       ;; (include filename)
       if (pair? te) {
	 meaning-include src (ph te) nametree flags eenv
       } {
	 ;; Test Case: evaluation-errors/include-nil.idio

	 ;; (include)
	 meaning-error-param src "no argument" he
       }
     })

     ((template-expand) {
       ;; (template-expand expr)
       if (pair? te) {
	 ;; skip the evaluation middle-man and just call
	 ;; template-expand directly

	 ;; XXX *apply* template-expand, here, otherwise, when the C
	 ;; evaluator is evaluating this file and tries to evaluate
	 ;; "template-expand te" it recognises the first word,
	 ;; {template-expand}, as its own special form
	 ;; {template-expand} rather than the function
	 ;; {template-expand}.
	 apply template-expand te
       } {
	 ;; Test Case: evaluation-errors/template-expand-nil.idio

	 ;; (template-expand)
	 meaning-error-param src "no argument" he
       }
     })

     (else {
       ;; not a special form

       ;; check if {he} is a symbol and if so, if it has been
       ;; flagged as an expander

       ;; otherwise it is a derived form, ie. an application
       if (symbol? he) {
	 si := meaning-variable-info src nametree he (set-scope 'toplevel flags) eenv

	 if (and si
		 (expander? he)) {
	   meaning-expander src e nametree flags eenv
	 } {
	   meaning-copy-src-properties src e
	   meaning-application e he te nametree flags eenv
	 }
       } {
	 meaning-copy-src-properties src e
	 meaning-application e he te nametree flags eenv
       }
     }))
  } {
    ;; {e} is not a pair so is mostly a constant unless it is a symbol
    ;; in which case (de-)reference it
    (cond ((or (fixnum? e)
	       (unicode? e)
	       (boolean? e)
	       (null? e)
	       (string? e)
	       (keyword? e)
	       (array? e)
	       (hash? e)
	       (bignum? e)
	       (bitset? e)
	       (struct-instance? e)
	       (void? e)
	       (undef? e))
	    (meaning-quotation src e nametree flags))
     ((symbol? e) {
       meaning-reference src e nametree (set-scope 'toplevel flags) eenv
     })
     (else
      ;; anything else is something the user shouldn't be dealing
      ;; with!
      idio-dump e
      eprintf "unexpected expression: %s\n" e
      eprintf "\n\n"
      libc/sleep 10
      (meaning-error-param src "invalid constant type" e)))
  }
}

define (evaluate src & args) "
evaluate Idio source code `src` in the context of evaluation
environment `eenv` and return intermediate code for the code generator

:param src: Idio source code
:type src: Abstract Syntax Tree
:param eenv: evaluation environment, defaults to a new instance
:type eenv: struct-instance, optional

.. seealso: :ref:`%evaluation-environment <evaluate/%evaluation-environment>`
" {
  eenv := #n
  if (pair? args) {
    eenv = ph args
  } {
    eenv = %evaluation-environment "evaluate" #t
  }

  ;; We must call this with the current module.  The previous
  ;; expression (when run) may well have changed the current module.
  set-%eenv-module! eenv (current-module)

  m := meaning src src #n no-flags eenv

  list (list I-PUSH-ABORT m) (list I-POP-ABORT) (list I-RETURN)
}

;; done
provide evaluate
