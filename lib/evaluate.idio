#*

Copyright (c) 2020 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

evaluate.idio

*#

module evaluate
export (
	 evaluate
)
import expander operator codegen threading vm

define (meaning-error-location src) {
  lo := #f
  if (not (null? src)) {
    lo = hash-ref %idio-src-properties src #f
  }

  if lo {
    sprintf "%s:line %d" lo.name lo.line
  } {
    sprintf "<no lexobj>"
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; all evaluation errors are derived from ^evaluation-error
;
; most of the specific errors just add some pertinent text

define (meaning-base-error src msg expr) {
  c := make-condition ^evaluation-error msg (meaning-error-location src) #n expr
  raise c
}

define (meaning-error-param-type src msg expr) {
  meaning-base-error src (sprintf "parameter type: %s" msg) expr
}

define (meaning-error-param src msg expr) {
  meaning-base-error src (sprintf "%s: %s" expr msg) expr
}

define (meaning-evaluation-error src msg expr) {
  meaning-base-error src msg expr
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; some of the various static errors should only occur in broken
; internal code
define (meaning-error-static-redefine src msg name cv new) {
  det := sprintf "%s: %s is currently %s: proposed %s" msg name cv new
  c := make-condition ^st-variable-error msg (meaning-error-location src) det name
  raise c
}

define (meaning-error-static-variable src msg name) {
  c := make-condition ^st-variable-error msg (meaning-error-location src) name name
  raise c
}

define (meaning-error-static-unbound src name) {
  meaning-error-static-variable src "unbound" name
}

define (meaning-error-static-immutable src name) {
  meaning-error-static-variable src "immutable" name
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define (meaning-error-static-primitive-arity src msg f args name primdata) {
  arity := sprintf "%d" (primitive-arity primdata)
  if (primitive-varargs? primdata) {
    arity = append-string arity "*"
  }
  det := sprintf "arity != %s; primitive (%s %s) was called as (%s %@)" arity f (%property f :sigstr) f args
  c := make-condition ^st-function-arity-error msg (meaning-error-location src) det
  raise c
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

define-struct eval-flags tailp scope define
no-flags := make-eval-flags #f #n #f

define (set-tailp flags) {
  make-eval-flags #t flags.scope flags.define
}

define (clear-tailp flags) {
  make-eval-flags #f flags.scope flags.define
}

define (clear-define flags) {
  make-eval-flags flags.tailp flags.scope #f
}

define (set-scope scope flags) {
  make-eval-flags flags.tailp scope flags.define
}

define (define-scope scope flags) {
  make-eval-flags flags.tailp scope #t
}

;; symbol-info is a tuple: (scope ci vi mod creator)

define (meaning-toplevel-extend src name flags cs cm) {
  flag-scope := flags.scope

  si := find-symbol name cm

  if (pair? si) {
    cur-scope := ph si

    if (not (eq? cur-scope flag-scope)) {
      meaning-error-static-redefine src "toplevel-extend: type change" name si flag-scope
    } {
      pht si
    }
  } {
    if (and (eq? flag-scope 'toplevel)
	    (not flags.define)) {
	      eprintf "toplevel-extend: forward reference: %s at %s\n" name (meaning-error-location src)
	      if (not (hash-ref %idio-src-properties src #f)) {
		eprintf "src=%s\n" src
	      }
    }
    ci := codegen-constants-lookup-or-extend cs name

    set-symbol! name (list flag-scope ci 0 cm "meaning-toplevel-extend") cm
  }
}

define (meaning-environ-extend src name val cs) {
  ; environment variables are only defined in 'Idio module
  im := find-module 'Idio

  si := find-symbol name im

  if (pair? si) {
    cur-scope := ph si

    if (not (eq? cur-scope 'environ)) {
      meaning-error-static-redefine src "environ-extend: type change" name si cur-scope
    } {
      pht si
    }
  } {
    ci := codegen-constants-lookup-or-extend cs name
    vi := (vm-extend-values)

    ; module ci/vi ?
    set-symbol! name (list 'environ ci vi im "idio-environ-extend") im
    set-symbol-value! name val im
  }
}

#*

meaning-lexical-lookup

{nametree} is a list of association lists with each association list
representing the names of variables introduced at some level with
newer levels preceding older ones with the effect that at the time of
lookup the innermost level is the first association list and will
therefore be searched first.

local variables for a given level are stashed as (name 'local j) where
{name} is the {j}th variable introduced at that level.

Nominally, you would walk through each "level" of names looking for
your variable name.  If you found it at depth {i} then you can combine
that with the corresponding {j} to give a SHALLOW (for {i} == 0) or
DEEP (for {i} > 0) variable reference.

The return for a local is ('local {i} {j})

It is interspersed with dynamic and environ variables.  They are
one-at-a-time variable introductions and they should not increment
{i}!

The return is, say, ('dynamic {ci}) where {ci} is the constant index
associated with the dynamic/environ variable.

*#
define (meaning-lexical-lookup src nametree name) {
  loop :+ function (nt i) {
	    if (null? nt) #f {
	      names := ph nt

	      if (pair? names) {
		l := assq name names
		if l {
		  scope := pht l	; ({name} 'local {j})
		  (case scope
			((local) (list scope i (phtt l)))
			((dynamic environ) (pt l))
			(else (meaning-error-static-variable src "unexpected local variant" name)))
		} {
		  ;; only bump i if these were local vars
		  if (eq? 'local scope) {
		    loop (pt nt) (i + 1)
		  } {
		    loop (pt nt) i
		  }
		}
	      } {
		loop (pt nt) (i + 1)
	      }
	    }
  }

  loop nametree 0
}

define (meaning-nametree->list nametree) {
  loop :+ function (nt r) {
	    if (null? nt) (reverse r) {
	      loop2 :+ function (names r2) {
			 if (null? names) (reverse r2) {
			   loop2 (pt names) (pair (ph names) r2)
			 }
	      }

	      loop (pt nt) (loop2 (ph nt) #n)
	    }
  }

  loop nametree #n
}

define (meaning-nametree-extend nametree names) {
  i := 0
  loop :+ function (ns r) {
	    if (null? ns) (reverse r) {
	      tuple := list (ph ns) 'local i
	      i = i + 1
	      loop (pt ns) (pair tuple r)
	    }
  }

  pair (loop names #n) nametree
}

define (meaning-nametree-dynamic-extend nametree name index scope) {
  pair (list (list name scope index)) nametree
}

define (meaning-variable-info src nametree name flags cs cm) {
  r := meaning-lexical-lookup src nametree name

  if (not r) {
    r = find-symbol name cm
    if (not r) {
      ; is name M/S ?
      r = symbol-direct-reference name
      if r {
	r = phtt r
	set-symbol! name r cm
      } {
	; not found -> (auto) extend toplevel
	meaning-toplevel-extend src name flags cs cm

	; meaning-toplevel-extend only returns a ci
	r = find-symbol name cm
      }
    }
  }

  r
}

define (meaning-prefer-properties e src) {
  if (and (pair? e)
	  (not (hash-ref %idio-src-properties src #f))) {
    e
  } {
    src
  }
}

mpp := meaning-prefer-properties

define (meaning-copy-src-properties src dst) {
  if (pair? dst) {
    dst-lo := hash-ref %idio-src-properties dst #f
    if (not dst-lo) {
      if (pair? src) {
	src-lo := hash-ref %idio-src-properties src #f
	if src-lo {
	  dst-lo = copy-value src-lo 'shallow
	  dst-lo.expr = dst
	  hash-set! %idio-src-properties dst dst-lo
	}
      }
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; let's find some meaning in all of this!

define (meaning-reference src name nametree flags cs cm) {
  si := meaning-variable-info src nametree name flags cs cm

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := ph si
  i := pht si

  (case scope
	((local) {
	  ; ('local {i} {j})
	  j := phtt si
	  (if (gt 0 i)
	      (list I-DEEP-ARGUMENT-REF i j)
	      (list I-SHALLOW-ARGUMENT-REF j))
	})
	((toplevel) {
	  ; ('toplevel ci vi)
	  vi := phtt si
	  (if (gt 0 vi)
	      (list I-CHECKED-GLOBAL-VAL-REF vi)
	      (list I-GLOBAL-SYM-REF i))
	})
	((dynamic) (list I-DYNAMIC-SYM-REF i))
	((environ) (list I-ENVIRON-SYM-REF i))
	((computed) (list I-COMPUTED-SYM-REF i))
	((predef) {
	  vi := phtt si
	  list I-PREDEFINED vi
	})
	(else {
	  ;; Shouldn't get here unless the if clauses above don't
	  ;; cover everything.  Developer error?
	  meaning-error-static-unbound src name
	}))
}

define (meaning-function-reference src name nametree flags cs cm) {
  si := meaning-variable-info src nametree name flags cs cm

  if (not si) {
    ; shouldn't get here as unknowns are automatically made toplevel
    meaning-error-static-unbound src name
  }

  scope := ph si
  i := pht si

  (case scope
	((local) {
	  ; ('local {i} {j})
	  j := phtt si
	  (if (gt 0 i)
	      (list I-DEEP-ARGUMENT-REF i j)
	      (list I-SHALLOW-ARGUMENT-REF j))
	})
	((toplevel) {
	  ; ('toplevel ci vi)
	  vi := phtt si
	  (if (gt 0 vi)
	      (list I-CHECKED-GLOBAL-FUNCTION-VAL-REF vi)
	      (list I-GLOBAL-FUNCTION-SYM-REF i))
	})
	((dynamic) (list I-DYNAMIC-FUNCTION-SYM-REF i))
	((environ) (list I-ENVIRON-SYM-REF i))
	((computed) (list I-COMPUTED-SYM-REF i))
	((predef) {
	  vi := phtt si
	  list I-PREDEFINED vi
	})
	(else {
	  ;; Shouldn't get here unless the if clauses above don't
	  ;; cover everything.  Developer error?
	  meaning-error-static-unbound src name
	}))
}

define (meaning-escape src e nametree flags cs cm) {
  meaning (mpp e src) e nametree flags cs cm
}

define (meaning-quotation src v nametree flags) {
  list I-CONSTANT-SYM-REF v
}

; a couple of helper functions from Alan Bawden's Quasiquotation in
; Lisp paper -- reworked slightly

define (eps-qq-expand-list e) {
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		#T{ (list $(pht e)) })
	  ((eq? 'unquotesplicing sym)	(pht e))
	  ((eq? 'quasiquote sym)	(eps-qq-expand-list
					 (eps-qq-expand (pht e))))
	  (else				#T{ (list (append
						   $(eps-qq-expand-list (ph e))
						   $(eps-qq-expand (pt e)))) }))
  } {
    #T{ '($e) }
  }
}

define (eps-qq-expand e) {
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		(pht e))
	  ((eq? 'unquotesplicing sym)	(error 'eps-qq-expand "illegal"))
	  ((eq? 'quasiquote sym)	(eps-qq-expand
					 (eps-qq-expand (pht e))))
	  (else				#T{ (append $(eps-qq-expand-list (ph e))
						    $(eps-qq-expand (pt e))) }))
  } {
    #T{ '$e }
  }
}

define (qq-expand e) {
  eps-qq-expand e
}

define (qq-expand-list/verbose e c) {
  printf " %-10s > qel p?=%s e=%s\n" c (pair? e) e
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		(list 'list (pht e)))
	  ((eq? 'unquotesplicing sym)	(pht e))
	  ((or (eq? 'quasiquote sym)
	       (eq? 'qq sym))		(qq-expand-list/verbose
					 (qq-expand/verbose (pht e) "qel qq i")
					 "qel qq o"))
	  (else				(list 'list (list 'append (qq-expand-list/verbose (ph e) "qel e qel")
								  (qq-expand/verbose (pt e) "qel e qe")))))
  } {
    (list 'quote (list e))
  }
}

define (qq-expand/verbose e c) {
  printf " %-10s > qe  p?=%s e=%s\n" c (pair? e) e
  if (pair? e) {
    sym := ph e
    (cond ((eq? 'unquote sym)		(pht e))
	  ((eq? 'unquotesplicing sym)	(error 'qq-expand/verbose "illegal"))
	  ((or (eq? 'quasiquote sym)
	       (eq? 'qq sym))		(qq-expand/verbose
					 (qq-expand/verbose (pht e) "qe qq i")
					 "qe qq o"))
	  (else				(list 'append (qq-expand-list/verbose (ph e) "qe e qel")
						      (qq-expand/verbose (pt e) "qe e qe"))))
  } {
    (list 'quote e)
  }
}

define (qq-expand/verbose e) {
  qq-expand/verbose e "repl"
}

define (STklos-backquotify e level) {
  printf "              bq    p?=%s e=%s\n" (pair? e) e
  (cond
   ((pair? e)
    (cond
     ((eq? (ph e) 'quasiquote)
      (list 'list ''quasiquote
		  (STklos-backquotify (pht e) (+ level 1))))
     ((eq? (ph e) 'unquote)
      (if (le level 0)
	  (pht e)
	  (list 'list ''unquote
		      (STklos-backquotify (pht e) (- level 1)))))
     ((eq? (ph e) 'unquotesplicing)
      (if (le level 0)
	  (list 'pair
		(STklos-backquotify (ph e) level)
		(STklos-backquotify (pt e) level))
	  (list 'list ''unquotesplicing
		      (STklos-backquotify (pht e) (- level 1)))))
     ((and (le level 0) (pair? (ph e)) (eq? (phh e) 'unquotesplicing))
      (if (null? (pt e))
	  (phth e)
	  (list 'append (phth e)
                        (STklos-backquotify (pt e) level))))
     (else
      (list 'pair
	    (STklos-backquotify (ph e) level)
	    (STklos-backquotify (pt e) level)))))
   ((symbol? e)
    (list 'quote e))
   (else
    e))
}

define (STklos-expand e) {
  STklos-backquotify e 0
}

define (meaning-quasiquotation src e nametree flags cs cm) {
  ee := qq-expand e

  meaning src ee nametree flags cs cm
}

define (meaning-alternative src e1 e2 e3 nametree flags cs cm) {
  m1 := meaning (mpp e1 src) e1 nametree (clear-tailp flags) cs cm
  m2 := meaning (mpp e2 src) e2 nametree flags cs cm
  m3 := meaning (mpp e3 src) e3 nametree flags cs cm

  list I-ALTERNATIVE m1 m2 m3
}

#*

validate & rewrite the cond clauses, {clauses}, noting the special
cases of {=>}, {else}

*#

define (meaning-rewrite-cond prev src clause*) {
  (cond ((null? clause*) (void))

	((not (pair? clause*))
	 ;; Shouldn't get here, eg. "(cond)", as we test that the cond
	 ;; clause* are a pair in the main idio_meaning loop.
	 (meaning-evaluation-error src "cond: no clauses" clause*))

	((not (pair? (ph clause*))) {
	  if (and (pair? (pt clause*))
		  (pair? (pht clause*))) {
		    ;; Test Cases:
		    ;; evaluation-errors/rewrite-cond-isa-pair-only.idio
		    ;; evaluation-errors/rewrite-cond-isa-pair-before.idio
		    ;; evaluation-errors/rewrite-cond-isa-pair-after.idio

		    ;; cond #t
		    ;; cond #t (#f 1)
		    ;; cond (#f 1) #t
		    meaning-error-param-type (pht clause*) "cond: clause is not a pair (before)" clause*
		  } {
		    ;; Test Case: ??
		    meaning-error-param-type prev "cond: clause is not a pair (in/after)" clause*
		  }
	})

	((eq? 'else (phh clause*)) {
	  if (null? (pt clause*)) {
	    c* := append (list 'begin) (pth clause*)
	    meaning-copy-src-properties (mpp (pth clause*) src) c*
	    c*
	  } {
	    ;; Test Case: evaluation-errors/rewrite-cond-else-not-last.idio

	    ;; cond (else 1) (#t 2)
	    meaning-evaluation-error (ph clause*) "cond: else not in last clause" clause*
	  }
	})

	((and (pair? (pth clause*))
	      (eq? '=> (phth clause*))) {
		;; XXX We've just accessed the {phth clause*} so *of
		;; course* it's a list...the only useful thing we're
		;; doing here is checking there's explicitly three
		;; elements.

		ph-clause* := ph clause*

		if (and (list? ph-clause*)
			(eq 3 (length ph-clause*))) {
			  ;; The {=>} operator is a bit of a
			  ;; Scheme-ism in that the clause says {(c =>
			  ;; f)} and means that if {c} is true then
			  ;; apply {f} to {c} and return the result of
			  ;; that.  Of course we need to stage the
			  ;; (result of the) evaluation of {c} in a
			  ;; temporary variable because we don't want
			  ;; it evaluated twice.

			  ;; There is an unhelpful indirection
			  ;; complication in that we are looking at
			  ;; {clause*} so this clause is {ph clause*}
			  ;; and then {c} and {f} are the {ph clause}
			  ;; (therefore {phh clause*}) and {phtt
			  ;; clause} (and therefore {phtth clause*})
			  ;; respectively.

			  ;; Finally, this clause is just one of many,
			  ;; so we need to keep rewriting all the
			  ;; remaining clause* ({pt clause*}).

			  gs := (gensym)

			  ;; `(let ((gs ,(phh clause*)))
			  ;;	(if gs
			  ;;	    (,(phtth clause*) gs)
			  ;;	    ,(rewrite-cond-clause* (pt clause*))))
			  pt-clause* := pt clause*

			  appl := list (phtth clause*) gs

			  c := (list 'let
				     (list (list gs (phh clause*)))
				     (list 'if
					   gs
					   appl
					   (meaning-rewrite-cond ph-clause*
								 (mpp pt-clause* src)
								 pt-clause*)))
			  meaning-copy-src-properties (mpp ph-clause* src) c
			  c
			} {
			  if (pair? src) {
			    ;; Test Cases:
			    ;; evaluation-errors/rewrite-cond-apply-two-args.idio
			    ;; evaluation-errors/rewrite-cond-apply-four-args.idio

			    ;; cond (1 =>)
			    ;; cond (1 => a b)
			    meaning-evaluation-error (ph src) "cond: invalid => clause" clause*
			  } {
			    ;; Test Case: ??
			    meaning-evaluation-error src "cond: invalid => clause" clause*
			  }
			}
	      })

	((null? (pth clause*)) {
	  gs := (gensym)
	  ;; `(let ((gs ,(phh clause*)))
	  ;;	   (or gs
	  ;;	       ,(rewrite-cond-clause* (pt clause*))))

	  ph-clause* := ph clause*
	  pt-clause* := pt clause*

	  c* := (list 'let
		      (list (list gs (phh clause*)))
		      (list 'or
			    gs
			    (meaning-rewrite-cond ph-clause*
						  (mpp pt-clause* src)
						  pt-clause*)))
	  meaning-copy-src-properties (mpp ph-clause* src) c*
	  c*
	})

	(else {
	  ph-clause* := ph clause*
	  pt-clause* := pt clause*

	  c := (list 'if
		     (phh clause* )
		     (append (list 'begin) (pth clause*))
		     (meaning-rewrite-cond ph-clause*
					   (mpp pt-clause* src)
					   pt-clause*))
	  meaning-copy-src-properties (mpp ph-clause* src) c
	  c
	}))
}

define (meaning-assignment src name e nametree flags cs cm) {
  (cond ((pair? name) {
    ;; setter

    ;; append will deconstruct the (setter name) construct so we need
    ;; extra levels of list
    args := pt name

    setter := list 'setter (ph name)

    se := append (list setter) args (list e)

    meaning src se nametree (clear-define flags) cs cm
  })
   ((symbol? name) {
     m := meaning (mpp e src) e nametree (make-eval-flags #f flags.scope #f) cs cm

     si := meaning-variable-info src nametree name flags cs cm

     if (not si) {
       ; shouldn't get here as unknowns are automatically made toplevel
       meaning-error-static-unbound src name
     }

     scope := ph si
     ci := pht si

     ; without being able to return early we can presume that if
     ; someone has set the intermediate code {i-code} then they
     ; intended to return immediately
     i-code := #f

     ; otherwise set {assign} to the intermediate code for the
     ; assignment part and we'll also check the {define} flag for all
     ; three callers
     assign := #n

     (case scope
	   ((local) {
	     vi := phtt si
	     if (eq 0 ci) {
	       i-code = list I-SHALLOW-ARGUMENT-SET vi m
	     } {
	       i-code = list I-DEEP-ARGUMENT-SET ci vi m
	     }
	   })
	   ((toplevel) {
	     vi := phtt si
	     if (eq 0 vi) {
	       assign = list I-GLOBAL-SYM-SET ci m
	     } {
	       assign = list I-GLOBAL-VAL-SET vi m
	     }
	   })
	   ((dynamic environ) {
	     assign = list I-GLOBAL-SYM-SET ci m
	   })
	   ((computed) {
	     if flags.define {
	       i-code = (list (list I-GLOBAL-SYM-DEF name scope ci)
			      (list I-COMPUTED-SYM-DEF ci m))
	       } {
		 i-code = list I-COMPUTED-SYM-SET ci m
	       }
	   })
	   ((predef) {
	     new-ci := meaning-toplevel-extend src name (define-scope 'toplevel flags) cs cm

	     vi := phtt si
	     set-symbol-value! name (vm-values-ref vi) cm
	     assign = list I-GLOBAL-SYM-SET new-ci m
	     ci = new-ci
	   })
	   (else {
	     ;; Shouldn't get here unless the if clauses above don't
	     ;; cover everything.  Developer error?
	     meaning-error-static-unbound src name
	   }))

     (cond (i-code i-code)
	   (flags.define {
	     (list (list I-GLOBAL-SYM-DEF name scope ci)
		   assign)
	   })
	   (else assign))
   })
   (else
    ;; Test Case: evaluation-errors/assign-non-symbol.idio

    ;; 1 = 3
    (meaning-evaluation-error src "cannot assign to" name)))
}

define (meaning-define src name e nametree flags cs cm) {
  if (pair? name) {
    ;; (define (func arg) ...) => (define func (function (arg) ...))
    e = append (list 'function (pt name)) e
    name = ph name

    meaning-copy-src-properties src e
  } {
    if (pair? e) {
      e = ph e

      meaning-copy-src-properties src e
    }
  }

  define-flags := make-eval-flags flags.tailp 'toplevel #t
  si := meaning-variable-info src nametree name define-flags cs cm

  ;; if the act of looking the variable up auto-created it then
  ;; actually give it a value slot as this *is* the definition of it
  scope :=  ph si
  vi := phtt si
  if (and (eq? 'toplevel scope)
	  (eq 0 vi)) {
	    vi = (vm-extend-values)
	    si = list scope (pht si) vi cm "meaning-define/gvi=0"
	    set-symbol! name si cm
	  }

  meaning-assignment src name e nametree define-flags cs cm
}

define (meaning-define-template src name e nametree flags cs cm) {

  if (and (symbol? e)
	  (expander? e)) {
	    ;; In general (define-template a ...) means that "a" is
	    ;; associated with an expander and that expander takes the
	    ;; pt of the expression it is passed, "(a ...)" (ie. it
	    ;; skips over its own name).

	    ;; It happens that people (S9fES) say

	    ;; (define-template %b ...)
	    ;; (define-template b %b)

	    ;; (in particular where they are creating an enhanced
	    ;; version of b which may require using the existing b to
	    ;; define itself hence defining some other name, "%b",
	    ;; which can use "b" freely then redefine b to this new
	    ;; version)

	    ;; However, we can't just use the current value of "%b" in
	    ;; (define-template b %b) as this template-expander
	    ;; association means we are replacing the nominal
	    ;; definition of a template with an expander which takes
	    ;; two arguments and the body of which will take the pt of
	    ;; its first argument.  Left alone, expander "b" will take
	    ;; the pt then expander "%b" will take the pt....  "A
	    ;; Pair-Tail Too Far", one would say, in hindsight and
	    ;; thinking of the big budget movie potential.

	    ;; So catch the case where the value is already an
	    ;; expander and replace it with the (obvious?) assignment
	    ;; with some *expander-list* copying.

	    copy-expander! name e
	    meaning-assignment src name e nametree (define-scope 'toplevel flags) cs cm
	  } {
	    ;; (define-template (name formal*) ...) => (define-template name (function (formal*) ...))
	    if (pair? name) {
	      e = (list 'function
			(pt name)
			e)
	      name = ph name

	      meaning-copy-src-properties src e
	    }

	    ;; create an expander: (function (x e) (apply proc (pt x)))

	    ;; where proc is (function (formal*) ...) from above,
	    ;; ie. e

	    docstr := sprintf "define-template: %s (x e)" name
	    expander := (list 'function
			      '(x e)
			      docstr
			      (list 'apply e '(pt x)))

	    meaning-copy-src-properties src expander

	    ;; XXX define-template bootstrap

	    ;; Option 1 (when I was dealing with file contents "all in
	    ;; one"):

	    ;; We really want the entry in *expander-list* to be some
	    ;; compiled code but we don't know what that code is yet
	    ;; because we have't processed the source code of the
	    ;; expander -- we only invented it a couple of lines above
	    ;; -- let alone compiled it!

	    ;; So, we'll drop the "source" code of the expander into
	    ;; *expander-list* and later, when someone calls expander?
	    ;; for this name we'll notice the value is a pair and do a
	    ;; symbol lookup for the closure that was created via
	    ;; meaning-assignment.

	    ;; Option 2 (noted at the time but not implemented):

	    ;; As an alternative we could evaluate the source to the expander
	    ;; now and install that code in *expander-list* directly -- but
	    ;; watch out for embedded calls to regular functions defined in
	    ;; the code (see comment above).

	    ;; In fact, because the evaluator changed to
	    ;; expression-by-expression we effectively implement
	    ;; Option 2 (which handles the regular function calls as
	    ;; well).

	    ;; Requirement either way:

	    ;; As a further twist, we really need to embed a call to
	    ;; install-expander in the *object* code too!  When
	    ;; someone in the future loads the object file containing
	    ;; this define-template who will have called
	    ;; install-expander?

	    ;; In summary: we need the expander in the here and now as
	    ;; someone might use it in the next line of source and we
	    ;; need to embed a call to install-expander in the object
	    ;; code for future users.

	    ;; this is a define at the toplevel and not tailp
	    ma := meaning-assignment expander name expander nametree (make-eval-flags #f 'toplevel #t) cs cm

	    install-expander/source! name expander expander

	    ;; Generate a ci/vi for name

	    ;; The ci is required so that the EXPANDER opcode can call
	    ;; install-expander to overwrite the proc from the
	    ;; install-expander/source! call we just made

	    ;; The vi is because this is definitely a define
	    ci := codegen-constants-lookup-or-extend cs name
	    vi := (vm-extend-values)

	    set-symbol! name (list 'toplevel ci vi cm docstr) cm

	    list I-EXPANDER ci ma
	  }
}

define (meaning-define-infix-operator src name pri e nametree flags cs cm) {
  if (lt pri 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol for {name} or create a new one
  ci := codegen-constants-lookup-or-extend cs name

  ;; XXX the plain use of operator gets a symbol in set-symbol! ??
  op-mod := find-module 'operator

  set-symbol! name (list 'toplevel ci 0 op-mod (sprintf "meaning-define-infix-operator %s" name)) op-mod
  eprintf "INFIX-OPERATOR: defined %d in %s\n" ci op-mod

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-infix-operator X pri Y

    if (infix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *infix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve
      eprintf "sve is %s\n" sve

      copy-infix-operator! name pri e
      m = meaning-assignment src name sve nametree (define-scope 'toplevel flags) cs cm
    } {
      ;; Test Case: evaluation-errors/infix-op-not-an-operator.idio

      ;; define-infix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-infix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-infix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function
		'(op before after)
		(sprintf "infix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    m = meaning fe fe nametree flags cs cm
  }

  list I-INFIX-OPERATOR ci pri m
}

define (meaning-define-postfix-operator src name pri e nametree flags cs cm) {
  if (lt pri 0) {
    meaning-evaluation-error src "positive priority" pri
  }

  ;; Step 1: find the existing symbol for {name} or create a new one
  ci := codegen-constants-lookup-or-extend cs name

  ;; XXX the plain use of operator gets a symbol in set-symbol! ??
  op-mod := find-module 'operator

  set-symbol! name (list 'toplevel ci 0 op-mod (sprintf "meaning-define-postfix-operator %s" name)) op-mod
  eprintf "POSTFIX-OPERATOR: defined %d in %s\n" ci op-mod

  ;; Step 2: rework the expression into some appropriate code and
  ;; compile
  m := #f
  if (symbol? e) {
    ;; define-postfix-operator X pri Y

    if (postfix-operator? e) {
      ;; We happen to have the closure for Y, (pt (assq Y
      ;; *postfix-operator-list*)), but when this object code is loaded
      ;; the compiled code's value could be anywhere so we should be
      ;; looking the value up.

      sve := #T{ symbol-value '$e (find-module 'operator) }
      meaning-copy-src-properties src sve
      eprintf "sve is %s\n" sve

      copy-postfix-operator! name pri e
      m = meaning-assignment src name sve nametree (define-scope 'toplevel flags) cs cm
    } {
      ;; Test Case: evaluation-errors/postfix-op-not-an-operator.idio

      ;; define-postfix-operator qqq 300 zzz
      meaning-evaluation-error src "not an operator" e
    }
  } {
    ;; define-postfix-operator X pri { ... }

    ;; should really be a function definition with args: {op},
    ;; {before} and {after}:

    ;; define-postfix-operator (X op before after) { ... }

    args := '(op before after)

    fe := (list 'function
		'(op before after)
		(sprintf "postfix-operator %s" name)
		e)
    meaning-copy-src-properties src fe

    m = meaning fe fe nametree flags cs cm
  }

  list I-POSTFIX-OPERATOR ci pri m
}

define (meaning-define-dynamic src name e nametree flags cs cm) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree (define-scope 'dynamic flags) cs cm
}

define (meaning-define-environ src name e nametree flags cs cm) {
  if (pair? e) {
    e = ph e

    meaning-copy-src-properties src e
  }

  meaning-assignment src name e nametree (define-scope 'environ flags) cs cm
}

;; A computed variable's value should be a pair, (getter & setter).
;; Either of getter or setter can be #n.
;;
;; We shouldn't have both #n as it wouldn't be much use.

define (meaning-define-computed src name e nametree flags cs cm) {
  getter := #n
  setter := #n

  if (pair? e) {
    he := ph e

    if (pair? he) {
      getter = ph he
      setter = pht he
    } {
      getter = he
    }
  } {
    ;; Not sure we can get here as {e} is either #n or a list
    meaning-evaluation-error src "define-computed: no getter/setter" e
  }

  if (and (null? getter)
	  (null? setter)) {
	    ;; Test Case: evaluation-errors/define-computed-no-args.idio

	    ;; C :$ #n
	    meaning-evaluation-error src "define-computed: no getter/setter" name
	  }

  #*

  There are no property lists associated with variables so we can't
  pull the same (set! (proc ...) v) => ((setter proc) ... v) trick as
  we can with procs.

  So, to set the actual getter/setter pair, as opposed to setting the
  variable (which is a call to the setter proc), we need a magic flag
  for meaning-assignment: IDIO_MEANING_FLAG_DEFINE.  Here, then, this
  is a re-definition rather than an assignment per se.

  *#

  meaning-assignment src name (list 'pair getter setter) nametree (define-scope 'computed flags) cs cm
}

define (meaning*-single-sequence src e nametree flags cs cm) {
  meaning (mpp e src) e nametree flags cs cm
}

define (meaning*-multiple-sequence src e e+ nametree flags keyword cs cm) {
  m := meaning (mpp e src) e nametree (clear-tailp flags) cs cm
  m+ := meaning-sequence src e+ nametree flags keyword cs cm

  (case keyword
	((and)		(list I-AND m m+))
	((or)		(list I-OR m m+))
	((begin)	(list I-BEGIN m m+))
	(else
	  ;; Shouldn't get here unless the clauses above don't cover
	  ;; everything.  Developer error?
	 (meaning-evaluation-error src "unexpected sequence keyword" keyword)))
}

define (meaning-sequence src e+ nametree flags keyword cs cm) {
  if (pair? e+) {
    he+ := ph e+
    if (pair? (pt e+)) {
      meaning*-multiple-sequence src he+ (pt e+) nametree flags keyword cs cm
    } {
      meaning*-single-sequence src he+ nametree flags cs cm
    }
  } {
    ;; Shouldn't get here as the args were checked in meaning.
    ;; Developer error?
    meaning-evaluation-error keyword "sequence: not a pair" e+
  }
}

define (meaning-fix-abstraction src formal* arg-name* docstr e+ nametree flags cs cm) {
  arity := length formal*
  nt+ := meaning-nametree-extend nametree formal*

  m+ := meaning-sequence src e+ nt+ (set-tailp flags) 'begin cs cm

  list I-FIX-CLOSURE m+ arity arg-name* docstr
}

define (meaning-dotted-abstraction src formal* vararg arg-name* docstr e+ nametree flags cs cm) {
  arity := length formal*
  fix-formal* := append formal* (list vararg)

  nt+ := meaning-nametree-extend nametree fix-formal*

  m+ := meaning-sequence src e+ nt+ (set-tailp flags) 'begin cs cm

  list I-NARY-CLOSURE m+ arity fix-formal* docstr
}

#*

With meaning-rewrite-body/meaning-rewrite-body-letrec we want to
massage the code to support some semantic trickery.

The two broad swathes are:

1. multiple function defines in (Scheme: at the start of) the body.

   {
     define (f) { ... }
     define (g) { ... }
     ...
   }

   Here, these two are expected to be self or mutually recursive
   (as well as being of local scope) and so the body is rewritten such
   that these are letrec definitions (and can safely be self/mutually
   recursive) and rest of the the body becomes the body of the letrec

   In Scheme these are only allowed at the start of the body whereas
   Idio allows them to appear anywhere in the body and when one
   appears we combine them with any immediately following.

2. new variable introductions

   a. := (let*)

      This is an extension of the letrec mechanism above so that the
      remaining body is transformed into a let* of the variable
      assignment.

   b. :* :~ !* !~

      These require a similar transform as the introduction of
      (potentially shadowing) environment/dynamic variables requires
      that their definitions be removed from the stack at the end of
      the body.

      Essentially the same as introducing environment/dynamic
      variables we can unset them which requires the same technique.

3. source properties

   If we're inventing code snippets then we should make some small
   effort to ensure that the source properties of the original code
   are propagated to our snippet.  This is especially important when
   several of these snippets invoke expanders -- which need to do much
   the same themselves!

---

meaning-rewrite-body is the main entry point and this will perform the
let* rewrites for := (and similar for dynamic/environ variables)

meaning-rewrite-body-letrec is called if we see an internal define/:+

*#

define (meaning-rewrite-body src e) {
  loop :+ function (l r) {
	    cur := (cond ((null? l) (reverse r))

			 ((and (pair? l)
			       (pair? (ph l))
			       (expander? (phh l))) {
				 template-expand* (ph l)
			       })

			 (else {
			   ph l
			 }))

	    meaning-copy-src-properties (mpp (ph l) src) cur

	    (cond ((null? l) {
	      reverse r
	    })

	     ((and (pair? cur)
		   (eq? 'begin (ph cur))) {
		     ;; redundant begin
		     loop (append (pt cur) (pt l)) r
		   })

	     ((and (pair? cur)
		   (or (eq? 'define (ph cur))
		       (eq? ':+ (ph cur)))) {
			 ;; :+ or define ==> letrec
			 reverse (pair (meaning-rewrite-body-letrec (mpp l src) l) r)
		       })

	     ((and (pair? cur)
		   (eq? ':= (ph cur))) {
		     ;; := ==> let*

		     ;; we have ((:= name value-expr) ...)

		     ;; which we can rewrite as

		     ;; (let ((name value-expr))
		     ;;      (begin
		     ;;       ...
		     ;;       ))

		     ;; and recurse on ..., which is now the body of
		     ;; our (let)

		     body := meaning-rewrite-body (mpp cur src) (pt l)

		     if (null? body) {
		       ;; what if value-expr has side-effects?
		       eprintf "mrb :=	OPT: empty body for let* => no eval of value-expr\n"
		       eprintf "src=%s\n" src
		       reverse r
		     } {

		       body-seq := append (list 'begin) body

		       binding := pt cur
		       value-expr := pht binding

		       r-cur := (list 'let
				      (list binding)
				      body-seq)

		       meaning-copy-src-properties (mpp cur src) r-cur

		       append (reverse r) (list r-cur)
		     }
		   })

	     ((and (pair? cur)
		   (or (eq? ':* (ph cur))
		       (eq? '!* (ph cur))
		       (eq? ':~ (ph cur))
		       (eq? '!~ (ph cur)))) {

			 op := (case ((':*) 'environ-let)
				     (('!*) 'environ-unset)
				     ((':~) 'dynamic-let)
				     (('!~) 'dynamic-unset)
				     (else (meaning-error-param src "bad operator" cur)))

			 body := meaning-rewrite-body (mpp cur src) (pt l)

			 if (null? body) {
			   ;; what if value-expr has side-effects?
			   eprintf "mrb :=	OPT: empty body for %s => no eval of value-expr\n" op
			   eprintf "src=%s\n" src
			   reverse r
			 } {

			   body-seq := append (list 'begin) body

			   binding := pt cur
			   value-expr := pht binding

			   r-cur := (list op
					  binding
					  body-seq)

			   meaning-copy-src-properties (mpp cur src) r-cur

			   append (reverse r) (list r-cur)
			 }
		       })

	     ((and (pair? cur)
		   (eq? 'define-template (ph cur))) {

		     meaning-error-param src "internal define-template" cur
		   })

	     (else {
	       loop (pt l) (pair cur r)
	     }))
  }

  loop e #n
}

#*

meaning-rewrite-body-letrec is slightly more sophisticated that
meaning-rewrite-body in that it needs to accumulate
consecutive "define"s to produce the letrec statement.

The algorithm was inspired by rewrite-body in STklos
.../lib/compiler.stk

*#

define (meaning-rewrite-body-letrec src e) {
  loop :+ function (l defs r) {
	    cur := (cond ((null? l) {
	      ;; Test Case: evaluation-errors/letrec-empty-body.idio

	      ;; {
	      ;;   bar :+ "foo"
	      ;;
	      ;; }

	      ;; NB The point is that there is nothing else in the
	      ;; block after the creation of {bar}, so there is no
	      ;; "body" for the (generated) letrec of {bar}.

	      ;; Regardless of whether {bar} is a (faintly) pointless
	      ;; sort of letrec, notably not involving a function.

	      ;; There's an argument that it could be optimised away
	      ;; (if the value-expression has no side-effects, etc.).
	      meaning-evaluation-error src "letrec: empty body" l
	    })

			 ((and (pair? l)
			       (pair? (ph l))
			       (expander? (phh l))) {
				 te := template-expand* (ph l)
				 te
			       })

			 (else {
			   ph l
			 }))
	    meaning-copy-src-properties (mpp (ph l) src) cur

	    (cond ((null? l) {
	      reverse r
	    })

	     ((and (pair? cur)
		   (eq? 'begin (ph cur))) {
		     ;; redundant begin
		     loop (append (pt cur) (pt l)) defs r
		   })

	     ((and (pair? cur)
		   (or (eq? 'define (ph cur))
		       (eq? ':+ (ph cur)))) {
			 ;; cur	~ (define (name formal*) ...)
			 ;; cur	~ (:+ name value-expr)

			 bindings := pht cur
			 form := #f

			 if (pair? bindings) {
			   ;; cur	~ (define (name formal*) ...)

			   ;; form	~ (name (function (formal*)) ...)

			   fn := (append (list 'function
					       (pt bindings)
					       (sprintf "rewrite body letrec: %s" bindings))
					 (ptt cur))

			   form = list (ph bindings) fn
			 } {
			   ;; cur	~ (:+ name value-expr)

			   ;; form	~ (name value-expr)
			   form = pt cur
			 }
			 meaning-copy-src-properties (mpp cur src) form

			 loop (pt l) (pair form defs) r
		       })

	     ((and (pair? cur)
		   (eq? 'define-template (ph cur))) {

		     ;; Test Case: (nominally) evaluation-errors/letrec-internal-define-template.idio

		     ;; bar :+ define-template (baz) { #T{ 1 } }

		     ;; XXX I can't get this to trigger the error
		     meaning-error-param src "internal define-template" cur
		   })

	     (else {
	       ;; body proper

	       cur-props := mpp cur src
	       l = meaning-rewrite-body cur-props l

	       ;; if no defs just return l
	       if (null? defs) l {
		 ;; poor man's letrec*

		 ;; We are aiming for:

		 ;; {
		 ;;   v1 :+ a1
		 ;;   v2 :+ a2
		 ;;   body
		 ;; }

		 ;; to become

		 ;; (let ((v1 #f)
		 ;;       (v2 #f))
		 ;;   (set! v1 a1)
		 ;;   (set1 v2 a2)
		 ;;   body)

		 ;; but we return it as a list of one, ((let
		 ;; ... body)), so that idio_meaning_sequence will
		 ;; re-read the first element in the list and interpret
		 ;; it as the expander "let"

		 ;; NB Leave defs reversed as creating the
		 ;; bindings/assignments will implicitly re-order them

		 bindings := #n
		 for-each (function (formal) {
			     bindings = pair (list formal #f) bindings
		 }) (map ph defs)

		 ;; Remember {defs} is the list of tuples

		 ;; ((v1 a1) (v2 a2))

		 ;; so that (ph vs) is (v1 a1) and therefore

		 ;; (append (set!) (v1 a1))

		 ;; gives us the desired

		 ;; (set! v1 a1)

		 ;; and that as we walk down {vs} we'll get a
		 ;; (reversed) list of assignments in {body}

		 ;; ((set! v2 a2)
		 ;;  (set! v1 a1))
		 body := #n
		 for-each (function (def) {
			     assign := append (list 'set!) def
			     body = append (list assign) body
		 }) defs
		 body = append body l

		 stmt := append (list 'let bindings) body
		 meaning-copy-src-properties cur-props stmt

		 stmt
	       }
	     }))
  }

  loop e #n #n
}

define (meaning-abstraction src formal* docstr e+ nametree flags cs cm) {
  e+ := meaning-rewrite-body (mpp e+ src) e+
  meaning-copy-src-properties src e+

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction
  formals-loop :+ function (f* regular) {
		    (cond
		     ((pair? f*) (formals-loop (pt f*) (pair (ph f*) regular)))
		     ((null? f*) (meaning-fix-abstraction src formal* formal* docstr e+ nametree flags cs cm))
		     (else (meaning-dotted-abstraction src (reverse regular) f* formal* docstr e+ nametree flags cs cm)))
  }

  formals-loop formal* #n
}

define (meaning-block src e* nametree flags cs cm) {
  e* = meaning-rewrite-body (mpp e* src) e*
  meaning-copy-src-properties src e*

  meaning-sequence (mpp e* src) e* nametree flags 'begin cs cm
}

define (meaning-some-arguments src ae ae* nametree size flags cs cm) {
  am := meaning (mpp ae src) ae nametree (clear-tailp flags) cs cm
  am* := meaning-arguments src ae* nametree size flags cs cm

  rank := size - ((length ae*) + 1)

  list I-STORE-ARGUMENT am am* rank
}

define (meaning-no-argument src nametree size flags cs) {
  list I-ALLOCATE-FRAME size
}

define (meaning-arguments src ae* nametree size flags cs cm) {
  if (pair? ae*) {
    meaning-some-arguments src (ph ae*) (pt ae*) nametree size flags cs cm
  } {
    meaning-no-argument src nametree size flags cs
  }
}

define (meaning-fix-closed-application src formal* body ae* nametree flags cs cm) {
  body = meaning-rewrite-body (mpp body src) body
  meaning-copy-src-properties src body

  am* := meaning-arguments src ae* nametree (length ae*) (clear-tailp flags) cs cm
  nt+ := meaning-nametree-extend nametree formal*

  mbody := meaning-sequence (mpp body src) body nt+ flags 'begin cs cm

  if flags.tailp {
    list I-TR-FIX-LET am* mbody formal*
  } {
    list I-FIX-LET am* mbody formal*
  }
}

define (meaning-some-dotted-arguments src ae ae* nametree size arity flags cs cm) {
  am := meaning (mpp ae src) ae nametree (clear-tailp flags) cs cm
  am* := meaning-dotted-arguments src ae* nametree size arity flags cs cm
  rank := size - ((length ae*) + 1)

  if (lt rank arity) {
    list I-STORE-ARGUMENT am am* rank
  } {
    list I-LIST-ARGUMENT am am* arity
  }
}

define (meaning-no-dotted-argument src nametree size arity flags cs) {
  list I-ALLOCATE-FRAME arity
}

define (meaning-dotted-arguments src ae* nametree size arity flags cs cm) {
  if (pair? ae*) {
    meaning-some-dotted-arguments src (ph ae*) (pt ae*) nametree size arity flags cs cm
  } {
    meaning-no-dotted-argument src nametree size arity flags cs
  }
}

define (meaning-dotted-closed-application src formal* vararg body ae* nametree flags cs cm) {
  body = meaning-rewrite-body (mpp body src) body
  meaning-copy-src-properties src body

  am* := meaning-dotted-arguments src ae* nametree (length ae*) (length formal*) (clear-tailp flags) cs cm

  fix-formal* := append formal* (list vararg)
  nt+ := meaning-nametree-extend nametree fix-formal*

  mbody := meaning-sequence (mpp body src) body nt+ flags 'begin cs cm

  if flags.tailp {
    list I-TR-FIX-LET am* mbody fix-formal*
  } {
    list I-FIX-LET am* mbody fix-formal*
  }
}

define (meaning-closed-application src fe ae* nametree flags cs cm) {
  ;; ((function ...) args)
  ;;
  ;; fe		~ (function ...)
  ;; (ph fe)	~ 'function
  ;; (pt fe)	~ ...		~ (formals* body)
  ;; (pht fe)	~ formals*
  ;; (ptt fe)	~ (body)

  ;; neat trick: walk down the list of formal* and if it is an
  ;; improper list then it must be a dotted abstraction

  ;; unlike meaning-abstraction above, we need to check the arguments
  ;; being supplied at the same time

  formal* := pht fe

  formals-loop :+ function (f* a* fixed-args) {
		    (cond
		     ((pair? f*) {
		       if (pair? a*) {
			 formals-loop (pt f*) (pt a*) (pair (ph f*) fixed-args)
		       } {
			 ;; Test Cases:
			 ;; evaluation-errors/closed-function-not-enough-args-{0,1}.idio

			 ;; ((function (x) x) )
			 ;; (function (x y) x) 1

			 ;; XXX Note that in the first case we must
			 ;; wrap the putative ``func-defn args`` in
			 ;; parens otherwise we're simply writing
			 ;; ``func-defn`` which defines and
			 ;; immediately throws away the function.

			 ;; In the second case the system can see
			 ;; there's an arg!
			 meaning-evaluation-error src "closed application: not enough arguments" (list formal* ae*)
		       }
		     })
		     ((null? f*) {
		       if (null? a*) {
			 meaning-fix-closed-application fe formal* (ptt fe) ae* nametree flags cs cm
		       } {
			 ;; Test Cases:
			 ;; evaluation-errors/closed-function-too-many-args-{0,1}.idio

			 ;; (function () 1) 2
			 ;; (function (x) x) 1 2
			 meaning-evaluation-error src "closed application: too many arguments" (list formal* ae*)
		       }
		     })
		     (else (meaning-dotted-closed-application fe (reverse fixed-args) f* (ptt fe) ae* nametree flags cs cm)))
  }

  formals-loop formal* ae* #n
}

#*

Of these IDIO_A_PRIMCALL1_SET_CUR_MOD *must* be a specialized
primitive call because it must be called "inline", ie. not in the
context of a regular Idio FUNCTION_INVOKE.

If you allow the latter then IDIO_THREAD_ENV() is saved/restored
around the call which defeats the point in it trying to alter
IDIO_THREAD_ENV().

Everything will remain permanently in the main Idio module.

--

Yuk!  Data in two places problem.

For regular function calls the duty cycle is to evaluate all the
arguments, pushing them onto the stack, create a frame, pop the
arguments off the stack into the frame, evaluate the functional
argument and push the resultant function in a register then call
FUNCTION_INVOKE or FUNCTION_GOTO.

For our hand-crafted primitives written in C we know they take a small
number (three or fewer, probably) arguments and that mechanically
we're going to end up with a call to the primitive's C function with
those three or fewer arguments.  We must be able to save some time.

We can accelerate fixed-arity primitive calls which, rather than
allocating frames on the stack, can just call the primitive function
with the contents of the VM registers directly.  Better yet, we can
accelerate some of them by having a dedicated VM instruction thus
avoiding having to pass the index of the primitive at all.

However, if we leave the decision as to which calls to accelerate to
the compiler then the compiler must be able to fall back to the
general function call evaluator, idio_meaning_regular_application().
Which is very complex.

For us to do it here we must know which primitive calls the VM is
capable of specializing which is knowledge that our strongly-held pure
encapsulation beliefs say we shouldn't have.

There must be a better way...but in the meanwhile it's much less code
for us to check the specialization here.

*#

define (meaning-primitive-application src fe ae* nametree flags arity vi cs cm) {
  primdata := vm-values-ref vi

  if (primitive-varargs? primdata) {
    ;; only a full function call protocol can cope with varargs!
    meaning-regular-application src fe ae* nametree flags cs cm
  } {
    name := primitive-name primdata

    i-code := #f

    (case arity
	  ((0) {
	    (case name
		  (("read") (i-code := (list I-PRIMCALL0 A-PRIMCALL0-READ)))
		  (("newline") (i-code := (list I-PRIMCALL0 A-PRIMCALL0-NEWLINE))))
	  })
	  ((1) {
	    m1 := meaning (mpp (ph ae*) src) (ph ae*) nametree (clear-tailp flags) cs cm

	    (case name
		  (("ph") (i-code := (list I-PRIMCALL1 A-PRIMCALL1-HEAD m1)))
		  (("pt") (i-code := (list I-PRIMCALL1 A-PRIMCALL1-TAIL m1))))
	  }))

    if i-code i-code {
      meaning-regular-application src fe ae* nametree flags cs cm
    }
  }
}

define (meaning-regular-application src fe ae* nametree flags cs cm) {
  fm := #n
  if (symbol? fe) {
    fm = meaning-function-reference src fe nametree flags cs cm
  } {
    fm = meaning fe fe nametree (clear-tailp flags) cs cm
  }

  am* := meaning-arguments src ae* nametree (length ae*) (clear-tailp flags) cs cm

  if flags.tailp {
    list I-TR-REGULAR-CALL src fm am*
  } {
    list I-REGULAR-CALL src fm am*
  }
}

define (meaning-application src fe ae* nametree flags cs cm) {
  i-code := #f

  ;; check for a primitive
  if (symbol? fe) {
    si := meaning-variable-info src nametree fe (set-scope 'toplevel flags) cs cm

    if (pair? si) {
      scope := ph si

      if (eq? 'predef scope) {
	primdata := vm-values-ref (phtt si)

	if (primitive? primdata) {
	  arity := primitive-arity primdata
	  n-args := length ae*

	  if (or (and (primitive-varargs? primdata)
		      (ge n-args arity))
	      (eq n-args arity)) {
		i-code = meaning-primitive-application src fe ae* nametree flags arity (phtt si) cs cm
	      } {
		;; Test Case: evaluation-errors/primitive-arity.idio

		;; pair 1
		meaning-evaluation-error src "wrong arity for primitive" (list fe ae*)
	      }
	} {
	  ;; Can we get here?  We'd need to be a predef but those are
	  ;; all, uh, primitives.  Developer error?
	  meaning-evaluation-error src "BAD application: not a primitive" fe
	}
      }
    }
  }

  if i-code i-code {
    ;; check for a closed application
    if (and (pair? fe)
	    (eq? 'function (ph fe))) {
	      ;; check for a documentation string and forge one to
	      ;; help debugging
	      if (not (string? (phtt fe))) {
		fe = append (list (ph fe) (pht fe) (sprintf "closed application: %s" (pht fe))) (ptt fe)
	      }
	      meaning-copy-src-properties src fe

	      meaning-closed-application src fe ae* nametree flags cs cm
	    } {
	      meaning-regular-application src fe ae* nametree flags cs cm
	    }
  }
}

define (meaning-dynamic-reference src name nametree flags cs cm) {
  meaning-reference src name nametree (set-scope 'dynamic flags) cs cm
}

define (meaning-dynamic-let src name e e+ nametree flags cs cm) {
  m := meaning (mpp e src) e nametree (clear-tailp flags) cs cm

  si := find-symbol name cm

  ci := #f

  if si {
    ci = pht si
  } {
    ci = meaning-toplevel-extend src name (set-scope 'dynamic flags) cs cm
  }

  nt+ := meaning-nametree-dynamic-extend nametree name ci 'dynamic

  m+ := meaning-sequence src e+ nt+ (clear-tailp flags) 'begin cs cm

  dynamic-wrap := (list (list I-PUSH-DYNAMIC ci m)
			m+
			(list I-POP-DYNAMIC))

  (list (list I-GLOBAL-SYM-DEF name 'dynamic ci)
	dynamic-wrap)
}

define (meaning-dynamic-unset src name e+ nametree flags cs cm) {
  meaning-dynamic-let src name 'undef e+ nametree flags cs cm
}

define (meaning-environ-reference src name nametree flags cs cm) {
  meaning-reference src name nametree (set-scope 'environ flags) cs cm
}

define (meaning-environ-let src name e e+ nametree flags cs cm) {
  m := meaning (mpp e src) e nametree (clear-tailp flags) cs cm

  si := find-symbol name cm

  ci := #f

  if si {
    ci = pht si
  } {
    ci = meaning-toplevel-extend src name (set-scope 'environ flags) cs cm
  }

  nt+ := meaning-nametree-dynamic-extend nametree name ci 'environ

  m+ := meaning-sequence src e+ nt+ (clear-tailp flags) 'begin cs cm

  environ-wrap := (list (list I-PUSH-ENVIRON ci m)
			m+
			(list I-POP-ENVIRON))

  (list (list I-GLOBAL-SYM-DEF name 'environ ci)
	environ-wrap)
}

define (meaning-environ-unset src name e+ nametree flags cs cm) {
  meaning-environ-let src name 'undef e+ nametree flags cs cm
}

define (meaning-computed-reference src name nametree flags cs cm) {
  meaning-reference src name nametree (set-scope 'computed flags) cs cm
}

define (meaning-trap src ce he be nametree flags cs cm) {
  he = meaning-rewrite-body (mpp he src) he
  meaning-copy-src-properties src he

  hm := meaning (mpp he src) he nametree (clear-tailp flags) cs cm

  ;; if the condition expression is not a list then make it one
  if (not (pair? ce)) {
    ce = list ce
  }

  ;; For each condition, resolve/discover the condition's name then
  ;; build pushs with the fci.

  ;; pushs is now the the reverse order of ce

  pushs := #n
  pops := #n

  c-loop :+ function (c*) {
	      if (null? c*) #n {
		c-sym := ph c*

		ci := #f

		si := find-symbol c-sym cm
		if (pair? si) {
		  ci = pht si
		} {
		  eprintf "meaning-trap: condition name unknown: '%s'\n" c-sym
		  ci = meaning-toplevel-extend src c-sym (set-scope 'toplevel flags) cs cm
		}

		pushs = pair (list I-PUSH-TRAP ci) pushs
		pops = pair (list I-POP-TRAP) pops

		c-loop (pt c*)
	      }
  }

  c-loop ce

  be = meaning-rewrite-body (mpp be src) be
  meaning-copy-src-properties src be

  bm := meaning-sequence (mpp be src) be nametree (clear-tailp flags) 'begin cs cm

  append (list hm) pushs (list bm) pops
}

define (evaluate-include-file fh cs) {
  eprintf "\nincl:\th=%s\n" fh
  c := *primitives*/read fh
  if (not (eof? fh)) {
    ;eprintf "incl:\tc=%s\n" c
    m := evaluate c
    eprintf "incl:\tm=%s\n" m
    pc := codegen (current-thread) m cs
    r := vm-run (current-thread) pc
    eprintf "incl:\tr=%s\n" r
    evaluate-include-file fh cs
  }
}

define (meaning-include src e nametree flags cs cm) {
  fh := open-input-file (find-lib e)
  unwind-protect {
    evaluate-include-file fh cs
  } {
    close-handle fh
  }
}

define (meaning-expander src e nametree flags cs cm) {
  ;eprintf "meaning-expander: %s\n" e
  te := expander/template-expand e
  meaning-copy-src-properties src te

  ;; copy src properties?

  meaning te te nametree flags cs cm
}

define (meaning src e nametree flags cs cm) {
  if (pair? e) {
    he := ph e
    te := pt e

    (case he
	  ((begin \and \or) {
	    if (pair? te) {
	      meaning-sequence src te nametree flags he cs cm
	    } {
	      (case he
		    ((begin) (meaning src (void) nametree flags cs cm))
		    ((and) (meaning src #t nametree flags cs cm))
		    ((or) (meaning src #f nametree flags cs cm))
		    (else
		     ;; can we even get here?
		     (meaning-evaluation-error src "unexpected sequence keyword" he)))
	    }
	  })

	  ((escape) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/escape-multiple-args.idio

		;; (escape 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-escape src (ph te) nametree flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/escape-nil.idio

	      ;; (escape)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((quote) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/quote-multiple-args.idio

		;; (quote 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-quotation src (ph te) nametree flags
	      }
	    } {
	      ;; Test Case: evaluation-errors/quote-nil.idio

	      ;; (quote)

	      ;; XXX is (quote) actually '#n ??
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((quasiquote) {
	    if (pair? te) {
	      if (pair? (pt te)) {
		;; Test Case: evaluation-errors/quasiquote-multiple-args.idio

		;; (quasiquote 1 2)
		meaning-error-param src "too many arguments" he
	      } {
		meaning-quasiquotation src (ph te) nametree flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/quasiquote-nil.idio

	      ;; (quasiquote)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((function) {
	    ;; (function bindings [docstr] body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		htte := ph tte
		ttte := pt tte
		if (and (string? htte)
			(not (null? ttte))) {
			  ;; (function bindings "docstr" body ...)
			  meaning-abstraction src (ph te) htte ttte nametree flags cs cm
			} {
			  ;; (function bindings body ...)
			  ;; (function bindings "...")

			  ;; The second is a function whose body is a
			  ;; string

			  meaning-abstraction src (ph te) #n tte nametree flags cs cm
			}
	      } {
		;; (function bindings body ...)
		meaning-abstraction src (ph te) #n tte nametree flags cs cm
	      }
	    } {
	      ;; Test Case: evaluation-errors/function-nil.idio

	      ;; (function)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((if) {
	    ;; (if condition consequent alternative)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		httte := (void)		; default: (if #f e) -> #void
		if (pair? ttte) {
		  httte = ph ttte
		}
		meaning-alternative src (ph te) (ph tte) httte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/if-cond-nil.idio

		;; (if 1)
		meaning-error-param src "no consequent/alternative" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/if-nil.idio

	      ;; (if)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((cond) {
	    ;; (cond clause ...)
	    if (pair? te) {
	      ;; What was I thinking here...
	      if (null? (pt te)) {
		hte := ph te
		if (and (pair? hte)
			(eq? 'block (ph hte))) {
			  ;; (cond )
			  te = pt hte
			}
	      }

	      ce := meaning-rewrite-cond e (mpp te src) te
	      meaning-copy-src-properties src ce

	      meaning ce ce nametree flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/cond-nil.idio

	      ;; (cond)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((set! \=) {
	    ;; (set! var expr)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-assignment src (ph te) (ph tte) nametree (set-scope 'toplevel flags) cs cm
	      } {
		;; Test Case: evaluation-errors/set-symbol-nil.idio

		;; (set! x )
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/set-nil.idio

	      ;; (set!)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-template) {
	    ;; (define-template bindings body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-template src (ph te) (ph tte) nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/define-template-bindings-nil.idio

		;; define-template (m)
		meaning-error-param src "no body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-template-nil.idio

	      ;; (define-template)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-infix-operator) {
	    ;; (define-infix-operator sym pri body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-define-infix-operator src (ph te) (ph tte) (ph ttte) nametree flags cs cm
		} {
		  ;; Test Case: evaluation-errors/define-infix-op-symbol-pri-nil.idio

		  ;; define-infix-operator sym pri
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/define-infix-op-symbol-nil.idio

		;; define-infix-operator sym
		meaning-error-param src "no pri body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-infix-op-nil.idio

	      ;; (define-infix-operator)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define-postfix-operator) {
	    ;; (define-postfix-operator sym pri body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-define-postfix-operator src (ph te) (ph tte) (ph ttte) nametree flags cs cm
		} {
		  ;; Test Case: evaluation-errors/define-postfix-op-symbol-pri-nil.idio

		  ;; define-postfix-operator sym pri
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/define-postfix-op-symbol-nil.idio

		;; define-postfix-operator sym
		meaning-error-param src "no pri body" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-postfix-op-nil.idio

	      ;; (define-postfix-operator)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((define) {
	    ;; (define var expr)
	    ;; (define bindings body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define src (ph te) tte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/define-sym-nil.idio

		;; define sym
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/define-nil.idio

	      ;; (define)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:=) {
	    ;; (:= var expr)
	    ;; (:= bindings body ...)

	    ;; (:= vars expr)	;; ?? cf. let-values (call-with-values producer consumer)

	    ;; in the short term => define
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define src (ph te) tte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/toplevel-define-sym-nil.idio

		;; := sym

		;; XXX can't do ``sym :=`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/toplevel-define-nil.idio

	      ;; (:=)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:*) {
	    ;; (:* var expr)

	    ;; in the short term => define-environ
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-environ src (ph te) tte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/environ-define-sym-nil.idio

		;; :* sym

		;; XXX can't do ``sym :*`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-define-nil.idio

	      ;; (:*)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:~) {
	    ;; (:~ var expr)

	    ;; in the short term => define-dynamic
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-dynamic src (ph te) tte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/dynamic-define-sym-nil.idio

		;; :~ sym

		;; XXX can't do ``sym :~`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no value" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-define-nil.idio

	      ;; (:~)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((:$) {
	    ;; (:$ var getter setter)
	    ;; (:$ var getter)

	    ;; in the short term => define-computed
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		meaning-define-computed src (ph te) tte nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/computed-define-sym-nil.idio

		;; :$ sym

		;; XXX can't do ``sym :$`` as you'll get the EOF in
		;; list error from the reader
		meaning-error-param src "no getter [setter]" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/computed-define-nil.idio

	      ;; (:$)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((block) {
	    ;; { ... }
	    if (pair? te) {
	      meaning-block src te nametree flags cs cm
	    } {
	      eprintf "empty body for block => void\n"
	      meaning src (void) nametree flags cs cm
	    }
	  })

	  ((dynamic) {
	    ;; (dynamic var)
	    if (pair? te) {
	      meaning-dynamic-reference src (ph te) nametree flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/dynamic-nil.idio

	      ;; (dynamic)
	      meaning-error-param src "no argument" he
	    }
	  })

	  ((dynamic-let) {
	    ;; (dynamic-let (var expr) body)
	    if (pair? te) {
	      hte := ph te
	      if (pair? hte) {
		thte := pt hte
		if (pair? thte) {
		  meaning-dynamic-let src (ph hte) (ph thte) (pt te) nametree flags cs cm
		} {
		  ;; Test Case: evaluation-errors/dynamic-let-bindings-not-tuple.idio

		  ;; dynamic-let (d)
		  meaning-error-param src "bindings not a tuple" e
		}
	      } {
		;; Test Case: evaluation-errors/dynamic-let-bindings-not-pair.idio

		;; dynamic-let #n
		meaning-error-param src "bindings not a pair" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-let-nil.idio

	      ;; (dynamic-let)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((dynamic-unset) {
	    ;; (dynamic-unset var body)
	    if (pair? te) {
	      hte := ph te
	      if (symbol? hte) {
		meaning-dynamic-unset src hte (pt te) nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/dynamic-unset-non-sym.idio

		;; dynamic-unset 1
		meaning-error-param src "not a symbol" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/dynamic-unset-nil.idio

	      ;; (dynamic-unset)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((environ-let) {
	    ;; (environ-let (var expr) body)
	    if (pair? te) {
	      hte := ph te
	      if (pair? hte) {
		thte := pt hte
		if (pair? thte) {
		  meaning-environ-let src (ph hte) (ph thte) (pt te) nametree flags cs cm
		} {
		  ;; Test Case: evaluation-errors/environ-let-bindings-not-tuple.idio

		  ;; environ-let (d)
		  meaning-error-param src "bindings not a tuple" e
		}
	      } {
		;; Test Case: evaluation-errors/environ-let-bindings-not-pair.idio

		;; environ-let #n
		meaning-error-param src "bindings not a pair" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-let-nil.idio

	      ;; (environ-let)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((environ-unset) {
	    ;; (environ-unset var body)
	    if (pair? te) {
	      hte := ph te
	      if (symbol? hte) {
		meaning-environ-unset src hte (pt te) nametree flags cs cm
	      } {
		;; Test Case: evaluation-errors/environ-unset-non-sym.idio

		;; environ-unset 1
		meaning-error-param src "not a symbol" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/environ-unset-nil.idio

	      ;; (environ-unset)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((trap) {
	    ;; (trap condition		handler body ...)
	    ;; (trap (condition ...)	handler body ...)
	    if (pair? te) {
	      tte := pt te
	      if (pair? tte) {
		ttte := pt tte
		if (pair? ttte) {
		  meaning-trap src (ph te) (ph tte) ttte nametree flags cs cm
		} {
		  ;; Test Case: evaluation-errors/trap-condition-handler-nil.idio

		  ;; trap condition handler
		  meaning-error-param src "no body" e
		}
	      } {
		;; Test Case: evaluation-errors/trap-condition-nil.idio

		;; trap condition
		meaning-error-param src "no handler" e
	      }
	    } {
	      ;; Test Case: evaluation-errors/trap-nil.idio

	      ;; (trap)
	      meaning-error-param src "no arguments" he
	    }
	  })

	  ((include) {
	    ;; (include filename)
	    if (pair? te) {
	      meaning-include src (ph te) nametree flags cs cm
	    } {
	      ;; Test Case: evaluation-errors/include-nil.idio

	      ;; (include)
	      meaning-error-param src "no argument" he
	    }
	  })

	  (else {
	    ;; not a special form

	    ;; check if {he} is a symbol and if so, if it has been
	    ;; flagged as an expander

	    ;; otherwise it is a derived form, ie. an application
	    if (symbol? he) {
	      si := meaning-variable-info src nametree he (set-scope 'toplevel flags) cs cm

	      if (and si
		      (expander? he)) {
			meaning-expander src e nametree flags cs cm
		      } {
			meaning-application src he te nametree flags cs cm
		      }
	    } {
	      meaning-application src he te nametree flags cs cm
	    }
	  }))
  } {
    ;; {e} is not a pair so is mostly a constant unless it is a symbol
    ;; in which case (de-)reference it
    (cond ((or (fixnum? e)
	       (boolean? e)
	       (null? e)
	       (string? e)
	       (unicode? e)
	       (keyword? e)
	       (array? e)
	       (hash? e)
	       (bignum? e)
	       (bignum? e)
	       (struct-instance? e)
	       (void? e))
	    (meaning-quotation src e nametree flags))
     ((symbol? e) (meaning-reference src e nametree (set-scope 'toplevel flags) cs cm))
     (else
      ;; anything else is something the user shouldn't be dealing
      ;; with!
      idio-dump e
      eprintf "unexpected expression: %s\n" e
      eprintf "\n\n"
      libc/sleep 10
      (meaning-error-param src "invalid constant type" e)))
  }
}

define (evaluate src & constants) {
  c* := #n
  if (pair? constants) {
    c* = ph constants
  } {
    c* = (vm-constants)
  }
  m := meaning src src #n no-flags c* (current-module)

  list I-ABORT m
}

;; done
provide evaluate
