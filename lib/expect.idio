#*

Copyright (c) 2021 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

expect.idio

*#

module expect
export (
	 spawn
	 spawn-id
	 expect-timeout
	 expect-match-max
	 expect-before
	 expect-after
	 expect-case
)

import libc
import pty

;; We'll use define-struct for struct-spawn itself as we weren't going
;; to give it a parent and we get all the predicates and accessors
;; defined.
(export-struct
 struct-spawn
 pid
 mfd
 mode
 buffer
 matched
 eof
 timeout
)

;; a simplified constructor
make-struct-spawn = {
  orig-make-struct-spawn := make-struct-spawn

  function (pid mfd mode) "
create a :ref:`struct-spawn <expect/struct-spawn>`

:param pid: Process ID of spawned process
:type pid: C/int
:param mfd: master file descriptor of pseudo-terminal
:type mfd: C/int
:param mode: initial terminal mode os standard input
:type mode: :ref:`libc/struct-termios <libc/struct-termios>`
:return: `struct-spawn`
:rtype: struct-instance
   
The `buffer` attribute is initialised to the empty string, ``\"\"``,
and the remaining attributes initialised to ``#f``.

" {
    orig-make-struct-spawn pid mfd mode "" #f #f #f
  }
}

spawn-id         :~ #f
expect-timeout   :~ -1
expect-match-max :~ 2000
expect-before    :~ #n
expect-after     :~ #n

define (spawn & argv)  "
Spawn a process defined by `argv`

:param argv: command and arguments
:type argv: list
:return: :ref:`struct-spawn <expect/struct-spawn>`
:rtype: struct-instance
:raises ^system-error:


" {
  spawn-id = apply make-struct-spawn (apply pty/spawn argv)

  spawn-id
}

#*

expect(1) allows for

  expect [[-opts] pat1 body1] ... [-opts] patn [bodyn]

with opts:

  -gl	(default)
  -ex
  -re
  -nocase

  [and others]

patn can be

  eof
  timeout
  default	== eof|timeout

expect-case {
}


loop over (test body) tuples

where test can be

  (regexec rx buffer)

    with rx derived from

      flags string

        and flags being

	  :re / :gl / :ex
	  :icase

	ie.

	  (regcomp (prepared string) [REG_ICASE])

  (or (POLLHUP? revents)
      (POLLERR? revents))

  (null? <result from poller-poll>)

******************************

What we want is to do is three things:

1. define a set of regcomps

  $e-a := make-array 5
  array-set! $e-a 0 (apply regcomp str1 flags1)
  array-set! $e-a 1 (apply regcomp str2 flags2)
  ...
  array-set! $e-a 4 :eof
  array-set! $e-a 5 :timeout

  where the keywords act as non-regcomp toggles

2. define a set of match clauses in cond which either call regexec or
   test the keyword's state and then run the corresponding body in a
   function which is passed (spawn-id) or (spawn-id r prefix) where r
   is the array result from regexec and prefix is the buffer up to
   r.0:

  define ($exp-match spawn-id) {
    (cond
     ((regexec (array-ref $e-a 0) (struct-spawn-buffer spawn-id) 'REG_VERBOSE)
      => (function (r) {
	set-struct-spawn-matched! spawn-id #t
	r0 := r.0
	prefix := substring (struct-spawn-buffer spawn-id) 0 r0.2
	set-struct-spawn-buffer! (substring (struct-spawn-buffer spawn-id) r0.3)

	((function (spawn-id r prefix) {
	  ...
	}) spawn-id r prefix)
      }))
     ((regexec (array-ref $e-a 1) (struct-spawn-buffer spawn-id) 'REG_VERBOSE)
      => (function (r) {
	set-struct-spawn-matched! spawn-id #t
	r0 := r.0
	prefix := substring (struct-spawn-buffer spawn-id) 0 r0.2
	set-struct-spawn-buffer! (substring (struct-spawn-buffer spawn-id) r0.3)

	((function (spawn-id r prefix) {
	  ...
	}) spawn-id r prefix)
      }))
     ...
     ((struct-spawn-eof spawn-id) => (function (r) {
       set-struct-spawn-matched! spawn-id #t
       ((function (spawn-id)
	$@(pth c*)) spawn-id)
     }))
     ((struct-spawn-timeout spawn-id) => (function (r) {
       set-struct-spawn-matched! spawn-id #t
       ((function (spawn-id) {
	 ...
       }) spawn-id)
     })))
    
  }

3. define the exp-continue loop (in the scope of the user's body
   forms) where we run $exp-match against the existing buffer contents
   and if not then poller-poll for more data

*#

define-template (expect-case & clauses) {

  define (exact-string str) {
    (regex-case str
		("([[:alnum:]]*)([^[:alnum:]])(.*)" {
		  append-string r.1 "\\" r.2 (exact-string r.3)
		})
		(else r))
  }

  define (glob-string str) {
    (regex-case str
		("(.*)\\*(.*)" {
		  append-string r.1 ".*" (glob-string r.2)
		})
		("(.*)\\?(.*)" {
		  append-string r.1 "." (glob-string r.2)
		})
		(else r))
  }

  ;; #[ <regcomp> ]
  expect-regcomps := gensym 'e-r

  define (process-args re-kind re-flags a*) {
    (cond
     ((null? a*)
      (error/type ^rt-syntax-error 'expect-case "invalid syntax: no string/body" re-kind re-flags))
     ((not (pair? a*))
      (error/type ^rt-syntax-error 'expect-case "invalid syntax: no string/body" re-kind re-flags a*))
     (else {
       (case (ph a*)
	((:eof :timeout) {
	  list (ph a*) (pt a*)
	})
	((:re :gl :ex) {
	  process-args (ph a*) re-flags (pt a*)
	})
	((:icase) {
	  process-args re-kind 'REG_ICASE (pt a*)
	})
	(else {
	  (cond
	   ((not (string? (ph a*)))
	    (error/type ^rt-syntax-error 'expect-case "invalid syntax: not a string" re-kind re-flags a*))
	   ((or (null? re-kind)
		(eq? :gl re-kind)) {
	     list (list (glob-string (ph a*)) re-flags) (pt a*)
	   })
	   ((eq? :ex re-kind) {
	     list (list (exact-string (ph a*)) re-flags) (pt a*)
	   })
	   ((eq? :re re-kind) {
	     list (list (ph a*) re-flags) (pt a*)
	   }))
	}))
     }))
  }

  define (process-clauses c* i i* k* b*) {
    (cond
     ((null? c*) (list (reverse i*) (reverse k*) (reverse b*)))
     ((or (not (pair? c*))
	  (not (pair? (ph c*)))
	  (not (pair? (pth c*)))) (error/type ^rt-syntax-error 'expect-case "invalid syntax" c*))
     (else {
       ;; key body
       kb := process-args #n #n (ph c*)
       process-clauses (pt c*) (i + 1) (pair i i*) (pair (ph kb) k*) (pair (pht kb) b*)
     }))

  }

  ikb := process-clauses clauses 0 #n #n #n

  n := length clauses
  exp-match := gensym 'e-m

  #T{
    {
      $expect-regcomps := make-array $n
      $@(map (function (i t) {
	;; t is kw|(str flags)
	(cond
	 ((keyword? t) {
	   #T{
	     array-set! $expect-regcomps $i $t
	   }
	 })
	 (else {
	   #T{
	     array-set! $expect-regcomps $i (apply regcomp $(ph t) $(pht t))
	   }
	 }))
      }) (ph ikb) (pht ikb))
      
      exp-continue := #f

      define ($exp-match spawn-id) {
	(cond
	 $@(map (function (i k b) {
	   (case k
	    ((:eof) {
	      #T{
		((struct-spawn-eof spawn-id) => (function (r) {
		  set-struct-spawn-matched! spawn-id #t
		  ((function (spawn-id)
		   $@b) spawn-id)
		}))
	      }
	    })
	    ((:timeout) {
	      #T{
		((struct-spawn-timeout spawn-id) => (function (r) {
		  set-struct-spawn-matched! spawn-id #t
		  ((function (spawn-id)
		   $@b) spawn-id)
		}))
	      }
	    })
	    (else {
	      #T{
		((regexec (array-ref $expect-regcomps $i) (struct-spawn-buffer spawn-id) 'REG_VERBOSE)
		 => (function (r) {
		   set-struct-spawn-matched! spawn-id #t
		   r0 := r.0
		   prefix := substring (struct-spawn-buffer spawn-id) 0 r0.2
		   set-struct-spawn-buffer! spawn-id (substring (struct-spawn-buffer spawn-id) r0.3)

		   ((function (spawn-id r prefix)
		    $@b) spawn-id r prefix)
		 }))
	      }
	    }))
	 }) (ph ikb) (pht ikb) (phtt ikb)))
      }

      t0 := SECONDS

      exp-continue = function #n    {
	set-struct-spawn-matched! spawn-id #f
   
   	;; search existing buffer
   	$exp-match spawn-id

   	if (not (struct-spawn-matched spawn-id)) {
   	  set-struct-spawn-timeout! spawn-id #f
   	  set-struct-spawn-eof! spawn-id #f

   	  mfd := struct-spawn-mfd spawn-id
   	  poller := libc/make-poller (list mfd libc/POLLIN)

   	  poll-results := libc/poller-poll poller (expect-timeout * 1000)

   	  (cond
   	   ((null? poll-results) {
   	     set-struct-spawn-timeout! spawn-id #t
   	   })
   	   (else {
   	     for p-r in poll-results {
   	       poll-fd := ph p-r
   	       poll-revents := pht p-r
   	       (cond
   		((libc/POLLIN? poll-revents) {
   		  data := libc/read poll-fd 1024
   		  if data {
   		    if (eof-object? data) {
   		      libc/poller-deregister poller poll-fd
		      set-struct-spawn-eof! spawn-id #t
   		    } {
   		      set-struct-spawn-buffer! spawn-id (append-string (struct-spawn-buffer spawn-id) data)
   		    }
   		  }
   		})
   		((or (libc/POLLHUP? poll-revents)
   		     (libc/POLLERR? poll-revents)) {
   		  libc/poller-deregister poller poll-fd
		  set-struct-spawn-eof! spawn-id #t
   		}))
   	     }
   	   }))
   	  $exp-match spawn-id

	  if (not (struct-spawn-matched spawn-id)) {
	    if ((string-length (struct-spawn-buffer spawn-id)) gt expect-match-max) {
	      set-struct-spawn-buffer! spawn-id (substring (struct-spawn-buffer spawn-id) (- expect-match-max))
	    }
	    (exp-continue)
	  }
   	}
      }

      (exp-continue)
    }
  }
}

provide expect
