;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; module.idio
;;

;; Following in the style of STklos

;; define-module
;;
;; We'll use a stack while processing (nested) define-module
;; statements which we can unwind if there's an error
%module-stack := #n

define (%module-push name) {
  %module-stack = pair (current-module) %module-stack
  %find-or-create-module name
}

define (%module-pop) {
  prev := ph %module-stack
  %module-stack = pt %module-stack
  prev
}

define (%module-handler c) {
  mod := (%module-pop)
  %set-current-module! mod
  raise c
}

define-template (define-module name & body) {
  #T{
    with-condition-handler ^condition %module-handler {
      %set-current-module! (%module-push $name)
      $@body
      %set-current-module! (%module-pop)
      (void)
    }
  }
}

define-template (in-module name & body) "Run `body` in module `name`

Control will revert to the current module on exit or any ^condition" {
  #T{
    with-condition-handler ^condition %module-handler {
      %set-current-module! (%module-push $name)
      $@body
      %set-current-module! (%module-pop)
      (void)
    }
  }
}

;; module and load are concomitant
;;
;; {module} simply sets the current module but {load} now needs to be
;; module-aware and restore the original module value at the end of
;; file or on an error
define-template (module name) {
  #T{
    %set-current-module! (%find-or-create-module '$name)
  }
}

{
  orig-load := load
  orig-load-handle := load-handle

  load = function (filename) "
load Idio code from ``filename``

:param filename: the filename to load from
:type filename: string

This is the module variant which handles changes to the current module
and calls

------------------------------
  " {
    if (not (string? filename)) (error 'load "not a string" filename)

    cmod := (current-module)
    load-r := #n

    unwind-protect {
      load-r = orig-load filename
    } {
      %set-current-module! cmod
    }


    ; I suspect the result of load is ignored by most but let's dot
    ; the i's and cross the t's etc..
    load-r
  }

  %set-property! load :docstr-raw (append-string (%property load :docstr-raw) (%property orig-load :docstr-raw))

  load-handle = function (handle) "
load Idio code from ``handle``

:param handle: the handle to load from
:type handle: handle

This is the module variant which handles changes to the current module
and calls

------------------------------
" {
    if (not (handle? handle)) (error 'load-handle "not a handle" handle)

    cmod := (current-module)
    load-handle-r := #n

    unwind-protect {
      load-handle-r = orig-load-handle handle
    } {
      %set-current-module! cmod
    }

    ; I suspect the result of load-handle is ignored by most but let's dot
    ; the i's and cross the t's etc..
    load-handle-r
  }

  %set-property! load-handle :docstr-raw (append-string (%property load-handle :docstr-raw) (%property orig-load-handle :docstr-raw))

}


;; module-import

;; This is slightly messed about because we have an existing ordered
;; list of imports, say, (I1 I2 I3) and we want to prepend an ordered
;; list of modules to be imported, say, (M1 M2).  Of course we have
;; the usual list-y thing of prepending to some list which means
;; working with a reversed list in-hand.

;; We should be require'ing the modules in order, M1 then M2, and the
;; resultant list of module imports should be (M1 M2 I1 I2 I3).

define (%module-import importer module*) {
  loop :+ function (m* r) {
	    cond ((null? m*) {
	      %set-module-imports! importer (append (reverse r) (module-imports importer))
	    }) \
		 (else {
		   mod-name := ph m*
		   subfeatures := #n
		   if (pair? mod-name) {
		     subfeatures = pt mod-name
		     mod-name = ph mod-name
		   }
		   mod := find-module mod-name #f
		   if mod {
		     loop (pt m*) (if (or (eq? mod importer)
					  (assq mod r))
				   r {
				     apply require (module-name mod) subfeatures
				     pair (list mod) r
				   })
		   } {
		     apply require mod-name subfeatures
		     mod := find-module mod-name #f
		     if mod {
		       loop (pt m*) (pair (list mod) r)
		     } (error '%module-import "failed to instantiate module" mod-name)
		   }
		 })
  }

  if (null? module*) #n {
    loop module* #n
  }
}

define-template (import & module*) {
  if (null? module*) #n #T{
    %module-import (current-module) '$module*
  }
}

;; %module-export
define (%module-export exporter symbols) {
  loop :+ function (syms result) {
    if (null? syms) {
      %set-module-exports! exporter result
    } {
      sym := ph syms
      if (symbol? sym) {
	loop (pt syms) (if (memq sym result) result (pair sym result))
      } {
	error 'export "not a symbol" sym
      }
    }
  }

  loop symbols (module-exports exporter)
}

;; export sym ...
;; export (sym
;;	   ...)
define-template (export & symbols) {
  cond ((null? symbols) #n) \
       ((pair? (ph symbols)) {
	 #T{
	   %module-export (current-module) '$(ph symbols)
	 }
       }) \
       (else {
	 #T{
	   %module-export (current-module) '$symbols
	 }
       })
}
