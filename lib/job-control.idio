;;
;; Copyright (c) 2015, 2017, 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;
module job-control

#*

Even though we import libc here in job-control (because we do a lot of
libc-ish things) the templates/operators we export -- which will be
expanded in the user's namespace -- will try to use those libc values
and we have no idea if they, the importer (of us), has imported libc
themselves.  We don't want to force them to import libc as it
annoyingly duplicates many names.

So the "fix" is to ensure that the templates/operators we export
dutifully call the libc/X "direct" names for any libc X they use and
that we export X here.

There's nominally no such problem with our own names,
eg. add-process-substitution-job, as bootstrap imports job-control.
However, templates/operators should probably use direct names
regardless.

*#

import libc
export (%idio-interactive
	%idio-jobs
	%%last-job
	job-failed
	job-detail
	pipeline-detail
	%prep-process
	background-job
	foreground-job
	default-child-handler
	%%process-substitution-jobs
	add-process-substitution-job
	tidy-process-substitution-job
	wait-for-job

	format-job-detail

	; default SIGCHLD handler via SIGCHLD clause in
	; default-condition-handler (condition.c) and
	; idio_command_SIGCHLD_signal_handler (command.c) which has
	; idio_vm_invoke_C() call "do-job-notification"

	do-job-notification

	bg-job
	wait
	with-input-from
	with-output-to
	with-error-to

	collect-output
	cat-file

	with-handle-dup
	with-handle-redir

	jobs)


export-struct-accessors-only %idio-process	argv exec pid completed stopped status
export-struct-accessors-only %idio-job		pipeline procs pgid notified raised tcattrs stdin stdout stderr report-timing timing-start timing-end async

%%last-job := #n

define (process-as-string proc seen) {
  if (%idio-process? proc) {
    r := (open-output-string)
    hprintf r "#<SI %%idio-process "

    hprintf r "PID=%s C?=%s S?%s: " (%idio-process-pid proc) (%idio-process-completed proc) (%idio-process-stopped proc)
    if (%idio-process-completed proc) {
      status := %idio-process-status proc
      (cond
       ((null? status) {
	 hprintf r " running: "
       })
       ((WIFEXITED status) {
	 hprintf r " exit %d: " (WEXITSTATUS status)
       })
       ((WIFSIGNALED status) {
	 hprintf r " kill -%d: " (WTERMSIG status)
       })
       (else {
	 hprintf r " unknown: "
       }))
    }
    hprintf r "%s " (%idio-process-argv proc)

    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string %idio-process process-as-string

define (job-as-string job seen) {
  if (%idio-job? job) {
    r := (open-output-string)
    hprintf r "#<SI %%idio-job "

    hprintf r "pgid=%d %s " (%idio-job-pgid job) (%idio-job-pipeline job)

    procs-first := #t
    procs-loop :+ function (procs) {
		    if (null? procs) #n {
		      proc := ph procs
		      if (null? proc) #t {
			if procs-first {
			  procs-first = #f
			} {
			  hprintf r "| "
			}
			hprintf r "[PID=%s C?=%s S?%s: " (%idio-process-pid proc) (%idio-process-completed proc) (%idio-process-stopped proc)
			if (%idio-process-completed proc) {
			  status := %idio-process-status proc
			  (cond
			   ((null? status) {
			     hprintf r " running: "
			   })
			   ((WIFEXITED status) {
			     hprintf r " exit %d: " (WEXITSTATUS status)
			   })
			   ((WIFSIGNALED status) {
			     hprintf r " kill -%d: " (WTERMSIG status)
			   })
			   (else {
			     hprintf r " unknown: "
			   }))
			}
			hprintf r "%s] " (%idio-process-argv proc)
			procs-loop (pt procs)
		      }
		    }
    }

    procs-loop (%idio-job-procs job)

    hprintf r "rt?%s %s %s a?=%s" (%idio-job-report-timing job) (%idio-job-timing-start job) (%idio-job-timing-end job) (%idio-job-async job)

    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string %idio-job job-as-string

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#*

%process-substitution-job describes the two alternatives for handling
process substitution pathnames using either the /dev/fd format (most
systems) or true named pipes (FreeBSD).

For /dev/fd systems we'll have used a pipe(2) and created the /dev/fd/
pathnames based on the pipe's file descriptors.  We only need close
the file descriptor {fd} so {path} and {dir} are #f.

For true named pipes we need to call mkfifo(2).  mktemp(3) is frowned
upon so we mkdtemp(3) for {dir} and append "/the-pipe" to get {path}.
There is no associated file descriptor so {fd} is #f.

On removal we can unlink(2) {path} then rmdir(2) {dir}.

{dir} is saving us having to split {path} to find the directory
component when we had it in our hands to begin with.

*#

export-struct %process-substitution-job		read fd path dir suppress

%%process-substitution-jobs := #{}

define (add-process-substitution-job job psj) {
  hash-set! %%process-substitution-jobs job psj
}

define (tidy-process-substitution-job job) {
  if (hash-exists? %%process-substitution-jobs job) {
    jd := job-detail job
    psj := hash-ref %%process-substitution-jobs job
    hash-delete! %%process-substitution-jobs job
    fd := (%process-substitution-job-fd psj)
    if fd {
      ;; everything except a read pipe that exited 0 gets closed
      if (not (and (%process-substitution-job-read psj)
		   (eq? (ph jd) 'exit)
		   (C/== (pht jd) C/0i))) {
		     ;; We're not using suppress-errors! and
		     ;; libc/close as we expect the fd to already have
		     ;; been closed (in
		     ;; idio_job_control_launch_1proc_job() or by the
		     ;; user directly) and so the suppress-errors!
		     ;; templated trap is far far (far) more code than
		     ;; up to two system calls require

		     libc/close-if-open fd
		   }
    }
    if (%process-substitution-job-path psj) {
      libc/unlink (%process-substitution-job-path psj)
      libc/rmdir (%process-substitution-job-dir psj)
    }

    pgid := %idio-job-pgid job
    if (C/> pgid libc/0pid_t) {
      if (not (job-is-completed job)) {
	eprintf "%6d: tidy-psj: kill -TERM %d:\n" PID pgid
	format-job-detail job (current-error-handle)
	suppress-errors! ^system-error killpg pgid SIGTERM
      }
    } {
      eprintf "%6d: tidy-psj: kill -TERM %d? from %s\n" PID pgid job
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#*

These algorithms are directly from the libc info pages on Job
Control: "info libc" then "Job Control" then "Implementing a Shell"

*#

define (job-is-stopped job) "test if job `job` is stopped

:param job: job to test

:return: #t if job `job` is stopped, #f otherwise
" {
  if (null? job) (error 'job-is-stopped "null job" job)

  loop :+ function (procs) {
	    (cond
	     ((null? procs) #t)
	     ((and (not (%idio-process-completed (ph procs)))
		   (not (%idio-process-stopped (ph procs)))) #f)
	     (else (loop (pt procs))))
  }

  loop (%idio-job-procs job)
}

define (job-is-completed job) "test if job `job` has completed

:param job: job to test

:return: #t if job `job` has completed, #f otherwise
" {
  if (null? job) (error 'job-is-completed "null job" job)

  loop :+ function (procs) {
	    (cond
	     ((null? procs) {
	       set-%idio-job-timing-end! job (list (libc/gettimeofday) (libc/getrusage libc/RUSAGE_SELF) (libc/getrusage libc/RUSAGE_CHILDREN))
	       #t
	     })
	     ((not (%idio-process-completed (ph procs))) #f)
	     (else {
	       loop (pt procs)
	     }))
  }

  loop (%idio-job-procs job)
}

define (job-failed job) "test if job `job` has failed

:param job: job to test
:return: #t if job `job` has failed, #f otherwise

If ``suppress-pipefail!`` is not ``#f`` then nominally failed
left-hand processes are ignored
" {
  if (null? job) (error 'job-failed "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #f {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (or (C/== (WEXITSTATUS status) C/0i)
			(and suppress-pipefail!
			     (not (null? (pt procs))))) {
			       loop (pt procs)
			     } #t
	       })
	       ((WIFSIGNALED status) {
		 if (and suppress-pipefail!
			 (not (null? (pt procs)))) {
			   loop (pt procs)
			 } #t
	       })
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  if (job-is-completed job) {
    loop (%idio-job-procs job)
  } #f
}

;; job-status => #t/#f
define (job-status job) "test if job `job` has a process status

:param job: job to test
:return: #f if job `job` has a process status, #t otherwise

Note that this is the inverse behaviour you might expect.

If ``suppress-pipefail!`` is not ``#f`` then nominally failed
left-hand processes are ignored
" {
  if (null? job) (error 'job-status "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #t {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (or (C/== (WEXITSTATUS status) C/0i)
			(and suppress-pipefail!
			     (not (null? (pt procs))))) {
			       loop (pt procs)
			     } #f
	       })
	       ((WIFSIGNALED status) {
		 if (and suppress-pipefail!
			 (not (null? (pt procs)))) {
			   loop (pt procs)
			 } #f
	       })
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  loop (%idio-job-procs job)
}

;; job-detail => '(exit X) or '(killed Y)
define (job-detail job) "return the process status of job `job`

:param job: job

:return: a (kind value) list

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed

If ``suppress-pipefail!`` is not ``#f`` then nominally failed
left-hand processes are ignored
" {
  if (null? job) (error 'job-detail "null job" job)

  last-proc := #f

  loop :+ function (procs) {
	    if (null? procs) #f {
	      last-proc = ph procs
	      status := %idio-process-status last-proc
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (or (C/== (WEXITSTATUS status) C/0i)
			(and suppress-pipefail!
			     (not (null? (pt procs))))) {
			       loop (pt procs)
			     } {
			       list 'exit (WEXITSTATUS status)
			     }
	       })
	       ((WIFSIGNALED status) {
		 if (and suppress-pipefail!
			 (not (null? (pt procs)))) {
			   loop (pt procs)
			   } {
			     list 'killed (WTERMSIG status)
			   }
	       })
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or '(running) if it hadn't actually exited)
  (or (loop (%idio-job-procs job))
      {
	status := %idio-process-status last-proc
	(cond
	 ((null? status) (list 'running))
	 ((WIFEXITED status) (list 'exit C/0i))
	 (else (list 'unknown)))
      })
}

define (pipeline-detail job) "return the process status of each process in the pipeline `job`

:param job: job

:return: a list of (kind value) lists

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed
" {
  if (null? job) (error 'pipeline-detail "null job" job)

  loop :+ function (procs st) {
	    if (null? procs) (reverse st) {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs) (pair (list 'running) st)
	       })
	       ((WIFEXITED status) {
		 loop (pt procs) (pair (list 'exit (WEXITSTATUS status)) st)
	       })
	       ((WIFSIGNALED status) {
		 loop (pt procs) (pair (list 'killed (WTERMSIG status)) st)
	       })
	       (else {
		 loop (pt procs) (pair (list 'unknown) st)
	       }))
	    }
  }

  loop (%idio-job-procs job) #n
}

define (mark-process-status pid status) "update the process status of pid `pid` with `status`

:param pid: process id
:param status: Unix process status

:return: #t if the update was successfull, #f otherwise

Store the `status` of the process `pid` that was returned by
waitpid(2).  Return #f if all went well, some true value otherwise.

This (inverted) convention follows the Libc texinfo algorithm and is
for the benefit of the do loops in update-status_ and wait-for-job_.
" {
  (cond
   ((C/> pid libc/0pid_t) {
     jobs-loop :+ function (jobs) {
		    (cond
		     ((null? jobs) {
		       if %idio-interactive {
			 eprintf "no child process %d\n" pid
		       }
		       hash-set! %idio-stray-pids pid status
		       #t
		     })
		     (else {
		       ;; procs-loop follows the same convention as the outer
		       ;; jobs-loop as returning success (#f!) will be the return
		       ;; value of jobs-loop
		       procs-loop :+ function (procs) {
				       (cond
					((null? procs) #t)
					((C/== pid (%idio-process-pid (ph procs))) {
					  set-%idio-process-status! (ph procs) status
					  if (WIFSTOPPED status) {
					    set-%idio-process-stopped! (ph procs) #t
					  } {
					    set-%idio-process-completed! (ph procs) #t
					    if (and %idio-interactive
						    (WIFSIGNALED status)) {
						      eprintf "Job Terminated: kill -%s %d\n" (signal-name (WTERMSIG status)) pid
						    }
					  }
					  #f
					})
					(else {
					  procs-loop (pt procs)
					}))
		       }

		       (and (procs-loop (%idio-job-procs (ph jobs)))
			    (jobs-loop (pt jobs)))
		     }))
     }

     jobs-loop %idio-jobs
   })
   ((C/== pid libc/0pid_t) {
     (cond
      ((C/== libc/errno libc/ECHILD) {
	;; We can get here if foreground-job was blocked in
	;; wait-for-job then a SIGCHLD event fired and the
	;; (default) handler calls do-job-notification.
	#t
      })
      ((C/pointer? status) {
	;; waitpid(2): if WNOHANG was specified and one or more
	;; child(ren) specified by pid exist, but have not yet changed
	;; state, then 0 is returned
	#t
      })
      ((null? status) {
	;; this should have been picked up by ECHILD, above...
	eprintf "mark-process-status: pid==0 status==#n errno!=ECHILD??\n"
      })
      (else {
	error 'mark-process-status "inconceivable errno!" pid status (libc/errno-name libc/errno)
      }))
     })
   (else {
     ;; an error in waitpid would have been signalled there
     error 'mark-process-status "inconceivable!" pid status
   }))
}

define (update-status) "update the process status of any outstanding pids

:return: #<unspec>
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY (WUNTRACED C/| WNOHANG))
  }

  do () ((call-with-values waitany mark-process-status) #n) #n
}

define (wait-for-job job) "wait for job `job` to be stopped or completed

:param job: job

:return: job status
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY WUNTRACED)
  }

  do () ((not (and (not (call-with-values waitany mark-process-status))
	           (not (job-is-stopped job))
	           (not (job-is-completed job))))
         #n) #n

  ;eprintf "wfj: %5s C=%s S=%s %s %s\n" (%idio-job-pgid job) (job-is-completed job) (job-is-stopped job) (if (job-failed job) "failed" "succeeded") (pipeline-detail job)

  if (job-is-completed job) {
    tidy-process-substitution-job job
  }

  if (job-failed job) {
    if (not (%idio-job-raised job)) {
      ct := ^rt-command-status-error
      if (%idio-job-async job) {
	ct = ^rt-async-command-status-error
      }
      c := make-condition ct "job failed" job (pipeline-detail job) (job-detail job)
      set-%idio-job-raised! job #t
      reraise c
    }
  }

  job-status job
}

define (format-job-info job msg) "display to stderr `msg` alongside job `job` details

:param job: job
:param msg: string

:return: #<unspec>
" {
  if %idio-interactive {
    jd := job-detail job
    if (not (equal? (list 'exit C/0i) jd)) {
      eprintf "job %6s: %s: %s: %s\n" (%idio-job-pgid job) (%idio-job-pipeline job) msg jd
    }
  }
}

define (format-job-detail job & args) {
  oh := (current-output-handle)
  if (pair? args) {
    oh = ph args
  }

  ;; cf. condition-report
  header := #t
  printed := #f
  loop :+ function (procs details) {
	    (cond
	     ((null? procs) #t)
	     (else {
	       if header {
		 header = #f
		 hprintf oh "        %6s %-3s %-12s %s\n" "PID" "fl" "status" "cmd"
	       }
	       proc := ph procs
	       hprintf oh "  proc: %6s %2s%s %-12s %s\n" (%idio-process-pid proc) (if (%idio-process-completed proc) " C" "!C") (if (%idio-process-stopped proc) "S" " ") (ph details) (%idio-process-argv proc)
	       printed = #t
	       loop (pt procs) (pt details)
	     }))
  }

  hprintf oh "\n"
  hprintf oh "job %6s: a?=%s: %s\n" (%idio-job-pgid job) (%idio-job-async job) (%idio-job-pipeline job)
  loop (%idio-job-procs job) (pipeline-detail job)
  if printed {
    hprintf oh "  flags: C - completed; !C - not completed; S - stopped\n"
  }

  ;; cf. time/time-command in common.idio
  timing-start := %idio-job-timing-start job
  timing-end   := %idio-job-timing-end job

  if (and timing-start
	  timing-end) {
	    tv-before    := ph timing-start
	    rus-before   := pht timing-start
	    ruc-before   := phtt timing-start
	    tv-end       := ph timing-end
	    rus-end      := pht timing-end
	    ruc-end      := phtt timing-end

	    ;; See the commentary for time-command in
	    ;; common.idio about this algorithm
	    h := (make-hash)
	    hash-set! h #\R (libc/subtract-struct-timeval tv-end tv-before)
	    hash-set! h #\U (libc/add-struct-timeval
			     (libc/subtract-struct-timeval (libc/struct-rusage-ref rus-end    'ru_utime)
							   (libc/struct-rusage-ref rus-before 'ru_utime))
			     (libc/subtract-struct-timeval (libc/struct-rusage-ref ruc-end    'ru_utime)
							   (libc/struct-rusage-ref ruc-before 'ru_utime)))

	    hash-set! h #\S (libc/add-struct-timeval
			     (libc/subtract-struct-timeval (libc/struct-rusage-ref rus-end    'ru_stime)
							   (libc/struct-rusage-ref rus-before 'ru_stime))
			     (libc/subtract-struct-timeval (libc/struct-rusage-ref ruc-end    'ru_stime)
							   (libc/struct-rusage-ref ruc-before 'ru_stime)))

	    js := (libc/struct-timeval-ref (ph timing-start) 'tv_sec)
	    je := (libc/struct-timeval-ref (ph timing-end) 'tv_sec)
	    hprintf oh " Started at %s, ran for %ss\n" (libc/strftime "%c" (libc/localtime js)) (je - js)
	    hprintf oh " %s" (%format 'timeformat "R %5.3R; U %5.3U; S %5.3S" h)
	    hprintf oh "\n"
	  } {
	    if (not timing-start) {
	      hprintf oh "timing-start is unset? "
	    } {
	      js := (libc/struct-timeval-ref (ph timing-start) 'tv_sec)
	      hprintf oh "Started at %s, %ds ago; " (libc/strftime "%c" (libc/localtime js)) ((libc/time) - js)
	    }
	    if (not timing-end) {
	      hprintf oh "timing-end=%s" timing-end
	    }
	    hprintf oh "\n"
	  }
}

define (do-job-notification) "notify of any job status changes" {
  (update-status)

  failed-jobs := #n

  loop :+ function (jobs njobs) {
	    (cond
	     ((null? jobs) (reverse njobs))
	     (else {
	       job := ph jobs
	       (cond
		((job-is-completed job) {

		  tidy-process-substitution-job job

		  format-job-info job "completed"

		  ;; cf. time/time-command in common.idio
		  if (%idio-job-report-timing job) {
		    timing-start := %idio-job-timing-start job
		    tv-before    := ph timing-start
		    rus-before   := pht timing-start
		    ruc-before   := phtt timing-start
		    timing-end   := %idio-job-timing-end job
		    tv-end       := ph timing-end
		    rus-end      := pht timing-end
		    ruc-end      := phtt timing-end

		    ;; See the commentary for time-command in
		    ;; common.idio about this algorithm
		    h := (make-hash)
		    hash-set! h #\R (libc/subtract-struct-timeval tv-end tv-before)
		    hash-set! h #\U (libc/add-struct-timeval
				     (libc/subtract-struct-timeval (libc/struct-rusage-ref rus-end    'ru_utime)
								   (libc/struct-rusage-ref rus-before 'ru_utime))
				     (libc/subtract-struct-timeval (libc/struct-rusage-ref ruc-end    'ru_utime)
								   (libc/struct-rusage-ref ruc-before 'ru_utime)))

		    hash-set! h #\S (libc/add-struct-timeval
				     (libc/subtract-struct-timeval (libc/struct-rusage-ref rus-end    'ru_stime)
								   (libc/struct-rusage-ref rus-before 'ru_stime))
				     (libc/subtract-struct-timeval (libc/struct-rusage-ref ruc-end    'ru_stime)
								   (libc/struct-rusage-ref ruc-before 'ru_stime)))

		    printf "%s" (%format 'timeformat TIMEFORMAT h)
		  }

		  if (job-failed job) {
		    failed-jobs = pair job failed-jobs
		  }

		  ;; remove job from list (by not including it!)
		  loop (pt jobs) njobs
		})
		((job-is-stopped job) {
		  if (not (%idio-job-notified job)) {
		    format-job-info job "stopped"
		    set-%idio-job-notified! job #t
		  }
		  loop (pt jobs) (pair job njobs)
		})
		(else {
		  loop (pt jobs) (pair job njobs)
		}))
	     }))
  }

  %idio-jobs = loop %idio-jobs #n

  #*

  This report->raise condition for failed jobs is badly positioned.
  The problem lies in that we, do-job-notification, have run on the
  back of a SIGCHLD event but will have had nothing to report (in the
  simplest case) because our call to update-status resulted in a pid
  of 0 and/or errno ECHILD.  That's because foreground-job, say, was
  blocked in wait-for-job who had (successfully) called waitpid but
  further processing has been suspended while the event handler runs.
  Only when we return will it be able to continue and usefully call
  mark-process-status with a proper pid and status.

  This isn't an Idio-issue, the Libc texinfo C version (from which
  this is ported) appears to suffer the same problem.

  Underlying that is that, perhaps, we shouldn't be calling
  do-job-notification from the signal handler.  The texinfo suggests
  SIGCHLD->do-job-notification should only enabled when waiting at the
  prompt for user input and not, say, while generically processing
  loaded files.

  All good, but that leaves us with the question of when to raise a
  condition to alert the Idio code?  I've migrated that to
  wait-for-job itself.  It knows the job is complete and can assert if
  the job failed.

  *#

  if (not (null? failed-jobs)) {
    report :+ function (jobs) {
		(cond
		 ((null? jobs) #n)
		 (else {
		   job := ph jobs
		   if (not (%idio-job-raised job)) {
		     ct := ^rt-command-status-error
		     if (%idio-job-async job) {
		       ct = ^rt-async-command-status-error
		     }
		     c := make-condition ct "job failed" job (pipeline-detail job) (job-detail job)
		     set-%idio-job-raised! job #t
		     reraise c
		   }

		   ;; if someone handled that error and returned (anything)
		   ;; then we can loop onto the next
		   report (pt jobs)
		 }))
    }

    report failed-jobs
  }

  #n
}

define (foreground-job job cont) "place job `job` in the foreground

:param job: job
:param cont: boolean

:return: job status

If `cont` is set a SIGCONT is sent to the process group
" {

  if %idio-interactive {
    ;; put the job in the foreground
    suppress-errors! ^system-error tcsetpgrp %idio-terminal (%idio-job-pgid job)
  }

  if cont {
    if %idio-interactive {
      tcsetattr %idio-terminal TCSADRAIN (%idio-job-tcattrs job)
    }

    killpg (%idio-job-pgid job) SIGCONT
  }

  r := wait-for-job job

  if %idio-interactive {
    ;; put the shell back in the foreground
    tcsetpgrp %idio-terminal %idio-pgid

    ;; save the job's current terminal state
    set-%idio-job-tcattrs! job (tcgetattr %idio-terminal)

    ;; restore the shell's terminal state
    tcsetattr %idio-terminal TCSADRAIN %idio-tcattrs
  }

  r
}

define (background-job job cont) "place job `job` in the background

:param job: job
:param cont: boolean

:return: #t

If `cont` is set a SIGCONT is sent to the process group

Backgrounding a job is always successful hence returns #t
" {
  job-pgid := %idio-job-pgid job
  if cont {
    killpg job-pgid SIGCONT
  }

  ;; result of background-job is always successful, ie. #t
  #t
}

define (hangup-job job) "hangup job `job`

:param job: job

:return: #<unspec>

Send the process group of `job` a SIGCONT then a SIGHUP
" {
  eprintf "hangup-job: %s\n" job
  job-pgid := %idio-job-pgid job
  killpg job-pgid SIGCONT
  killpg job-pgid SIGHUP

  ;; result of hungup-job is #t
  #t
}

define (SIGTERM-stopped-jobs) {
  loop :+ function (jobs) {
	    if (null? jobs) #t {
	      job := ph jobs
	      pgid := %idio-job-pgid job

	      if (C/> pgid libc/0pid_t) {
		if %idio-interactive {
		  eprintf "%6d: SIGTERM -> pgid %d\n" PID pgid
		}

		;; Following in the style of Bash's
		;; terminate_stopped_jobs() issue the SIGTERM before
		;; the SIGCONT

		;; ignore errors, we're shutting down
		;suppress-errors! ^system-error killpg pgid SIGTERM
		;suppress-errors! ^system-error killpg pgid SIGCONT
		killpg pgid SIGTERM
		killpg pgid SIGCONT
	      } {
		if %idio-interactive {
		  eprintf "%6d: SIGTERM -> pgid %d ??\n" PID pgid
		  eprintf "job %s\n" job
		}
	      }
	      loop (pt jobs)
	    }
  }

  if (not (null? %idio-jobs)) {
    ;; take a copy of %idio-jobs in case the value is perturbed by
    ;; jobs shutting down during this loop
    jobs := %idio-jobs
    if %idio-interactive {
      eprintf "%6d: SIGTERM: outstanding jobs: %s\n" jobs
    }

    suppress-async-command-report! = #t
    loop jobs
  }
}

define (stop-job job) {
  job-pgid := %idio-job-pgid job
  killpg job-pgid SIGSTOP

  ;; result of stop-job is #t
  #t
}

define (mark-job-as-running job) "mark job `job` as running

:param job: job

:return: #<unspec>

In particular, mark job `job` as not stopped.
" {
  loop :+ function (procs) {
	    (cond
	     ((null? procs) #n)
	     (else {
	       set-%idio-process-stopped! (ph procs) #f
	       loop (pt procs)
	     }))
  }

  loop (%idio-job-procs job)
  set-%idio-job-notified! job #f
}

define (continue-job job foreground) "mark job `job` as running and foreground it if required

:param job: job
:param foreground: boolean

:return: #<unspec>
" {
  mark-job-as-running job
  if foreground {
    foreground-job job #t
  } {
    background-job job #t
  }
}

define (default-child-handler c) "
The default condition handler set in child processes.

It will report the condition and exit (1).
" {
  (cond-expand
   (IDIO_DEBUG-X {
     condition-report (sprintf "[%d] child-error-handler" (libc/getpid)) c (current-error-handle)
     eprintf "[%d] child process will exit (1)\n" (libc/getpid)
   }))

  libc/exit 1
}

define (prep-io infile outfile errfile) "prepare the IO for the current process

:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr

:return: #<unspec>
" {
  #*

  The nominal libc texinfo algorithm is:

    Switch stdin/stdout/stderr to the supplied file descriptor if it
    isn't already stdin/stdout/stderr.  (Here, the supplied file
    descriptor would commonly be one end or other of a pipe(2).)

    We can then close the supplied file descriptor if it is >
    STDERR_FILENO (ie. > 2) and isn't one of the later ones.

    That latter case is for: ls > "foo" 2>& 1

    Here, "stdout" will be fd N, say, having opened "foo" which we
    would close because N > 2, before we reached the "2>& 1" which
    tries to dup2(N, 2)

  However, we *must* set the Idio thread-specific input/output/error
  handles.  The problem lies in that this code, prep-io, is most
  likely called from the | operator in Idio-land in which case we are
  the *first* IO redirection.  However, the later IO redirections, (>
  >& etc.) reference the Idio thread-specific IO handles and *not*
  simply the STD*_FILENO file descriptors.  They do that because we
  can (seamlessly) use file-handles, string-handles, file descriptor
  numbers and ... instead of straight file names.  The use of
  string-handles means we have to create temporary files etc..

  In fact they call (libc/stdin-fileno) etc. which furtles about and
  conjures up a file descriptor which represents stdin etc..

  So, leave the final resolution of handle -> *nix file descriptor
  until the last thing before execve().  Just set Idio-level params.

  ---

  Named pipes complicate the issue.  Well, true named pipes at any
  rate.  /dev/fd systems are fine because in practice we are just
  using the file descriptors from pipe(2) but if we have to use a true
  named pipe (FreeBSD) then we need separate processes to open each
  end -- otherwise we block.  In other words
  libc/proc-subst-named-pipe-* cannot (pre-)open the named pipe for
  us, we need to delay opening until we're in a separate process.

  So we need to test if *file is a pathname and set the appropriate
  handle using that.  We're safe doing it here because %prep-process &
  prep-io are run in the child.

  *#

  (cond
   ((pathname? infile) {
     ifh := open-input-file infile
     ifd := file-handle-fd ifh
     dup2 ifd STDIN_FILENO
     close-handle ifh
     set-input-handle! (open-input-file-from-fd STDIN_FILENO)
   })
   ((C/int? infile) {
     if (not (C/== infile STDIN_FILENO)) {
       dup2 infile STDIN_FILENO
       close infile
       set-input-handle! (open-input-file-from-fd STDIN_FILENO)
     }
   })
   (else (error 'prep-io "unexpected infile format" infile)))

  (cond
   ((pathname? outfile) {
     ofh := open-output-file outfile
     ofd := file-handle-fd ofh
     dup2 ofd STDOUT_FILENO
     close-handle ofh
     set-output-handle! (open-output-file-from-fd STDOUT_FILENO)
   })
   ((C/int? outfile) {
     if (not (C/== outfile STDOUT_FILENO)) {
       dup2 outfile STDOUT_FILENO
       close outfile
       set-output-handle! (open-output-file-from-fd STDOUT_FILENO)
     }
   })
   (else (error 'prep-io "unexpected outfile format" outfile)))

  (cond
   ((pathname? errfile) {
     set-error-handle! (open-output-file errfile)
   })
   ((C/int? errfile) {
     if (not (C/== errfile STDERR_FILENO)) {
       dup2 errfile STDERR_FILENO
       close errfile
       set-error-handle! (open-output-file-from-fd errfile)
     }
   })
   (else (error 'prep-io "unexpected errfile format" errfile)))
}

define (%prep-process pgid infile outfile errfile foreground async-job) "prepare the current process

:param pgid: process group to be joined
:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr
:param foreground: place job in foreground

:return: #<unspec>
" {
  if (or %idio-interactive
	 async-job) {
	   pid := (libc/getpid)
	   if (C/== pgid libc/0pid_t) {
	     pgid = pid
	   }

	   ;; put the process in the process group -- dupe of parent to avoid
	   ;; race conditions
	   suppress-errors! ^system-error setpgid pid pgid
	 }

  if %idio-interactive {
    if foreground {
      ;; give the terminal to the process group -- dupe of parent to
      ;; avoid race conditions
      suppress-errors! ^system-error tcsetpgrp %idio-terminal pgid
    }

    ;; set job control signals back to default
    signal SIGINT SIG_DFL
    signal SIGQUIT SIG_DFL
    signal SIGTSTP SIG_DFL
    signal SIGTTIN SIG_DFL
    signal SIGTTOU SIG_DFL
    signal SIGCHLD SIG_DFL
  }

  prep-io infile outfile errfile
}

define-infix-operator | 700 {
  foreground  := #t
  use-w-pipe  := #f
  use-r-pipe  := #f
  collect     := #f
  report-time := #f
  async-job   := #f

  ;; Slightly annoyingly, some meta-instructions to the pipeline are
  ;; consumed by the reader operator (us!) so we should look out for
  ;; them.

  meta-loop :+ function () {
		 (case (ph before)
		       ((collect-output) {
			 before      = pt before
			 collect     = #t
			 foreground  = #t
			 async-job   = #t
			 (meta-loop)
		       })
		       ((fg-job) {
			 before      = pt before
			 foreground  = #t
			 (meta-loop)
		       })
		       ((bg-job) {
			 before      = pt before
			 foreground  = #f
			 (meta-loop)
		       })
		       ((named-pipe-into) {
			 before      = pt before
			 use-w-pipe  = 'named
			 foreground  = #f
			 async-job   = #t
			 (meta-loop)
		       })
		       ((pipe-into) {
			 before      = pt before
			 use-w-pipe  = #t
			 foreground  = #f
			 async-job   = #t
			 (meta-loop)
		       })
		       ((named-pipe-from) {
			 before      = pt before
			 use-r-pipe  = 'named
			 foreground  = #f
			 async-job   = #t
			 (meta-loop)
		       })
		       ((pipe-from) {
			 before      = pt before
			 use-r-pipe  = #t
			 foreground  = #f
			 async-job   = #t
			 (meta-loop)
		       })
		       ((time) {
			 before      = pt before
			 report-time = #t
			 (meta-loop)
		       }))
  }

  (meta-loop)

  orig-pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
	     (cond
	      ((null? after)		(reverse (pair (reverse expr) op-args)))
	      ((not (pair? after))	(error '| "bad syntax" op (reverse op-args) after))
	      ((eq? op (ph after))	(split op (pair (reverse expr) op-args) #n (pt after)))
	      (else			(split op op-args (pair (ph after) expr) (pt after))))
  }

  op-args := split op (list before) #n after

  ;; we have created new lists so we should expand any operators in
  ;; them
  op-args = map operator-expand op-args

  #*

  pgrp-pipe:

  There's a little process coordination trickery ported from Bash --
  noting that if the race condition occurs in a slick and fast pure C
  environment then our meandering and inefficient byte-compiled script
  has no hope!

  We need to prevent the first process in the pipeline from starting
  until all the others are in place -- otherwise you can have the
  first process, the process group leader, run and exit before you
  manage to start any of the others!  That also leaves the small issue
  of trying to call setpgid with a process group that no longer
  exists (and, worse, could have been replaced with a different
  process all together).  That's all bad for business.

  The trick is to open another pipe and have the first process block
  reading from the pipe just before it starts.  All the other
  processes in the pipeline simply close the pipe when they're about
  to exec/start.  When the last one has closed the pipe the first will
  have its blocking read() return (with zero bytes, ie EOF -- we don't
  care) and we're good to go.

  Incidentally, as we created the pipe in the main Idio process, it
  too holds the pipe open so we can be fairly confident that all the
  child processes are set up and running when the main Idio process
  closes the (last?) pgrp-pipe write-end.

  Well, probably, there's always a race condition between closing the
  pgrp-pipe and exec()ing or starting processing the Idio code in
  which the last process can be prevented from running before all the
  previous processes have been and gone.  But we've done a decent job,
  what more can we do?


  Hygiene

  Looping over the list of commands prepping the children uses a
  number of variables which are at risk of polluting the called
  code (if it is Idio code -- obviously if it is an external command
  we exec()'d it wouldn't matter).  Strict hygiene, please!

  Pipeline Bookkeeping

  Most of the work in a pipeline is done with file descriptors whereas
  the caller is dealing with handles.

  With named-pipe variants the result we return will be a pathname and
  not a handle.  Accordingly, various elements are named -fdn because
  they could be a file descriptor or a pathname.

  There is an overall $pipeline-r-fdn and $pipeline-w-fdn -- which the
  first and last commands use (indirectly via the per-command
  $cmd-r-fd and $cmd-w-fd).

  If the caller passed 'named-pipe-into or 'named-pipe-from as the
  first argument of the pipeline then $pipeline-*-fdn are pathnames:

  * /dev/fd/n for real pipes (most systems) or

  * /tmp/idio-np-xxxxxx for true named pipes (FreeBSD)

  for the caller to open and write into or read from the pipeline.

  If the caller passed 'pipe-into or 'pipe-from as the first argument
  of the pipeline then $pipeline-*-fdn are real pipes and the other
  ends of these are returned as pipe handles, $pipeline-w-phn and
  $pipeline-r-phn, for the caller to write into or read from the
  pipeline.

  $cmd-pipe is the inter-cmd pipe, created by the left hand command to
  generate its own output file descriptor and then to leave (trailing
  around the loop) an input file descriptor for the next command.

  For each command there is a per-cmd input file descriptor,
  $cmd-r-fd, and output file descriptor, $cmd-w-fd.

  The $cmd-r-fd is normally the pipe-reader of the previous command's
  $cmd-pipe except, of course, the first command whose $cmd-r-fd is
  $pipeline-r-fdn.

  The $cmd-w-fd is normally the pipe-writer of of $cmd-pipe except, of
  course, the last command whose $cmd-w-fd is $pipeline-w-fdn.

  The $pipeline-*-fdn, the overarching input and output of the entire
  pipeline, could be:

  1. entities figured out by (stdin-fileno):

     a. regular C STDIN_FILENO and STDOUT_FILENO

     b. whatever (current-input-handle) and (current-output-handle)
        actually are

     c. either of which which could be string-handles (necessitating
        temporary files and some post-pipeline content recovery)

  2. pathnames for either actual pipes or named pipes

  3. actual pipes!

  4. future *stuff* (sockets are the obvious missing contender)

  *#

  proc-subst-job         := gensym 'psj

  w-pipe		 := gensym 'w-pipe
  pipeline-r-fdn         := gensym 'pl-r-fd
  close-pipeline-r-fd    := gensym 'close-pl-r-fd
  pipeline-w-phn         := gensym 'pl-w-h
  cmd-r-fdn              := gensym 'cmd-r-fdn

  r-pipe		 := gensym 'r-pipe
  pipeline-w-fdn         := gensym 'pl-w-fd
  pipeline-r-phn         := gensym 'pl-r-h
  recover-pipeline-w-fd  := gensym 'rcvr-pl-w-fd
  cmd-w-fdn              := gensym 'cmd-w-fdn

  stderr                 := gensym 'stderr

  pgid                   := gensym 'pgid
  job                    := gensym 'job
  proc-id                := gensym 'proc-id
  cmd-pipe               := gensym 'cmd-pipe
  pgrp-pipe              := gensym 'pgrp-pipe
  proc                   := gensym 'proc
  pid                    := gensym 'pid
  status                 := gensym 'status

  nprocs := length op-args

  #T{
    {
      $proc-subst-job       := #f

      $w-pipe               := #f
      $pipeline-r-fdn       := #f
      $close-pipeline-r-fd  := #f
      $pipeline-w-phn       := #f
      (cond
       ((eq? $use-w-pipe 'named) {
	 named-pipe := (libc/proc-subst-named-pipe-into)
	 $pipeline-w-phn = (nth named-pipe 4)
	 ;; true named pipes will not have opened an fd so substitute the name
	 $pipeline-r-fdn = (or (nth named-pipe 1)
			       (nth named-pipe 3))

	 (cond
	  ((nth named-pipe 2) {
	    $proc-subst-job = job-control/make-%process-substitution-job #f (nth named-pipe 2) #f #f #f
	  })
	  (else {
	    $proc-subst-job = job-control/make-%process-substitution-job #f #f (nth named-pipe 4) (nth named-pipe 5) #f
	  }))
       })
       ($use-w-pipe {
	 $w-pipe         = (libc/pipe)
	 $pipeline-w-phn = open-output-pipe (libc/pipe-writer $w-pipe)
	 $pipeline-r-fdn = libc/pipe-reader $w-pipe
       })
       (else {
	 $pipeline-r-fdn         = (libc/stdin-fileno) ; STDIN_FILENO
	 if (pair? $pipeline-r-fdn) {
	   $pipeline-r-fdn       = ph $pipeline-r-fdn
	   $close-pipeline-r-fd = $pipeline-r-fdn
	 }
       }))
      ;; set $cmd-r-fdn now as it is used immediately in the loop
      $cmd-r-fdn := $pipeline-r-fdn

      $r-pipe                 := #f
      $pipeline-w-fdn         := #f
      $pipeline-r-phn         := #f
      $recover-pipeline-w-fd  := #f
      (cond
       ((eq? $use-r-pipe 'named) {
	 named-pipe := (libc/proc-subst-named-pipe-from)
	 $pipeline-r-phn = (nth named-pipe 3)
	 ;; true named pipes will not have opened an fd so substitute the name
	 $pipeline-w-fdn = (or (nth named-pipe 2)
			       (nth named-pipe 4))

	 (cond
	  ((nth named-pipe 1) {
	    $proc-subst-job = job-control/make-%process-substitution-job #t (nth named-pipe 1) #f #f #f
	  })
	  (else {
	    $proc-subst-job = job-control/make-%process-substitution-job #t #f (nth named-pipe 3) (nth named-pipe 5) #f
	  }))
       })
       ($use-r-pipe {
	 $r-pipe         = (libc/pipe)
	 $pipeline-r-phn = open-input-pipe (libc/pipe-reader $r-pipe)
	 $pipeline-w-fdn = libc/pipe-writer $r-pipe
       })
       ($collect {
	 $pipeline-w-fdn = (libc/make-tmp-fd)
       })
       (else {
	 $pipeline-w-fdn           = (libc/stdout-fileno) ; STDOUT_FILENO
	 if (pair? $pipeline-w-fdn) {
	   $recover-pipeline-w-fd = pht $pipeline-w-fdn
	   $pipeline-w-fdn         = ph $pipeline-w-fdn
	 }
       }))
      ;; $cmd-w-fdn is (re-)set each time round the loop but needs to
      ;; exist in the first place
      $cmd-w-fdn := #f

      ;; everyone gets the same stderr!
      $stderr := (libc/stderr-fileno) ; STDERR_FILENO

      $pgid      := libc/0pid_t
      $job       := (make-%idio-job '$orig-pipeline
				    #n
				    $pgid
				    #f
				    #f
				    #n
				    $pipeline-r-fdn
				    $pipeline-w-fdn
				    $stderr
				    $report-time
				    (list (libc/gettimeofday) (libc/getrusage libc/RUSAGE_SELF) (libc/getrusage libc/RUSAGE_CHILDREN))
				    #f
				    $async-job)

      $proc-id   := 1
      $cmd-pipe  := #n
      $pgrp-pipe := (libc/pipe)

      $@(map (function (cmd) {
	        #T{
		  {
		    $proc := make-%idio-process '$cmd #n -1 #f #f #n

		    ;; NB. Update the procs list asap as we can get a
		    ;; signal about processes in the pipeline at any
		    ;; time including, annoyingly, before we've
		    ;; finished creating the pipeline.
		    ;; do-job-notification/update-status will want to
		    ;; have a proc entry to update.
		    ;;
		    ;; NB this is a reversed order list -- we'll patch
		    ;; that up at the end
		    set-%idio-job-procs! $job (pair $proc (%idio-job-procs $job))

		    if ($proc-id lt $nprocs) {
		      $cmd-pipe = (libc/pipe)
		      $cmd-w-fdn = (libc/pipe-writer $cmd-pipe)
		    } {
		      $cmd-w-fdn = $pipeline-w-fdn
		    }
		    $pid := (libc/fork)
		    if (C/== $pid libc/0pid_t) {
		      set-default-handler! ^idio-error default-child-handler
		      job-control/%idio-jobs = #n
		      job-control/%%last-job = #n
		      job-control/%%process-substitution-jobs = #{}
		      %prep-process $pgid $cmd-r-fdn $cmd-w-fdn $stderr $foreground $async-job

		      (cond
		       ($use-w-pipe {
			 ;; sub-Idio should not hold the write end of
			 ;; the (named-)pipe-into pipe open (if a file
			 ;; descriptor) -- it will have been dup'ed in
			 ;; prep-io
			 if (eq? $use-w-pipe 'named) {
			   fd := %process-substitution-job-fd $proc-subst-job
			   if fd {
			     libc/close fd
			   }
			 } {
			   libc/close (libc/pipe-writer $w-pipe)
			 }
		       })
		       ($use-r-pipe {
			 ;; sub-Idio should not hold the read end of
			 ;; the (named-)pipe-from pipe open (if a file
			 ;; descriptor) -- it will have been dup'ed in
			 ;; prep-io
			 if (eq? $use-r-pipe 'named) {
			   fd := %process-substitution-job-fd $proc-subst-job
			   if fd {
			     libc/close fd
			   }
			 } {
			   libc/close (libc/pipe-reader $r-pipe)
			 }
		       }))

		      ;; The Libc texinfo page seems to have missed
		      ;; this.  On the basis that a $cmd-pipe is owned
		      ;; (created?) by the left hand process of the
		      ;; two being connected, then $cmd-r-fdn is the
		      ;; (pipe-reader $cmd-pipe) of the left-hand
		      ;; process and will have been closed in
		      ;; %prep-process, above (unless it was
		      ;; $pipeline-r-fdn).

		      ;; In turn, the current (pipe-reader $cmd-pipe)
		      ;; will become the $cmd-r-fdn of the right-hand
		      ;; process (as the parent Idio also has it open
		      ;; and will pass it on).  But what of us?  Who
		      ;; closes (pipe-reader $cmd-pipe) in us?

		      ;; Ah, OK.  We do.
		      if ($proc-id lt $nprocs) {
			libc/close (libc/pipe-reader $cmd-pipe)
		      }

		      ;; We don't have the same problem with
		      ;; (pipe-writer $cmd-pipe) because we only
		      ;; create the $cmd-pipe when we know there is
		      ;; another process in the pipeline and
		      ;; $cmd-w-fdn immediately becomes (pipe-writer
		      ;; $cmd-pipe).

		      ;; $cmd-r-fdn is a left-over from the pipe of
		      ;; the left hand process and we are suffering an
		      ;; off-by-one error and the left-over one is the
		      ;; current (pipe-reader $cmd-pipe) we have in
		      ;; our hands.

		      if (C/== $pgid libc/0pid_t) {
			libc/close (libc/pipe-writer $pgrp-pipe)

			;; $pgid is 0 so we must be the first in the
			;; pipeline -- block reading a single byte
			;; from the $pgrp-pipe
			libc/read (libc/pipe-reader $pgrp-pipe) 1
			libc/close (libc/pipe-reader $pgrp-pipe)
                      } {
			libc/close (libc/pipe-reader $pgrp-pipe)
			libc/close (libc/pipe-writer $pgrp-pipe)
		      }

		      ;; tidy up any trailing $pipeline-*-fdn ends
		      if (and (C/int? $pipeline-r-fdn)
			      (not (C/== $cmd-r-fdn $pipeline-r-fdn))
			      (not (C/== $pipeline-r-fdn libc/STDIN_FILENO))) {
				libc/close $pipeline-r-fdn
		      }
		      if (and (C/int? $pipeline-w-fdn)
			      (not (C/== $cmd-w-fdn $pipeline-w-fdn))
			      (not (C/== $pipeline-w-fdn libc/STDOUT_FILENO))) {
				libc/close $pipeline-w-fdn
		      }

		      (cond
		       ((pair? (ph '$cmd)) {
			 $@cmd
		       })
		       (else {
			 $cmd
		       }))

		      ;; We ought to definitively stop before this
		      ;; child continues back into the main Idio
		      ;; engine.

		      exit 0
		    } {
		      set-%idio-process-pid! $proc $pid
		      if (or job-control/%idio-interactive
			     $async-job) {
			if (C/== $pgid libc/0pid_t) {
			  $pgid = $pid
			  set-%idio-job-pgid! $job $pgid
			}
			suppress-errors! ^system-error libc/setpgid $pid $pgid
		      }
		    }

		    ;; tidy up any trailing $cmd-pipe ends
		    if (C/int? $cmd-r-fdn) {
		      if (not (and (C/int? $pipeline-r-fdn)
				   (C/== $cmd-r-fdn $pipeline-r-fdn))) {
				     libc/close $cmd-r-fdn
				   }
		    }
		    if (C/int? $cmd-w-fdn) {
		      if (not (and (C/int? $pipeline-w-fdn)
				   (C/== $cmd-w-fdn $pipeline-w-fdn))) {
				     libc/close $cmd-w-fdn
				   }
		    }

		    $cmd-r-fdn = (libc/pipe-reader $cmd-pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
      })
	 op-args)

      (cond
       ($use-w-pipe {
	 ;; parent should not hold the read end of the pipe-into pipe open
	 if (eq? $use-w-pipe 'named) {
	   job-control/add-process-substitution-job $job $proc-subst-job
	   if (C/int? $pipeline-r-fdn) {
	     libc/close $pipeline-r-fdn
	   }
	 } {
	   libc/close $pipeline-r-fdn
	 }
       })
       ($use-r-pipe {
	 ;; parent should not hold the write end of the pipe-from pipe open
	 if (eq? $use-r-pipe 'named) {
	   job-control/add-process-substitution-job $job $proc-subst-job
	   if (C/int? $pipeline-w-fdn) {
	     libc/close $pipeline-w-fdn
	   }
	 } {
	   libc/close $pipeline-w-fdn
	 }
       }))

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      ;; put the job's procs back in pipeline order
      set-%idio-job-procs! $job (reverse (%idio-job-procs $job))

      ;; finally let the first process go
      libc/close (libc/pipe-reader $pgrp-pipe)
      libc/close (libc/pipe-writer $pgrp-pipe)

      ;; OK, how do we, the parent, finish up?
      (cond
       ($use-w-pipe {
	 $pipeline-w-phn
       })
       ($use-r-pipe {
	 $pipeline-r-phn
       })
       ($collect {
	 ;; wait for it!
	 foreground-job $job #f

	 ;; OK, now recover the output
	 ih := open-input-file-from-fd $pipeline-w-fdn
	 seek-handle ih 0 'set
	 os := (open-output-string)
	 display (read-lines ih) os
	 close-handle ih
	 strip-string (get-output-string os) "\n"
       })
       (else {
	 $status := #f
	 (cond
	  ($foreground {
	    $status = foreground-job $job #f
	  })
	  (else {
	    $status = background-job $job #f
	  }))

	 if $close-pipeline-r-fd {
	   libc/close $close-pipeline-r-fd
	 }

	 if $recover-pipeline-w-fd {
	   ;; if the job was backgrounded then this won't do much!
	   ih := open-input-file-from-fd $pipeline-w-fdn
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-pipeline-w-fd
	   close-handle ih
	 }

	 $status
       }))
    }
  }
}

#*

fork-command started life as per the Job Control info pages as taking
a foreground boolean.

It was extended to take use-[rw]-pipe booleans for whether it should
return write/read pipe handles for pipe-into and pipe-from.

We can (ab)use those pipe "booleans" by testing if they are the 'named
symbol to return a (named) pipe pathname for Process Substitution.  We
can do this because we can't ask for both a pipe handle and a named
pipe pathname to be returned at the same time:

use-[rw]-pipe:

* #f		do nothing

* 'named	return a (named) pipe pathname

* any		return a pipe handle

The only complication is that we can't open the true named pipe now,
we must open it in the child process otherwise we block waiting for
the other guy to open their end.  Which they can't because we've just
blocked ourselves from starting them.

*#

define-template (fork-command foreground use-w-pipe use-r-pipe async-job & cmd) {
  proc-subst-job   := gensym 'psj

  w-pipe           := gensym 'w-pipe
  cmd-r-fdn        := gensym 'cmd-r-fdn
  close-cmd-r-fd   := gensym 'close-cmd-r-fd
  cmd-w-phn        := gensym 'cmd-w-phn

  r-pipe           := gensym 'r-pipe
  cmd-w-fdn        := gensym 'cmd-w-fdn
  cmd-r-phn        := gensym 'cmd-r-phn
  recover-cmd-w-fd := gensym 'rcvr-cmd-w-fd

  cmd-e-fd         := gensym 'cmd-e-fd
  recover-cmd-e-fd := gensym 'rcvr-cmd-e-fd

  pgid             := gensym 'pgid
  proc             := gensym 'proc
  job              := gensym 'job
  pid              := gensym 'pid
  status           := gensym 'status

  #T{
    {
      $proc-subst-job := #f

      $w-pipe         := #f
      $cmd-r-fdn      := #f
      $close-cmd-r-fd := #f
      $cmd-w-phn      := #f
      (cond
       ((eq? $use-w-pipe 'named) {
	 named-pipe := (libc/proc-subst-named-pipe-into)
	 $cmd-w-phn = (nth named-pipe 4)
	 ;; true named pipes will not have opened an fd so substitute
	 ;; the name
	 $cmd-r-fdn = (or (nth named-pipe 1)
			  (nth named-pipe 3))

	 (cond
	  ((nth named-pipe 2) {
	    $proc-subst-job = job-control/make-%process-substitution-job #f (nth named-pipe 2) #f #f #f
	  })
	  (else {
	    $proc-subst-job = job-control/make-%process-substitution-job #f #f (nth named-pipe 4) (nth named-pipe 5) #f
	  }))
       })
       ($use-w-pipe {
	 $w-pipe    = (libc/pipe)
	 $cmd-w-phn = open-output-pipe (libc/pipe-writer $w-pipe)
	 $cmd-r-fdn = libc/pipe-reader $w-pipe
       })
       (else {
	 $cmd-r-fdn        = (libc/stdin-fileno) ; STDIN_FILENO
	 $close-cmd-r-fd   = #f
	 if (pair? $cmd-r-fdn) {
	   $cmd-r-fdn      = ph $cmd-r-fdn
	   $close-cmd-r-fd = $cmd-r-fdn
	 }
       }))

      $r-pipe           := #f
      $cmd-w-fdn	:= #f
      $cmd-r-phn	:= #f
      $recover-cmd-w-fd := #f
      (cond
       ((eq? $use-r-pipe 'named) {
	 named-pipe := (libc/proc-subst-named-pipe-from)
	 $cmd-r-phn = (nth named-pipe 3)
	 ;; true named pipes will not have opened an fd so substitute
	 ;; the name
	 $cmd-w-fdn = (or (nth named-pipe 2)
			  (nth named-pipe 4))

	 (cond
	  ((nth named-pipe 1) {
	    $proc-subst-job = job-control/make-%process-substitution-job #t (nth named-pipe 1) #f #f #f
	  })
	  (else {
	    $proc-subst-job = job-control/make-%process-substitution-job #t #f (nth named-pipe 3) (nth named-pipe 5) #f
	  }))
       })
       ($use-r-pipe {
	 $r-pipe    = (libc/pipe)
	 $cmd-r-phn = open-input-pipe (libc/pipe-reader $r-pipe)
	 $cmd-w-fdn = libc/pipe-writer $r-pipe
       })
       (else {
	 $cmd-w-fdn          = (libc/stdout-fileno) ; STDOUT_FILENO
	 $recover-cmd-w-fd   = #f
	 if (pair? $cmd-w-fdn) {
	   $recover-cmd-w-fd = pht $cmd-w-fdn
	   $cmd-w-fdn        = ph $cmd-w-fdn
	 }
       }))

      $cmd-e-fd          := (libc/stderr-fileno) ; STDERR_FILENO
      $recover-cmd-e-fd  := #f
      if (pair? $cmd-e-fd) {
	$recover-cmd-e-fd = pht $cmd-e-fd
	$cmd-e-fd         = ph $cmd-e-fd
      }
      $pgid := libc/0pid_t
      $proc := make-%idio-process '$cmd #n -1 #f #f #n
      $job := (make-%idio-job '$cmd
			      (list $proc)
			      $pgid
			      #f
			      #f
			      #n
			      $cmd-r-fdn
			      $cmd-w-fdn
			      $cmd-e-fd
			      #f
			      (list (libc/gettimeofday) (libc/getrusage libc/RUSAGE_SELF) (libc/getrusage libc/RUSAGE_CHILDREN))
			      #f
			      $async-job)

      $pid := (libc/fork)
      (cond
       ((C/== $pid libc/0pid_t) {
	 set-default-handler! ^idio-error default-child-handler
	 job-control/%idio-jobs = #n
	 job-control/%%last-job = #n
	 job-control/%%process-substitution-jobs = #{}
	 %prep-process $pgid $cmd-r-fdn $cmd-w-fdn $cmd-e-fd $foreground $async-job

	 (cond
	  ($use-w-pipe {
	    ;; sub-Idio should not hold the write end of the
	    ;; (named-)pipe-into pipe open (if a file descriptor) --
	    ;; it will have been dup'ed in prep-io
	    if (eq? $use-w-pipe 'named) {
	      fd := %process-substitution-job-fd $proc-subst-job
	      if fd {
		libc/close fd
	      }
	    } {
	      libc/close (libc/pipe-writer $w-pipe)
	    }
	  })
	  ($use-r-pipe {
	    ;; sub-Idio should not hold the read end of the
	    ;; (named-)pipe-from pipe open (if a file descriptor) --
	    ;; it will have been dup'ed in prep-io
	    if (eq? $use-r-pipe 'named) {
	      fd := %process-substitution-job-fd $proc-subst-job
	      if fd {
		libc/close fd
	      }
	    } {
	      libc/close (libc/pipe-reader $r-pipe)
	    }
	  }))

	 (cond
	  ((pair? (ph '$cmd)) {
	    $@cmd
	  })
	  (else $cmd))

	 ;; We ought to definitively stop before this child continues
	 ;; back into the main Idio engine.
	 exit 0
       })
       (else {
	 set-%idio-process-pid! $proc $pid
	 if (or job-control/%idio-interactive
		$async-job) {
	   $pgid = $pid
	   set-%idio-job-pgid! $job $pgid
	   suppress-errors! ^system-error libc/setpgid $pid $pgid
	 }
       }))

      (cond
       ($use-w-pipe {
	 ;; parent should not hold the read end of the
	 ;; (named-)pipe-into pipe open
	 if (eq? $use-w-pipe 'named) {
	   job-control/add-process-substitution-job $job $proc-subst-job
	   if (C/int? $cmd-r-fdn) {
	     libc/close $cmd-r-fdn
	   }
	 } {
	   libc/close $cmd-r-fdn
	 }
       })
       ($use-r-pipe {
	 ;; parent should not hold the write end of the
	 ;; (named-)pipe-from pipe open
	 if (eq? $use-r-pipe 'named) {
	   job-control/add-process-substitution-job $job $proc-subst-job
	   if (C/int? $cmd-w-fdn) {
	     libc/close $cmd-w-fdn
	   }
	 } {
	   libc/close $cmd-w-fdn
	 }
       }))

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      (cond
       ($use-w-pipe {
	 $cmd-w-phn
       })
       ($use-r-pipe {
	 $cmd-r-phn
       })
       (else {
	 $status := #f
	 (cond
	  ($foreground {
	    $status = foreground-job $job #f
	  })
	  (else {
	    $status = background-job $job #f
	  }))

	 if $close-cmd-r-fd {
	   libc/close $close-cmd-r-fd
	 }

	 if $recover-cmd-w-fd {
	   ih := open-input-file-from-fd $cmd-w-fdn

	   ;; NB the temporary file has just been written to so the file
	   ;; pointer is currently at the end, we need to set it back to
	   ;; the start to be able to read anything!
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-cmd-w-fd
	   close-handle ih
	 }

	 if $recover-cmd-e-fd {
	   ih := open-input-file-from-fd $cmd-e-fd

	   ;; NB the temporary file has just been written to so the file
	   ;; pointer is currently at the end, we need to set it back to
	   ;; the start to be able to read anything!
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-cmd-e-fd
	   close-handle ih
	 }

	 $status
       }))
    }
  }
}

define-template (fg-job & cmd) {
  #T{ fork-command #t #f #f #f $@cmd }
}

define-template (bg-job & cmd) {
  #T{ fork-command #f #f #f #f $@cmd }
}

define-template (pipe-into & cmd) {
  #T{ fork-command #f #t #f #t $@cmd }
}

define-template (named-pipe-into & cmd) {
  #T{ fork-command #f 'named #f #t $@cmd }
}

define-template (pipe-from & cmd) {
  #T{ fork-command #f #f #t #t $@cmd }
}

define-template (named-pipe-from & cmd) {
  #T{ fork-command #f #f 'named #t $@cmd }
}

define (wait & jobs) {
  notify := #f

  loop :+ function (jobs) {
	    if (null? jobs) #t {
	      notify = #t
	      wait-for-job (ph jobs)
	      loop (pt jobs)
	    }
  }

  if (null? jobs) {
    jobs = %idio-jobs
  }

  loop jobs

  if notify (do-job-notification)
}

#*

with-handle-redir type s/d thunk

wrapper functions with-input-from, with-output-to and with-error-to
are identical barring some "directional" function calls.  We'll have a
generic function instead.

{type} is the symolic name of the handle being modified: 'input,
'output, 'error

{s/d} (source/destination) can be:
1. a handle (fd or string)
2. a literal string which will be interpreted as the name of the
   fd to open as per:
     open-output-fd {s/d} or
     open-input-fd {s/d}
3. #n as shorthand for the string "/dev/null"

{thunk} is the 0-arg function to invoke

*#

with-handle-redir := {
  current-input-handle	:= current-input-handle
  current-output-handle := current-output-handle
  current-error-handle	:= current-error-handle
  set-input-handle!	:= set-input-handle!
  set-output-handle!	:= set-output-handle!
  set-error-handle!	:= set-error-handle!

  function (type s/d thunk) {
    ;; handle-oriented indirection function/variables
    get-current-h := #f
    open-fd-h     := #f
    open-file-h   := #f
    set-h!        := #f
    dir-fd-h?     := #f
    dir-string-h? := #f
    dir-msg       := #f

    (cond
     ((eq? type 'input) {
       get-current-h = current-input-handle
       open-fd-h     = open-input-fd
       open-file-h   = open-input-file
       set-h!        = set-input-handle!
       dir-fd-h?     = input-fd-handle?
       dir-string-h? = input-string-handle?
       dir-msg       = "input"
     })
     ((eq? type 'output) {
       get-current-h = current-output-handle
       open-fd-h     = open-output-fd
       open-file-h   = open-output-file
       set-h!        = set-output-handle!
       dir-fd-h?     = output-fd-handle?
       dir-string-h? = output-string-handle?
       dir-msg       = "output"
     })
     ((eq? type 'append) {
       get-current-h = current-output-handle
       open-fd-h     = open-output-fd
       open-file-h   = function (n) (open-file n "a")
       set-h!        = set-output-handle!
       dir-fd-h?     = output-fd-handle?
       dir-string-h? = output-string-handle?
       dir-msg       = "append"
     })
     ((eq? type 'error) {
       get-current-h = current-error-handle
       open-fd-h     = open-output-fd
       open-file-h   = open-output-file
       set-h!        = set-error-handle!
       dir-fd-h?     = output-fd-handle?
       dir-string-h? = output-string-handle?
       dir-msg       = "output"
     })
     (else (error 'with-handle-redir "unexpected handle type" type)))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    ;; if we create a new handle we need to close it afterwards
    close-h := #f

    (cond
     ((dir-fd-h? s/d)      (new-h = s/d))
     ((fd-handle? s/d)     (error 'with-handle-redir (append-string "not an " dir-msg "-fd-handle") s/d))
     ((dir-string-h? s/d)  (new-h = s/d))
     ((string-handle? s/d) (error 'with-handle-redir (append-string "not an " dir-msg "-string-handle") s/d))
     ((string? s/d) {
       new-h = open-file-h s/d
       close-fd-handle-on-exec new-h
       close-h = #t
     })
     ((null? s/d) {
       new-h = open-file-h "/dev/null"
       close-fd-handle-on-exec new-h
       close-h = #t
     })
     (else (error 'with-handle-redir (append-string "unexpected " dir-msg) s/d)))

    if new-h {
      set-h! new-h
    } {
      error 'with-handle-redir (append-string "unexpected " dir-msg) s/d
    }

    unwind-protect {
      (thunk)
    } {
      if close-h {
	close-handle new-h
      }
      set-h! old-h
    }
  }
}

define (with-input-from src thunk) {
  with-handle-redir 'input src thunk
}

define (with-output-to dst thunk) {
  with-handle-redir 'output dst thunk
}

define (with-error-to dst thunk) {
  with-handle-redir 'error dst thunk
}

;; collect-output works fine for standalone commands, (collect-output
;; uname -n), but is caught up in a pipeline by the reader operator.
;; See above.
;;
;; NB call fork-command directly as we want to be both in the
;; foreground and an async command
define-template (collect-output & cmd) {
  osh := gensym 'osh
  #T{
    $osh := (open-output-string)
    with-output-to $osh (function #n {
			   fork-command #t #f #f #t $@cmd
    })
    strip-string (get-output-string $osh) "\n"
  }
}

define (cat-file fn) {
  fh := open-input-file fn
  r := read-lines fh
  close-handle fh
  r
}

#*

with-handle-dup type new thunk

nominal functions dup-input-from, dup-output-to and dup-error-to are
identical barring some "directional" function calls.  We'll have a
generic function instead.

{type} is the symolic name of the handle being modified: 'input,
'output, 'error

{new} can be:
1. a handle (file or string)
2. a C int or fixnum which will be interpreted as the name of the
   file descriptor to call dup2(2) with

{thunk} is the 0-arg function to invoke

*#

with-handle-dup := {
  current-input-handle  := current-input-handle
  current-output-handle := current-output-handle
  current-error-handle  := current-error-handle
  set-input-handle!     := set-input-handle!
  set-output-handle!    := set-output-handle!
  set-error-handle!     := set-error-handle!

  function (type new thunk) {
    ;; handle-oriented indirection function/variables
    get-current-h := #f
    set-h!        := #f
    dir-file-h?   := #f
    dir-string-h? := #f
    msg-h         := #f

    (cond
     ((eq? type 'input) {
       get-current-h = current-input-handle
       set-h!        = set-input-handle!
       dir-file-h?   = input-file-handle?
       dir-string-h? = input-string-handle?
       msg-h         = "input"
     })
     ((eq? type 'output) {
       get-current-h = current-output-handle
       set-h!        = set-output-handle!
       dir-file-h?   = output-file-handle?
       dir-string-h? = output-string-handle?
       msg-h         = "output"
     })
     ((eq? type 'error) {
       get-current-h = current-error-handle
       set-h!        = set-error-handle!
       dir-file-h?   = output-file-handle?
       dir-string-h? = output-string-handle?
       msg-h         = "output"
     })
     (else (error 'with-handle-dup "unexpected handle type" type)))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    (cond
     ((dir-file-h? new) {
       new-h = new
     })
     ((file-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-file-handle") new))
     ((dir-string-h? new) (new-h = new))
     ((string-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-string-handle") new))
     ((or (C/int? new)
	  (fixnum? new)) {
	    if (C/int? new) (new = C/->integer new)
	    (cond
	     ((eq? new 0) {
	       new-h = (current-input-handle)
	     })
	     ((eq? new 1) {
	       new-h = (current-output-handle)
	     })
	     ((eq? new 2) {
	       new-h = (current-error-handle)
	     }))
	  })
     (else (error 'with-handle-dup (append-string "unexpected " msg-h) new)))

    (cond
     (new-h {
       set-h! new-h
     })
     (else {
       error 'with-handle-dup (append-string "unexpected " msg-h) new
     }))

    unwind-protect {
      (thunk)
    } {
      set-h! old-h
    }
  }
}

;; ... < e1 ...
;; ... > e1 ...
;; ... 2> e1 ...
define-infix-operator > 600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  (cond
   ((eq? op '<) {
     type = 'input
   })
   ((eq? op '>) {
     type = 'output
   })
   ((eq? op '>>) {
     type = 'append
   })
   ((eq? op '2>) {
     type = 'error
   })
   (else (error op "unexpected op" op)))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  result
}

define-infix-operator >> 600 \>
define-infix-operator <  600 \>
define-infix-operator 2> 600 \>

;; ... <& e1 ...
;; ... >& e1 ...
;; ... 2>& e1 ...
define-infix-operator >& 600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  (cond
   ((eq? op '<&) {
     type = 'input
   })
   ((eq? op '>&) {
     type = 'output
   })
   ((eq? op '2>&) {
     type = 'error
   })
   (else (error op "unexpected op" op)))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  result
}

define-infix-operator <&  600 \>&
define-infix-operator 2>& 600 \>&

define (jobs) "display the state of outstanding jobs" {
  first-j := #t
  jobs-loop :+ function (jobs) {
		 (cond
		  ((null? jobs) {
		    #t
		  })
		  (else {
		    job := ph jobs
		    if first-j {
		      first-j = #f
		      printf "%6s %s\n" "pgid" "job-pipeline"
		    }
		    printf "%6d %s\n" (%idio-job-pgid job) (%idio-job-pipeline job)

		    first-p := #t

		    procs-loop :+ function (procs) {
				    if (null? procs) #t {
				      proc := ph procs
				      if (null? proc) #t {
					if first-p {
					  first-p = #f
					  printf "  %6s %2s %2s %s\n" "pid" "C?" "S?" "argv"
					}
					printf "  %6d %s %s %s\n" (%idio-process-pid proc) (%idio-process-completed proc) (%idio-process-stopped proc) (%idio-process-argv proc)
					procs-loop (pt procs)
				      }
				    }
		    }

		    (and (procs-loop (%idio-job-procs job))
			 (jobs-loop (pt jobs)))
		  }))
  }

  jobs-loop %idio-jobs
}

provide job-control
