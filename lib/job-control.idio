;;
;; Copyright (c) 2015, 2017, 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; command.idio
;;
module job-control

#*

Even though we import libc here in job-control (because we do a lot of
libc-ish things) the templates/operators we export -- which will be
expanded in the user's namespace -- will use libc values and we have
no idea if they, the importer (of us), has imported libc themselves.
We don't want to force them to import libc as it annoyingly duplicates
many names.

So the "fix" is to ensure that the templates/operators we export
dutifully call the libc/X "direct" names for any libc X they use.

*#

import libc
export (%idio-interactive
	%idio-jobs
	%%last-job
	job-failed
	job-detail
	pipeline-detail
	%prep-process
	background-job
	foreground-job
	default-child-handler
	wait-for-job

	format-job-detail

	; default SIGCHLD handler via SIGCHLD clause in
	; default-condition-handler (condition.c) and
	; idio_command_SIGCHLD_signal_handler (command.c) which has
	; idio_vm_invoke_C() call "do-job-notification"

	do-job-notification

	bg-job
	wait
	with-input-from
	with-output-to
	with-error-to

	collect-output

	with-handle-dup
	with-handle-redir

	jobs)


export-struct-accessors-only %idio-process	argv pid completed stopped status
export-struct-accessors-only %idio-job		pipeline procs pgid notified raised tcattrs stdin stdout stderr

%%last-job := #n

define (job-as-string job seen) {
  if (%idio-job? job) {
    r := (open-output-string)
    hprintf r "#<SI %%idio-job "

    hprintf r "%s %s " (%idio-job-pgid job) (%idio-job-pipeline job)

    procs-first := #t
    procs-loop :+ function (procs) {
		    if (null? procs) #n {
		      proc := ph procs
		      if (null? proc) #t {
			if procs-first {
			  procs-first = #f
			} {
			  hprintf r "| "
			}
			hprintf r "[PID=%s C?=%s S?%s: " (%idio-process-pid proc) (%idio-process-completed proc) (%idio-process-stopped proc)
			if (%idio-process-completed proc) {
			  status := %idio-process-status proc
			  (cond
			   ((WIFEXITED status) {
			     hprintf r " exit %d: " (WEXITSTATUS status)
			   })
			   ((WIFSIGNALED status) {
			     hprintf r " kill -%d: " (WTERMSIG status)
			   }))
			}
			hprintf r "%s] " (%idio-process-argv proc)
			procs-loop (pt procs)
		      }
		    }
    }

    procs-loop (reverse (%idio-job-procs job))

    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string %idio-job job-as-string

#*

These algorithms are directly from the libc info pages on Job
Control: "info libc" then "Job Control" then "Implementing a Shell"

*#

define (job-is-stopped job) "test if job `job` is stopped

:param job: job to test

:return: #t if job `job` is stopped, #f otherwise
" {
  if (null? job) (error 'job-is-stopped "null job" job)

  loop :+ function (procs) {
	    (cond
	     ((null? procs) #t)
	     ((and (not (%idio-process-completed (ph procs)))
		   (not (%idio-process-stopped (ph procs)))) #f)
	     (else (loop (pt procs))))
  }

  loop (%idio-job-procs job)
}

define (job-is-completed job) "test if job `job` has completed

:param job: job to test

:return: #t if job `job` has completed, #f otherwise
" {
  if (null? job) (error 'job-is-completed "null job" job)

  loop :+ function (procs) {
	    (cond
	     ((null? procs) #t)
	     ((not (%idio-process-completed (ph procs))) #f)
	     (else {
	       loop (pt procs)
	     }))
  }

  loop (%idio-job-procs job)
}

define (job-failed job) "test if job `job` has failed

:param job: job to test

:return: #t if job `job` has failed, #f otherwise
" {
  if (null? job) (error 'job-failed "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #f {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (not (C/== (WEXITSTATUS status) C/0i)) #t {
		   loop (pt procs)
		 }
	       })
	       ((WIFSIGNALED status) #t)
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  if (job-is-completed job) {
    loop (%idio-job-procs job)
  } #f
}

;; job-status => #t/#f
define (job-status job) "test if job `job` has a process status

:param job: job to test

:return: #f if job `job` has a process status, #t otherwise

Note that this is the inverse behaviour you might expect.
" {
  if (null? job) (error 'job-status "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #t {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (not (C/== (WEXITSTATUS status) C/0i)) #f {
		   loop (pt procs)
		 }
	       })
	       ((WIFSIGNALED status) #f)
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  ;;
  ;; NB. the procs were pushed onto the list in reverse order so
  ;; walking down the list we encounter the rightmost first
  procs := %idio-job-procs job
  loop procs
}

;; job-detail => '(exit X) or '(killed Y)
define (job-detail job) "return the process status of job `job`

:param job: job

:return: a (kind value) list

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed
" {
  if (null? job) (error 'job-detail "null job" job)

  loop :+ function (procs) {
	    if (null? procs) #f {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs)
	       })
	       ((WIFEXITED status) {
		 if (not (C/== (WEXITSTATUS status) C/0i)) (list 'exit (WEXITSTATUS status)) {
		   loop (pt procs)
		 }
	       })
	       ((WIFSIGNALED status) (list 'killed (WTERMSIG status)))
	       (else {
		 loop (pt procs)
	       }))
	    }
  }

  ;; return rightmost non-zero exit status or the status from the last
  ;; (or any as they all succeeded but the last is top of procs)
  ;;
  ;; NB. the procs were pushed onto the list in reverse order so
  ;; walking down the list we encounter the rightmost first
  procs := %idio-job-procs job
  (or (loop procs)
      (list 'exit (WEXITSTATUS (%idio-process-status (ph procs)))))
}

define (pipeline-detail job) "return the process status of each process in the pipeline `job`

:param job: job

:return: a list of (kind value) lists

kind can be: 'exit or 'killed
value can be: exit status for 'exit or signal number for 'killed
" {
  if (null? job) (error 'pipeline-detail "null job" job)

  loop :+ function (procs st) {
	    if (null? procs) (reverse st) {
	      status := %idio-process-status (ph procs)
	      (cond
	       ((null? status) {
		 loop (pt procs) (pair (list 'no-status) st)
	       })
	       ((WIFEXITED status) {
		 loop (pt procs) (pair (list 'exit (WEXITSTATUS status)) st)
	       })
	       ((WIFSIGNALED status) {
		 loop (pt procs) (pair (list 'killed (WTERMSIG status)) st)
	       })
	       (else {
		 loop (pt procs) (pair (list 'unknown) st)
	       }))
	    }
  }

  loop (%idio-job-procs job) #n
}

define (mark-process-status pid status) "update the process status of pid `pid` with `status`

:param pid: process id
:param status: Unix process status

:return: #t if the update was successfull, #f otherwise

Store the `status` of the process `pid` that was returned by
waitpid(2).  Return #f if all went well, some true value otherwise.

This (inverted) convention follows the Libc texinfo algorithm and is
for the benefit of the do loops in update-status_ and wait-for-job_.
" {
  (cond
   ((C/> pid libc/0pid_t) {
     jobs-loop :+ function (jobs) {
		    (cond
		     ((null? jobs) {
		       if %idio-interactive {
			 eprintf "no child process %d\n" pid
		       }
		       #t
		     })
		     (else {
		       ;; procs-loop follows the same convention as the outer
		       ;; jobs-loop as returning success (#f!) will be the return
		       ;; value of jobs-loop
		       procs-loop :+ function (procs) {
				       (cond
					((null? procs) #t)
					((C/== pid (%idio-process-pid (ph procs))) {
					  set-%idio-process-status! (ph procs) status
					  if (WIFSTOPPED status) {
					    set-%idio-process-stopped! (ph procs) #t
					  } {
					    set-%idio-process-completed! (ph procs) #t
					    if (and %idio-interactive
						    (WIFSIGNALED status)) {
						      eprintf "Job Terminated: kill -%s %d\n" (signal-name (WTERMSIG status)) pid
						    }
					  }
					  #f
					})
					(else {
					  procs-loop (pt procs)
					}))
		       }

		       (and (procs-loop (%idio-job-procs (ph jobs)))
			    (jobs-loop (pt jobs)))
		     }))
     }

     jobs-loop %idio-jobs
   })
   ((or (C/== pid libc/0pid_t)
	(C/== libc/errno ECHILD)) {
	  ;; We can get here if foreground-job was blocked in
	  ;; wait-for-job then a SIGCHLD event fired and the
	  ;; (default) handler calls do-job-notification.
	  #t
	})
   (else {
     ;; an error in waitpid would have been signalled there
     error 'mark-process-status "inconceivable!" pid status
   }))
}

define (update-status) "update the process status of any outstanding pids

:return: #<unspec>
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY (WUNTRACED C/| WNOHANG))
  }

  do () ((call-with-values waitany mark-process-status) #n) #n
}

define (wait-for-job job) "wait for job `job` to be stopped or completed

:param job: job

:return: job status
" {
  waitany := function () {
    apply values (waitpid WAIT_ANY WUNTRACED)
  }

  do () ((not (and (not (call-with-values waitany mark-process-status))
	           (not (job-is-stopped job))
	           (not (job-is-completed job))))
         #n) #n

  ;eprintf "wfj: %5s C=%s S=%s %s %s\n" (%idio-job-pgid job) (job-is-completed job) (job-is-stopped job) (if (job-failed job) "failed" "succeeded") (pipeline-detail job)

  if (job-failed job) {
    if (not (%idio-job-raised job)) {
      c := make-condition ^rt-command-status-error "job failed" job (pipeline-detail job) (job-detail job)
      set-%idio-job-raised! job #t
      reraise c
    }
  }

  job-status job
}

define (format-job-info job msg) "display to stderr `msg` alongside job `job` details

:param job: job
:param msg: string

:return: #<unspec>
" {
  if %idio-interactive {
    jd := job-detail job
    if (not (equal? (list 'exit C/0i) jd)) {
      eprintf "job %5s: %s: %s: %s\n" (%idio-job-pgid job) (%idio-job-pipeline job) msg jd
    }
  }
}

define (format-job-detail job & args) {
  oh := (current-output-handle)
  if (pair? args) {
    oh = ph args
  }

  ;; cf. condition-report
  header := #t
  printed := #f
  loop :+ function (procs details) {
	    (cond
	     ((null? procs) #t)
	     (else {
	       if header {
		 header = #f
		 hprintf oh "        %6s %-3s %-12s %s\n" "PID" "fl" "status" "cmd"
	       }
	       proc := ph procs
	       hprintf oh "  proc: %6s %2s%s %-12s %s\n" (%idio-process-pid proc) (if (%idio-process-completed proc) " C" "!C") (if (%idio-process-stopped proc) "S" " ") (ph details) (%idio-process-argv proc)
	       printed = #t
	       loop (pt procs) (pt details)
	     }))
  }

  hprintf oh "\n"
  loop (reverse (%idio-job-procs job)) (reverse (pipeline-detail job))
  if printed {
    hprintf oh "  flags: C - completed; !C - not completed; S - stopped\n"
  }
}

define (do-job-notification) "notify of any job status changes" {
  (update-status)

  failed-jobs := #n

  loop :+ function (jobs njobs) {
	    (cond
	     ((null? jobs) (reverse njobs))
	     (else {
	       job := ph jobs
	       (cond
		((job-is-completed job) {

		  format-job-info job "completed"
		  if (job-failed job) {
		    failed-jobs = pair job failed-jobs
		  }
		  ;; remove job from list (by not including it!)
		  loop (pt jobs) njobs
		})
		((job-is-stopped job) {
		  if (not (%idio-job-notified job)) {
		    format-job-info job "stopped"
		    set-%idio-job-notified! job #t
		  }
		  loop (pt jobs) (pair job njobs)
		})
		(else {
		  loop (pt jobs) (pair job njobs)
		}))
	     }))
  }

  %idio-jobs = loop %idio-jobs #n

  #*

  This report->raise condition for failed jobs is badly positioned.
  The problem lies in that we, do-job-notification, have run on the
  back of a SIGCHLD event but will have had nothing to report (in the
  simplest case) because our call to update-status resulted in a pid
  of 0 and/or errno ECHILD.  That's because foreground-job, say, was
  blocked in wait-for-job who had (successfully) called waitpid but
  further processing has been suspended while the event handler runs.
  Only when we return will it be able to continue and usefully call
  mark-process-status with a proper pid and status.

  This isn't an Idio-issue, the Libc texinfo C version (from which
  this is ported) appears to suffer the same problem.

  Underlying that is that, perhaps, we shouldn't be calling
  do-job-notification from the signal handler.  The texinfo suggests
  SIGCHLD->do-job-notification should only enabled when waiting at the
  prompt for user input and not, say, while generically processing
  loaded files.

  All good, but that leaves us with the question of when to raise a
  condition to alert the Idio code?  I've migrated that to
  wait-for-job itself.  It knows the job is complete and can assert if
  the job failed.

  *#

  if (not (null? failed-jobs)) {
    report :+ function (jobs) {
		(cond
		 ((null? jobs) #n)
		 (else {
		   job := ph jobs
		   if (not (%idio-job-raised job)) {
		     c := make-condition ^rt-command-status-error "job failed" job (pipeline-detail job) (job-detail job)
		     set-%idio-job-raised! job #t
		     reraise c
		   }

		   ;; if someone handled that error and returned (anything)
		   ;; then we can loop onto the next
		   report (pt jobs)
		 }))
    }

    report failed-jobs
  }

  #n
}

define (foreground-job job cont) "place job `job` in the foreground

:param job: job
:param cont: boolean

:return: job status

If `cont` is set a SIGCONT is sent to the process group
" {

  ;; put the job in the foreground
  suppress-errors ^idio-error tcsetpgrp %idio-terminal (%idio-job-pgid job)

  if cont {
    tcsetattr %idio-terminal TCSADRAIN (%idio-job-tcattrs job)

    kill (- (%idio-job-pgid job)) SIGCONT
  }

  r := wait-for-job job

  ;; put the shell back in the foreground
  tcsetpgrp %idio-terminal %idio-pgid

  ;; save the job's current terminal state
  set-%idio-job-tcattrs! job (tcgetattr %idio-terminal)

  ;; restore the shell's terminal state
  tcsetattr %idio-terminal TCSADRAIN %idio-tcattrs

  r
}

define (background-job job cont) "place job `job` in the background

:param job: job
:param cont: boolean

:return: #t

If `cont` is set a SIGCONT is sent to the process group

Backgrounding a job is always successful hence returns #t
" {
  job-pgid := %idio-job-pgid job
  if cont {
    kill (- job-pgid) SIGCONT
  }

  ;; result of background-job is always successful, ie. #t
  #t
}

define (hangup-job job) "hangup job `job`

:param job: job

:return: #<unspec>

Send the process group of `job` a SIGCONT then a SIGHUP
" {
  job-pgid := %idio-job-pgid job
  kill (- job-pgid) SIGCONT
  kill (- job-pgid) SIGHUP

  ;; result of hungup-job is #t
  #t
}

define (stop-job job) {
  job-pgid := %idio-job-pgid job
  kill (- job-pgid) SIGSTOP

  ;; result of stop-job is #t
  #t
}

define (mark-job-as-running job) "mark job `job` as running

:param job: job

:return: #<unspec>

In particular, mark job `job` as not stopped.
" {
  loop :+ function (procs) {
	    (cond
	     ((null? procs) #n)
	     (else {
	       set-%idio-process-stopped! (ph procs) #f
	       loop (pt procs)
	     }))
  }

  loop (%idio-job-procs job)
  set-%idio-job-notified! job #f
}

define (continue-job job foreground) "mark job `job` as running and foreground it if required

:param job: job
:param foreground: boolean

:return: #<unspec>
" {
  mark-job-as-running job
  if foreground {
    foreground-job job #t
  } {
    background-job job #t
  }
}

define (default-child-handler c) "
The default condition handler set in child processes.

It will report the condition and exit (1).
" {
  condition-report (sprintf "[%d] child-error-handler" (libc/getpid)) c (current-error-handle)
  eprintf "[%d] child process will exit (1)\n" (libc/getpid)
  libc/exit 1
}

define (prep-io infile outfile errfile) "prepare the IO for the current process

:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr

:return: #<unspec>
" {
  #*

  The nominal libc texinfo algorithm is:

    Switch stdin/stdout/stderr to the supplied file descriptor if it
    isn't already stdin/stdout/stderr.  (Here, the supplied file
    descriptor would commonly be one end or other of a pipe(2).)

    We can then close the supplied file descriptor if it is >
    STDERR_FILENO (ie. > 2) and isn't one of the later ones.

    That latter case is for: ls > "foo" 2>& 1

    Here, "stdout" will be fd N, say, having opened "foo" which we
    would close because N > 2, before we reached the "2>& 1" which
    tries to dup2(N, 2)

  However, we *must* set the Idio thread-specific input/output/error
  handles.  The problem lies in that this code, prep-io, is most
  likely called from the | operator in Idio-land in which case we are
  the *first* IO redirection.  However, the later IO redirections, (>
  >& etc.) reference the Idio thread-specific IO handles and *not*
  simply the STD*_FILENO file descriptors.  They do that because we
  can (seamlessly) use file-handles, string-handles, file descriptor
  numbers and ... instead of straight file names.  The use of
  string-handles means we have to create temporary files etc..

  In fact they call (libc/stdin-fileno) etc. which furtles about and
  conjures up a file descriptor which represents stdin etc..

  So, leave the final resolution of handle -> *nix file descriptor
  until the last thing before execve().  Just set Idio-level params.

  *#

  (cond
   ((C/int? infile) {
     if (not (C/== infile STDIN_FILENO)) {
       dup2 infile STDIN_FILENO
       close infile
       set-input-handle! (open-input-file-from-fd STDIN_FILENO)
     }
   })
   (else (error 'prep-io "unexpected infile format" infile)))

  (cond
   ((C/int? outfile) {
     if (not (C/== outfile STDOUT_FILENO)) {
       dup2 outfile STDOUT_FILENO
       close outfile
       set-output-handle! (open-output-file-from-fd STDOUT_FILENO)
     }
   })
   (else (error 'prep-io "unexpected outfile format" outfile)))

  (cond
   ((C/int? errfile) {
     if (not (C/== errfile STDERR_FILENO)) {
       dup2 errfile STDERR_FILENO
       close errfile
       set-error-handle! (open-output-file-from-fd errfile)
     }
   })
   (else (error 'prep-io "unexpected errfile format" errfile)))
}

define (%prep-process pgid infile outfile errfile foreground) "prepare the current process

:param pgid: process group to be joined
:param infile: to be used for stdin
:param outfile: to be used for stdout
:param errfile: to be used for stderr
:param foreground: place job in foreground

:return: #<unspec>
" {
  if %idio-interactive {
    pid := (libc/getpid)
    if (C/== pgid libc/0pid_t) {
      pgid = pid
    }

    ;; put the process in the process group -- dupe of parent to avoid
    ;; race conditions
    suppress-errors ^idio-error setpgid pid pgid

    if foreground {
      ;; give the terminal to the process group -- dupe of parent to
      ;; avoid race conditions
      suppress-errors ^idio-error tcsetpgrp %idio-terminal pgid
    }

    ;; set job control signals back to default
    signal SIGINT SIG_DFL
    signal SIGQUIT SIG_DFL
    signal SIGTSTP SIG_DFL
    signal SIGTTIN SIG_DFL
    signal SIGTTOU SIG_DFL
    signal SIGCHLD SIG_DFL
  }

  prep-io infile outfile errfile
}

define-infix-operator | 700 {
  foreground := #t
  use-w-pipe := #f
  use-r-pipe := #f
  collect := #f

  ;; Slightly annoyingly, some meta-instructions to the pipeline are
  ;; consumed by the reader operator (us!) so we should look out for
  ;; them.
  ;;
  ;; Obvious candidates are 'pipe-into and 'pipe-from but also fg-job,
  ;; bg-job and collect-output are auto-consumed.

  (case (ph before)
	((collect-output) {
	  before = pt before
	  collect = #t
	  foreground = #t
	})
	((fg-job) {
	  before = pt before
	  foreground = #t
	})
	((bg-job) {
	  before = pt before
	  foreground = #f
	})
	((pipe-into) {
	  before = pt before
	  use-w-pipe = #t
	  foreground = #f
	})
	((pipe-from) {
	  before = pt before
	  use-r-pipe = #t
	  foreground = #f
	}))

  orig-pipeline := append before (append (list op) after)

  ;; we want a list of lists -- a list of the |-separated commands
  split :+ function (op op-args expr after) {
	     (cond
	      ((null? after)		(reverse (pair (reverse expr) op-args)))
	      ((not (pair? after))	(error '| "bad syntax" op (reverse op-args) after))
	      ((eq? op (ph after))	(split op (pair (reverse expr) op-args) #n (pt after)))
	      (else			(split op op-args (pair (ph after) expr) (pt after))))
  }

  op-args := split op (list before) #n after

  ;; we have created new lists so we should expand any operators in
  ;; them
  op-args = map operator-expand op-args

  #*

  pgrp-pipe:

  There's a little process coordination trickery ported from Bash --
  noting that if the race condition occurs in a slick and fast pure C
  environment then our meandering and inefficient byte-compiled script
  has no hope!

  We need to prevent the first process in the pipeline from starting
  until all the others are in place -- otherwise you can have the
  first process, the process group leader, run and exit before you
  manage to start any of the others!  That also leaves the small issue
  of trying to call setpgid with a process group that no longer
  exists (and, worse, could have been replaced with a different
  process all together).  That's all bad for business.

  The trick is to open another pipe and have the first process block
  reading from the pipe just before it starts.  All the other
  processes in the pipeline simply close the pipe when they're about
  to exec/start.  When the last one has closed the pipe the first will
  have its blocking read() return (with zero bytes, ie EOF -- we don't
  care) and we're good to go.

  Incidentally, as we created the pipe in the main Idio process, it
  too holds the pipe open so we can be fairly confident that all the
  child processes are set up and running when the main Idio process
  closes the (last?) pgrp-pipe write-end.

  Well, probably, there's always a race condition between closing the
  pgrp-pipe and exec()ing or starting processing the Idio code in
  which the last process can be prevented from running before all the
  previous processes have been and gone.  But we've done a decent job,
  what more can we do?


  Hygiene

  Looping over the list of commands prepping the children uses a
  number of variables which are at risk of polluting the called
  code (if it is Idio code -- obviously if it is an external command
  we exec()'d it wouldn't matter).  Strict hygiene, please!

  Pipeline Bookkeeping

  Most of the work in a pipeline is done with file descriptors whereas
  the caller is dealing with handles.

  There is an overall $pipeline-r-fd and $pipeline-w-fd -- which the
  first and last commands use (indirectly via the per-command
  $cmd-r-fd and $cmd-w-fd).

  If the caller passed 'pipe-into or 'pipe-from as the first argument
  of the pipeline then $pipeline-*-fd are real pipes and the other
  ends of these are returned as pipe handles, $pipeline-w-ph and
  $pipeline-r-ph, for the caller to write into and read from the
  pipeline.

  $cmd-pipe is the inter-cmd pipe, created by the left hand command to
  generate its own output file descriptor and then to leave trailing
  around the loop an input file descriptor for the next command.

  For each command there is a per-cmd input file descriptor,
  $cmd-r-fd, and output file descriptor, $cmd-w-fd.

  The $cmd-r-fd is normally the pipe-reader of the previous command's
  $cmd-pipe except, of course, the first command whose $cmd-r-fd is
  $pipeline-r-fd.

  The $cmd-w-fd is normally the pipe-writer of of $cmd-pipe except, of
  course, the last command whose $cmd-w-fd is $pipeline-w-fd.

  The $pipeline-*-fd, the overarching input and output of the entire
  pipeline, could be:

  1. entities figured out by (stdin-fileno):

     a. regular C STDIN_FILENO and STDOUT_FILENO

     b. whatever (current-input-handle) and (current-output-handle)
        actually are

     c. either of which which could be string-handles (necessitating
        temporary files and some post-pipeline content recovery)

  2. actual pipes!

  3. future *stuff* (sockets are the obvious missing contender)

  *#

  pipeline-r-ph		:= gensym 'pl-r-h
  pipeline-w-ph		:= gensym 'pl-w-h

  pipeline-r-fd		:= gensym 'pl-r-fd
  cmd-r-fd		:= gensym 'cmd-r-fd
  close-pipeline-r-fd	:= gensym 'close-pl-r-fd

  pipeline-w-fd		:= gensym 'pl-w-fd
  cmd-w-fd		:= gensym 'cmd-w-fd
  recover-pipeline-w-fd := gensym 'rcvr-pl-w-fd

  stderr		:= gensym 'stderr

  pgid			:= gensym 'pgid
  job			:= gensym 'job
  proc-id		:= gensym 'proc-id
  cmd-pipe		:= gensym 'cmd-pipe
  pgrp-pipe		:= gensym 'pgrp-pipe
  proc			:= gensym 'proc
  pid			:= gensym 'pid
  status		:= gensym 'status

  nprocs := length op-args
  #T{
    {
      $pipeline-r-fd := #f
      $close-pipeline-r-fd := #f
      $pipeline-w-ph := #f
      if $use-w-pipe {
	w-pipe := (libc/pipe)
	$pipeline-w-ph = open-output-pipe (libc/pipe-writer w-pipe)
	$pipeline-r-fd = libc/pipe-reader w-pipe
      } {
	$pipeline-r-fd = (libc/stdin-fileno) ; STDIN_FILENO
	if (pair? $pipeline-r-fd) {
	  $pipeline-r-fd = ph $pipeline-r-fd
	  $close-pipeline-r-fd = $pipeline-r-fd
	}
      }
      ;; set $cmd-r-fd now as it is used immediately in the loop
      $cmd-r-fd := $pipeline-r-fd

      $pipeline-w-fd := #f
      $close-pipeline-w-fd := #f
      $pipeline-r-ph := #f
      $recover-pipeline-w-fd := #f
      (cond
       ($use-r-pipe {
	 r-pipe := (libc/pipe)
	 $pipeline-r-ph = open-input-pipe (libc/pipe-reader r-pipe)
	 $pipeline-w-fd = libc/pipe-writer r-pipe
       })
       ($collect {
	 $pipeline-w-fd = (libc/make-tmp-fd)
       })
       (else {
	 $pipeline-w-fd = (libc/stdout-fileno) ; STDOUT_FILENO
	 if (pair? $pipeline-w-fd) {
	   $recover-pipeline-w-fd = pht $pipeline-w-fd
	   $pipeline-w-fd = ph $pipeline-w-fd
	 }
       }))
      ;; $cmd-w-fd is (re-)set each time round the loop but needs to
      ;; exist in the first place
      $cmd-w-fd := #f

      ;; everyone gets the same stderr!
      $stderr := (libc/stderr-fileno) ; STDERR_FILENO

      $pgid := libc/0pid_t
      $job := make-%idio-job '$orig-pipeline #n $pgid #f #f #n $pipeline-r-fd $pipeline-w-fd $stderr

      $proc-id := 1
      $cmd-pipe := #n
      $pgrp-pipe := (libc/pipe)

      $@(map (function (cmd) {
	        #T{
		  {
		    $proc := make-%idio-process '$cmd -1 #f #f #n

		    ;; NB. Update the procs list asap as we can get a
		    ;; signal about processes in the pipeline at any
		    ;; time including, annoyingly, before we've
		    ;; finished creating the pipeline.
		    ;; do-job-notification/update-status will want to
		    ;; have a proc entry to update.
		    set-%idio-job-procs! $job (pair $proc (%idio-job-procs $job))

		    if ($proc-id lt $nprocs) {
		      $cmd-pipe = (libc/pipe)
		      $cmd-w-fd = (libc/pipe-writer $cmd-pipe)
		    } {
		      $cmd-w-fd = $pipeline-w-fd
		    }
		    $pid := (libc/fork)
		    if (C/== $pid libc/0pid_t) {
		      set-default-handler! ^idio-error default-child-handler
		      %prep-process $pgid $cmd-r-fd $cmd-w-fd $stderr $foreground

		      ;; The Libc texinfo page seems to have missed
		      ;; this.  On the basis that a $cmd-pipe is owned
		      ;; (created?) by the left hand process of the
		      ;; two being connected, then $cmd-r-fd is the
		      ;; (pipe-reader $cmd-pipe) of the left-hand
		      ;; process and will have been closed in
		      ;; %prep-process, above (unless it was
		      ;; $pipeline-r-fd).

		      ;; In turn, the current (pipe-reader $cmd-pipe)
		      ;; will become the $cmd-r-fd of the right-hand
		      ;; process (as the parent Idio also has it open
		      ;; and will pass it on).  But what of us?  Who
		      ;; closes (pipe-reader $cmd-pipe) in us?

		      ;; Ah, OK.  We do.
		      if ($proc-id lt $nprocs) {
			libc/close (libc/pipe-reader $cmd-pipe)
		      }

		      ;; We don't have the same problem with
		      ;; (pipe-writer $cmd-pipe) because we only
		      ;; create the $cmd-pipe when we know there is
		      ;; another process in the pipeline and
		      ;; $cmd-w-fd immediately becomes (pipe-writer
		      ;; $cmd-pipe).

		      ;; $cmd-r-fd is a left-over from the pipe of
		      ;; the left hand process and we are suffering an
		      ;; off-by-one error and the left-over one is the
		      ;; current (pipe-reader $cmd-pipe) we have in
		      ;; our hands.

		      if (C/== $pgid libc/0pid_t) {
			libc/close (libc/pipe-writer $pgrp-pipe)

			;; $pgid is 0 so we must be the first in the
			;; pipeline -- block reading a single byte
			;; from the $pgrp-pipe
			libc/read (libc/pipe-reader $pgrp-pipe) 1
			libc/close (libc/pipe-reader $pgrp-pipe)
                      } {
			libc/close (libc/pipe-reader $pgrp-pipe)
			libc/close (libc/pipe-writer $pgrp-pipe)
		      }

		      ;; tidy up any trailing $pipeline-*-fd ends
		      if (and (not (C/== $cmd-r-fd $pipeline-r-fd))
			      (not (C/== $pipeline-r-fd libc/STDIN_FILENO))) {
				libc/close $pipeline-r-fd
		      }
		      if (and (not (C/== $cmd-w-fd $pipeline-w-fd))
			      (not (C/== $pipeline-w-fd libc/STDOUT_FILENO))) {
				libc/close $pipeline-w-fd
		      }

		      (cond
		       ((pair? (ph '$cmd)) {
			 $@cmd
		       })
		       (else {
			 $cmd
		       }))

		      ;; If {cmd} was an external command then this
		      ;; child will have exec()'d it otherwise it is
		      ;; some Idio scripting whereon it will do its
		      ;; thing and continue onto here.  So we ought to
		      ;; definitively stop before this child continues
		      ;; back into the main Idio engine.

		      libc/exit 0
		    } {
		      set-%idio-process-pid! $proc $pid
		      if job-control/%idio-interactive {
			if (C/== $pgid libc/0pid_t) {
			  $pgid = $pid
			  set-%idio-job-pgid! $job $pgid
			}
			suppress-errors ^idio-error setpgid $pid $pgid
		      }
		    }

		    ;; tidy up any trailing $cmd-pipe ends
		    if (not (C/== $cmd-r-fd $pipeline-r-fd)) {
		      libc/close $cmd-r-fd
		    }
		    if (not (C/== $cmd-w-fd $pipeline-w-fd)) {
		      libc/close $cmd-w-fd
		    }

		    $cmd-r-fd = (libc/pipe-reader $cmd-pipe)
		    $proc-id = $proc-id + 1
		  }
	        }
      })
	 op-args)

      (cond
       ($use-w-pipe {
	 ;; parent should not hold the read end of the pipe-into pipe open
	 libc/close $pipeline-r-fd
       })
       ($use-r-pipe {
	 ;; parent should not hold the write end of the pipe-from pipe open
	 libc/close $pipeline-w-fd
       }))

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      ;; finally let the first process go
      libc/close (libc/pipe-reader $pgrp-pipe)
      libc/close (libc/pipe-writer $pgrp-pipe)

      (cond
       ($use-w-pipe {
	 $pipeline-w-ph
       })
       ($use-r-pipe {
	 $pipeline-r-ph
       })
       ($collect {
	 ;; wait for it!
	 if (not job-control/%idio-interactive) {
	   wait-for-job $job
	 } {
	   foreground-job $job #f
	 }

	 ;; OK, now recover the output
	 ih := open-input-file-from-fd $pipeline-w-fd
	 seek-handle ih 0 'set
	 os := (open-output-string)
	 display (read-lines ih) os
	 close-handle ih
	 strip-string (get-output-string os) "\n"
       })
       (else {
	 $status := #f
	 (cond
	  ((not job-control/%idio-interactive) {
	    $status = wait-for-job $job
	  })
	  ($foreground {
	    $status = foreground-job $job #f
	  })
	  (else {
	    $status = background-job $job #f
	  }))

	 if $close-pipeline-r-fd {
	   libc/close $close-pipeline-r-fd
	 }

	 if $recover-pipeline-w-fd {
	   ;; if the job was backgrounded then this won't do much!
	   ih := open-input-file-from-fd $pipeline-w-fd
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-pipeline-w-fd
	   close-handle ih
	 }

	 $status
       }))
    }
  }
}

define-template (fork-command foreground use-w-pipe use-r-pipe & cmd) {
  cmd-r-ph	   := gensym 'cmd-r-ph
  cmd-w-ph	   := gensym 'cmd-w-ph

  cmd-r-fd	   := gensym 'cmd-r-fd
  close-cmd-r-fd   := gensym 'close-cmd-r-fd

  cmd-w-fd	   := gensym 'cmd-w-fd
  recover-cmd-w-fd := gensym 'rcvr-cmd-w-fd

  cmd-e-fd	   := gensym 'cmd-e-fd
  recover-cmd-e-fd := gensym 'rcvr-cmd-e-fd

  pgid		   := gensym 'pgid
  proc		   := gensym 'proc
  job		   := gensym 'job
  pid		   := gensym 'pid
  status	   := gensym 'status

  #T{
    {
      $cmd-r-fd		:= #f
      $close-cmd-r-fd	:= #f
      $cmd-w-ph		:= #f
      if $use-w-pipe {
	w-pipe := (libc/pipe)
	$cmd-w-ph = open-output-pipe (libc/pipe-writer w-pipe)
	$cmd-r-fd = libc/pipe-reader w-pipe
      } {
	$cmd-r-fd       = (libc/stdin-fileno) ; STDIN_FILENO
	$close-cmd-r-fd = #f
	if (pair? $cmd-r-fd) {
	  $cmd-r-fd       = ph $cmd-r-fd
	  $close-cmd-r-fd = $cmd-r-fd
	}
      }

      $cmd-w-fd		:= #f
      $close-cmd-w-fd	:= #f
      $cmd-r-ph		:= #f
      $recover-cmd-w-fd := #f
      if $use-r-pipe {
	r-pipe := (libc/pipe)
	$cmd-r-ph = open-input-pipe (libc/pipe-reader r-pipe)
	$cmd-w-fd = libc/pipe-writer r-pipe
      } {
	$cmd-w-fd         = (libc/stdout-fileno) ; STDOUT_FILENO
	$recover-cmd-w-fd = #f
	if (pair? $cmd-w-fd) {
	  $recover-cmd-w-fd = pht $cmd-w-fd
	  $cmd-w-fd         = ph $cmd-w-fd
	}
      }

      $cmd-e-fd         := (libc/stderr-fileno) ; STDERR_FILENO
      $recover-cmd-e-fd := #f
      if (pair? $cmd-e-fd) {
	$recover-cmd-e-fd = pht $cmd-e-fd
	$cmd-e-fd         = ph $cmd-e-fd
      }
      $pgid := libc/0pid_t
      $proc := make-%idio-process '$cmd -1 #f #f #n
      $job := make-%idio-job '$cmd (list $proc) $pgid #f #f #n $cmd-r-fd $cmd-w-fd $cmd-e-fd

      $pid := (libc/fork)
      (cond
       ((C/== $pid libc/0pid_t) {
	 set-default-handler! ^idio-error default-child-handler
	 %prep-process $pgid $cmd-r-fd $cmd-w-fd $cmd-e-fd $foreground
	 (cond
	  ((pair? (ph '$cmd)) {
	    $@cmd
	  })
	  (else $cmd))

	 libc/exit 0
       })
       (else {
	 set-%idio-process-pid! $proc $pid
	 if job-control/%idio-interactive {
	   $pgid = $pid
	   set-%idio-job-pgid! $job $pgid
	   suppress-errors ^idio-error setpgid $pid $pgid
	 }
       }))

      (cond
       ($use-w-pipe {
	 ;; parent should not hold the read end of the pipe-into pipe open
	 libc/close $cmd-r-fd
       })
       ($use-r-pipe {
	 ;; parent should not hold the write end of the pipe-from pipe open
	 libc/close $cmd-w-fd
       }))

      %idio-jobs = pair $job %idio-jobs
      %%last-job = $job

      (cond
       ($use-w-pipe {
	 $cmd-w-ph
       })
       ($use-r-pipe {
	 $cmd-r-ph
       })
       (else {
	 $status := #f
	 (cond
	  ((not job-control/%idio-interactive) {
	    $status = wait-for-job $job
	  })
	  ($foreground {
	    $status = foreground-job $job #f
	  })
	  (else {
	    $status = background-job $job #f
	  }))

	 if $close-cmd-r-fd {
	   libc/close $close-cmd-r-fd
	 }

	 if $recover-cmd-w-fd {
	   ih := open-input-file-from-fd $cmd-w-fd

	   ;; NB the temporary file has just been written to so the file
	   ;; pointer is currently at the end, we need to set it back to
	   ;; the start to be able to read anything!
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-cmd-w-fd
	   close-handle ih
	 }

	 if $recover-cmd-e-fd {
	   ih := open-input-file-from-fd $cmd-e-fd

	   ;; NB the temporary file has just been written to so the file
	   ;; pointer is currently at the end, we need to set it back to
	   ;; the start to be able to read anything!
	   seek-handle ih 0 'set
	   display (read-lines ih) $recover-cmd-e-fd
	   close-handle ih
	 }

	 $status
       }))
    }
  }
}

define-template (fg-job & cmd) {
  #T{ fork-command #t #f #f $@cmd }
}

define-template (bg-job & cmd) {
  #T{ fork-command #f #f #f $@cmd }
}

define-template (pipe-into & cmd) {
  #T{ fork-command #f #t #f $@cmd }
}

define-template (pipe-from & cmd) {
  #T{ fork-command #f #f #t $@cmd }
}

define (wait & jobs) {
  notify := #f

  loop :+ function (jobs) {
	    if (null? jobs) #t {
	      notify = #t
	      wait-for-job (ph jobs)
	      loop (pt jobs)
	    }
  }

  if (null? jobs) {
    jobs = %idio-jobs
  }

  loop jobs

  if notify (do-job-notification)
}

#*

with-handle-redir type s/d thunk

wrapper functions with-input-from, with-output-to and with-error-to
are identical barring some "directional" function calls.  We'll have a
generic function instead.

{type} is the symolic name of the handle being modified: 'input,
'output, 'error

{s/d} (source/destination) can be:
1. a handle (fd or string)
2. a literal string which will be interpreted as the name of the
   fd to open as per:
     open-output-fd {s/d} or
     open-input-fd {s/d}
3. #n as shorthand for the string "/dev/null"

{thunk} is the 0-arg function to invoke

*#

with-handle-redir := {
  current-input-handle	:= current-input-handle
  current-output-handle := current-output-handle
  current-error-handle	:= current-error-handle
  set-input-handle!	:= set-input-handle!
  set-output-handle!	:= set-output-handle!
  set-error-handle!	:= set-error-handle!

  function (type s/d thunk) {
    ;; handle-oriented indirection function/variables
    get-current-h	:= #f
    open-fd-h		:= #f
    open-file-h		:= #f
    set-h!		:= #f
    dir-fd-h?		:= #f
    dir-string-h?	:= #f
    dir-msg		:= #f

    (cond
     ((eq? type 'input) {
       get-current-h	= current-input-handle
       open-fd-h	= open-input-fd
       open-file-h	= open-input-file
       set-h!		= set-input-handle!
       dir-fd-h?	= input-fd-handle?
       dir-string-h?	= input-string-handle?
       dir-msg		= "input"
     })
     ((eq? type 'output) {
       get-current-h	= current-output-handle
       open-fd-h	= open-output-fd
       open-file-h	= open-output-file
       set-h!		= set-output-handle!
       dir-fd-h?	= output-fd-handle?
       dir-string-h?	= output-string-handle?
       dir-msg		= "output"
     })
     ((eq? type 'error) {
       get-current-h	= current-error-handle
       open-fd-h	= open-output-fd
       open-file-h	= open-output-file
       set-h!		= set-error-handle!
       dir-fd-h?	= output-fd-handle?
       dir-string-h?	= output-string-handle?
       dir-msg		= "output"
     })
     (else (error 'with-handle-redir "unexpected handle type" type)))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    ;; if we create a new handle we need to close it afterwards
    close-h := #f

    (cond
     ((dir-fd-h? s/d)      (new-h = s/d))
     ((fd-handle? s/d)     (error 'with-handle-redir (append-string "not an " dir-msg "-fd-handle") s/d))
     ((dir-string-h? s/d)  (new-h = s/d))
     ((string-handle? s/d) (error 'with-handle-redir (append-string "not an " dir-msg "-string-handle") s/d))
     ((string? s/d) {
       new-h = open-file-h s/d
       close-fd-handle-on-exec new-h
       close-h = #t
     })
     ((null? s/d) {
       new-h = open-file-h "/dev/null"
       close-fd-handle-on-exec new-h
       close-h = #t
     })
     (else (error 'with-handle-redir (append-string "unexpected " dir-msg) s/d)))

    if new-h {
      set-h! new-h
    } {
      error 'with-handle-redir (append-string "unexpected " dir-msg) s/d
    }

    unwind-protect {
      (thunk)
    } {
      if close-h {
	close-handle new-h
      }
      set-h! old-h
    }
  }
}

define (with-input-from src thunk) {
  with-handle-redir 'input src thunk
}

define (with-output-to dst thunk) {
  with-handle-redir 'output dst thunk
}

define (with-error-to dst thunk) {
  with-handle-redir 'error dst thunk
}

;; collect-output works fine for standalone commands, (collect-output
;; uname -n), but is caught up in a pipeline by the reader operator.
;; See above.
define-template (collect-output & cmd) {
  osh := gensym 'osh
  #T{
    $osh := (open-output-string)
    with-output-to $osh (function #n {
			   fg-job $@cmd
    })
    strip-string (get-output-string $osh) "\n"
  }
}

#*

with-handle-dup type new thunk

nominal functions dup-input-from, dup-output-to and dup-error-to are
identical barring some "directional" function calls.  We'll have a
generic function instead.

{type} is the symolic name of the handle being modified: 'input,
'output, 'error

{new} can be:
1. a handle (file or string)
2. a C int or fixnum which will be interpreted as the name of the
   file descriptor to call dup2(2) with

{thunk} is the 0-arg function to invoke

*#

with-handle-dup := {
  current-input-handle  := current-input-handle
  current-output-handle := current-output-handle
  current-error-handle  := current-error-handle
  set-input-handle!     := set-input-handle!
  set-output-handle!    := set-output-handle!
  set-error-handle!     := set-error-handle!

  function (type new thunk) {
    ;; handle-oriented indirection function/variables
    get-current-h := #f
    set-h!        := #f
    dir-file-h?   := #f
    dir-string-h? := #f
    msg-h         := #f
    (cond
     ((eq? type 'input) {
       get-current-h = current-input-handle
       set-h!        = set-input-handle!
       dir-file-h?   = input-file-handle?
       dir-string-h? = input-string-handle?
       msg-h         = "input"
     })
     ((eq? type 'output) {
       get-current-h = current-output-handle
       set-h!        = set-output-handle!
       dir-file-h?   = output-file-handle?
       dir-string-h? = output-string-handle?
       msg-h         = "output"
     })
     ((eq? type 'error) {
       get-current-h = current-error-handle
       set-h!        = set-error-handle!
       dir-file-h?   = output-file-handle?
       dir-string-h? = output-string-handle?
       msg-h         = "output"
     })
     (else (error 'with-handle-dup "unexpected handle type" type)))

    ;; old and new handles
    old-h := (get-current-h)
    new-h := #f

    (cond
     ((dir-file-h? new) {
       new-h = new
     })
     ((file-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-file-handle") new))
     ((dir-string-h? new) (new-h = new))
     ((string-handle? new) (error 'with-handle-dup (append-string "not an " msg-h "-string-handle") new))
     ((or (C/int? new)
	  (fixnum? new)) {
	    if (C/int? new) (new = C/->integer new)
	    (cond
	     ((eq? new 0) {
	       new-h = (current-input-handle)
	     })
	     ((eq? new 1) {
	       new-h = (current-output-handle)
	     })
	     ((eq? new 2) {
	       new-h = (current-error-handle)
	     }))
	  })
     (else (error 'with-handle-dup (append-string "unexpected " msg-h) new)))

    (cond
     (new-h {
       set-h! new-h
     })
     (else {
       error 'with-handle-dup (append-string "unexpected " msg-h) new
     }))

    unwind-protect {
      (thunk)
    } {
      set-h! old-h
    }
  }
}

;; ... < e1 ...
;; ... > e1 ...
;; ... 2> e1 ...
define-infix-operator > 600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  (cond
   ((eq? op '<) {
     type = 'input
   })
   ((eq? op '>) {
     type = 'output
   })
   ((eq? op '2>) {
     type = 'error
   })
   (else (error op "unexpected op" op)))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-redir '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  result
}

define-infix-operator < 600 \>
define-infix-operator 2> 600 \>

;; ... <& e1 ...
;; ... >& e1 ...
;; ... 2>& e1 ...
define-infix-operator >& 600 {
  suffix := #n

  if (and (pair? after)
	  (pair? (pt after))
	  (not (null? (pt (pt after))))) {
    suffix = pt after
    after = (list (ph after))
  }

  type := #f
  (cond
   ((eq? op '<&) {
     type = 'input
   })
   ((eq? op '>&) {
     type = 'output
   })
   ((eq? op '2>&) {
     type = 'error
   })
   (else (error op "unexpected op" op)))

  result := #n

  if (null? suffix) {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $before
      })
    }
  } {
    result = #T{ with-handle-dup '$type $(ph after) (function () {
        $(operator-expand (append before suffix))
      })
    }
  }

  result
}

define-infix-operator <& 600 \>&
define-infix-operator 2>& 600 \>&

define (jobs) "display the state of outstanding jobs" {
  first-j := #t
  jobs-loop :+ function (jobs) {
		 (cond
		  ((null? jobs) {
		    #t
		  })
		  (else {
		    job := ph jobs
		    if first-j {
		      first-j = #f
		      printf "%5s %s\n" "pgid" "job-pipeline"
		    }
		    printf "%5s %s\n" (%idio-job-pgid job) (%idio-job-pipeline job)

		    first-p := #t

		    procs-loop :+ function (procs) {
				    proc := ph procs
				    if (null? proc) #t {
				      if first-p {
					first-p = #f
					printf "  %5s %2s %2s %s\n" "pid" "C?" "S?" "argv"
				      }
				      printf "  %5s %s %s %s\n" (%idio-process-pid proc) (%idio-process-completed proc) (%idio-process-stopped proc) (%idio-process-argv proc)
				      procs-loop (pt procs)
				    }
		    }

		    (and (procs-loop (reverse (%idio-job-procs job)))
			 (jobs-loop (pt jobs)))
		  }))
  }

  jobs-loop %idio-jobs
}

provide job-control
