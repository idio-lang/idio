;;
;; Copyright (c) 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; posix-regex.idio
;;

define (regex-matches rx str) "
does `rx` match `str`?

:param rx: regular expression
:type rx: string
:param str: string to match against
:type str: string
:return: see :ref:`regexec <regexec>`
" {
  regexec (regcomp rx) str
}

#*

When we run regex-case/pattern-case the chances are we'll be looping
over the same *-case expression repeatedly.  In which case what we
really want to be doing is pre-computing the regcomp and referring
back to it.  Store those references in an array.

The array is external to any loop, ie global.  That means the regcomp
results live forever.  Not ideal.

*#

*regcomp-table* := #{}

define-template (regex-case e & clauses) {
  ;; regex-strings want to extract the regex strings
  regex-strings :+ function (c* r) {
		     (cond
		      ((null? c*) (reverse r))
		      ((or (not (pair? c*))
			   (not (pair? (ph c*)))
			   (not (pair? (pth c*)))) (error/type ^rt-syntax-error 'regex-case "invalid syntax" c*))
		      ((null? (pt c*)) {
			if (eq? 'else (phh c*)) {
			  reverse r
			} {
			  reverse (pair (phh c*) r)
			}
		      })
		      (else {
			regex-strings (pt c*) (pair (phh c*) r)
		      }))

  }

  ;; put {key} in scope of gen-clauses to save passing it as an
  ;; argument
  key := gensym 'key

  gen-clauses :+ function (c*) {
		   (cond
		    ((null? c*) '#n)
		    ((or (not (pair? c*))
			 (not (pair? (ph c*)))
			 (not (pair? (pth c*)))) (error/type ^rt-syntax-error 'regex-case "invalid syntax" c*))
		    ((null? (pt c*)) {
		      if (eq? 'else (phh c*)) {
			#T{
			  ((else ((function (r) {
				     $@(pth c*)
			  }) $key)))
			}
		      } {
			#T{
			  (((regexec (hash-ref *regcomp-table* $(phh c*)) $key) => (function (r) {
										$@(pth c*)
			  })))
			}
		      }
		    })
		    (else {
		      #T{
			(((regexec (hash-ref *regcomp-table* $(phh c*)) $key) => (function (r) {
									      $@(pth c*)
			})) $@(gen-clauses (pt c*)))
		      }
		    }))

  }

  #T{
    $@(map (function (s) {
	      #T{
		if (not (hash-exists? *regcomp-table* $s)) {
		  hash-set! *regcomp-table* $s (regcomp $s)
		}
	      }
    }) (regex-strings clauses #n))
    {
      ;; evaluate {e} (once!)
      $key := $e

      cond $@(gen-clauses clauses)
    }
  }
}

define-template (pattern-case e & clauses) {
  ;; regex-strings want to extract the regex strings
  regex-strings :+ function (c* r) {
		     (cond
		      ((null? c*) (reverse r))
		      ((or (not (pair? c*))
			   (not (pair? (ph c*)))
			   (not (pair? (pth c*)))) (error/type ^rt-syntax-error 'pattern-case "invalid syntax" c*))
		      ((null? (pt c*)) {
			if (eq? 'else (phh c*)) {
			  reverse r
			} {
			  reverse (pair (phh c*) r)
			}
		      })
		      (else {
			regex-strings (pt c*) (pair (phh c*) r)
		      }))

  }

  ;; put {key} in scope of gen-clauses to save passing it as an
  ;; argument
  key := (gensym 'key)

  gen-clauses :+ function (c*) {
		   (cond
		    ((null? c*) '#n)
		    ((or (not (pair? c*))
			 (not (pair? (ph c*)))
			 (not (pair? (pth c*)))) (error/type ^rt-syntax-error 'pattern-case "invalid syntax" c*))
		    ((null? (pt c*)) {
		      if (eq? 'else (phh c*)) {
			#T{
			  ((else ((function (r) {
				     $@(pth c*)
			  }) $key)))
			}
		      } {
			#T{
			  (((regexec (hash-ref *regcomp-table* $(phh c*)) $key) => (function (r) {
										$@(pth c*)
			  })))
			}
		      }
		    })
		    (else {
		      #T{
			(((regexec (hash-ref *regcomp-table* $(phh c*)) $key) => (function (r) {
									      $@(pth c*)
			})) $@(gen-clauses (pt c*)))
		      }
		    }))

  }

  ;; pattern-case rewrite loop
  pcr-loop :+ function (str) {
	    (regex-case str
			("(.*)\\*(.*)" {
			  append-string r.1 ".*" (pcr-loop r.2)
			})
			("(.*)\\?(.*)" {
			  append-string r.1 "." (pcr-loop r.2)
			})
			(else r))
  }


  #T{
    $@(map (function (s) {
	      ;s = sprintf "^%s$" (pcr-loop s)
	      #T{
		if (not (hash-exists? *regcomp-table* $s)) {
		  hash-set! *regcomp-table* $s (regcomp (sprintf "^%s$" $(pcr-loop s)))
		}
	      }
    }) (regex-strings clauses #n))
    {
      ;; evaluate {e} (once!)
      $key := $e

      cond $@(gen-clauses clauses)
    }
  }
}
