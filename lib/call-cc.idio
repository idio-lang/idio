;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; call-cc.idio
;;
;;

;; We're going to redefine call/cc (at least) twice.  call/cc is
;; normally used like this:

;; call/cc (function (k) {
;;            ...do something with k...
;;	      ; you *could* invoke it with a value
;;            k value
;;	      ; but more likely you store it
;;            thing = k
;;            ; then invoke some risky function
;;            risky job
;;            })

;; (risky job) will normally just run, return a value which call/cc
;; will return in turn.  If risky job has gone a bit haywire then
;; either it or some other mechanism (a trap?) can now invoke (thing
;; value) -- assuming {thing} is in scope! -- and call/cc will return
;; {value} as if (risky job) has returned it.

;; If you want a "<k is here>" marker then invoking {k} is a mechanism
;; to return from the call to call/cc -- from anywhere the stashed
;; value of {k} is in scope!

;; So call/cc, a function, expects as its only argument a function
;; which in turn expects a single argument, the continuation.  The
;; continuation itself can be stored or invoked with a single value,
;; the value to continue the continuation with.

;; The continuation of call/cc, k, is, as noted above, a mechanism to
;; return from the call to call/cc -- potentially a second or third
;; time.

;; With that in mind, invoking the continuation *inside* the function
;; passed to call/cc is a bit pointless in the sense that you return
;; from call/cc just as you would have anyway.  However, you would
;; normally store the continuation in a variable that is in scope for
;; some other part of the code to call as part of some recovery
;; process.

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Below, when we're redefining call/cc, we're using k-proc to
;; represent the 1-ary function that call/cc expects and k to
;; represent the continuation.

;; In that light, we could have written the original usage as:

;; k-proc := function (k) {
;;             ...do something with k...
;;	       ; store it
;;             thing = k
;;	       ; invoke it with a value
;;             k value
;; }
;;
;; call/cc k-proc

;; except we'd be filling the top-level namespace with junk names --
;; is this {k-proc} my k-proc or your k-proc?

;; In all redefinitions we can use the current/original call/cc
;; (whether that is one of these redefinitions or the original
;; primitive) to carry out the actual dirty business of implementing
;; the continuation.

;; Clearly, something needs to exists to bootstrap everything and that
;; is the primitive %%call/cc, defined in vm.c.

call/cc := %%call/cc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; values, call-with-values and call/cc are concomitant

;; from Kent Dybvig
;; http://www.scheme.com/tspl3/control.html#./control:s53

values := #f
call-with-values := #f

{

  ;; magic is simply a unique/sentinel value -- any pair will do
  magic := pair 'multiple 'values

  magic? := function (x) {
	      and (pair? x) \
		  (eq? (ph x) magic)
  }

  ;; Ordinarily orig-call/cc could live inside the block defining
  ;; call/cc however we want to reuse the :docstr properties.

  orig-call/cc := call/cc
  call/cc = {

    function (k-proc) "
This is the call-with-values call/cc variant which calls:

" {
      orig-call/cc (function (k) {

		      ;; Dirty trick time!  k-proc should be a 1-ary
		      ;; function -- but what if it was passed more
		      ;; than one arg?  Being given more than one arg
		      ;; isn't a problem except that the continuation
		      ;; we're about to call only accepts 1 argument.

		      ;; Here we solve that problem by transforming
		      ;; the n args into a single value where for 2 or
		      ;; more args the 1-ary arg becomes '(magic args)
		      ;; through applying the function {values} to
		      ;; {args}.

		      ;; We can now call the continuation with our
		      ;; faked single value.

		      k-proc (function args {
				k (apply values args)
		      })
      })
    }
  }

  %set-property! call/cc :docstr-raw (string-append (%property call/cc :docstr-raw) (%property orig-call/cc :docstr-raw))

  ;; Remember, with this form, {args} will be #n or a list

  values = function args {
	     if (and (not (null? args))
		     (null? (pt args))) {
	       ph args
	     } {
	       pair magic args
	     }
  }

  call-with-values = function (producer consumer) {
		       x := (producer)
		       if (magic? x) {

			 ;; multiple args so use {apply} to flatten
			 ;; the list -- removing {magic} from the
			 ;; front

			 apply consumer (pt x)
		       } {
			 consumer x
		       }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This is derived from implementations as described in R5RS
;; documentation.

;; dynamic-wind and call/cc are concomitant

;; From the R5RS report

;; A state space is a tree with the current state at the root. Each
;; node other than the root is a triple <before,after,parent>,
;; represented in this implementation as two pairs:

;; ((before . after) . parent)

;; Navigating between states requires re-rooting the tree by reversing
;; parent-child links.

;call/cc := call/cc
dynamic-wind := #f

{
  *here* := list #f
  original-call/cc := call/cc

  ;; reroot! is playing a very dirty trick.  It is modifying the
  ;; *contents* of {*here*} and {there} and then changing what
  ;; {*here*} refers to which is critical because the callers of
  ;; reroot! have generally taken a reference to {*here*} (as it was
  ;; when they started).

  ;; The important part about reroot! modifying the *contents* is
  ;; because of the eq? test.  eq? will be testing the address in
  ;; memory of the pairs and not the contents of the pairs.  It is
  ;; obviously true that if the two variables refer to the same
  ;; address then they are the same.  However, they no longer have the
  ;; contents you first thought of.

  ;; The callers' reference to {*here*} (usually called {here})
  ;; started as, probably, (#f . #n) but will become

  ;; ((after . before) . orig-there)

  ;; and {orig-there} was itself ((before . after) . orig-*here*)

  ;; which means when the caller subsequently calls reroot! again with
  ;; {here} they're actually calling it with ((after . before)
  ;; . orig-there) which means the first thing reroot! does is call
  ;; itself with (pt there), ie. {orig-there}.

  ;; But wait!  {orig-there} was *also* modified by reroot! to be (#f
  ;; . #n) which now eq? {*here*} because reroot! changed what
  ;; {*here*} referred to as well (to {orig-there} in fact).

  ;; Don't forget, if you're remotely following, that any modification
  ;; to {there} will affect all those who were referencing it as part
  ;; of another data structure!

  ;; A neat side-effect of toggling the (after . before) pair is that
  ;; reroot!  will now blindly call ({before}) as previously but now
  ;; {before} -- (phh there) -- is actually {after}.

  define (reroot! there) {
    if (not (eq? *here* there)) {
      reroot! (pt there)
      {
        before := phh there
	after := pth there
	set-ph! *here* (pair after before)
	set-pt! *here* there
	set-ph! there #f
	set-pt! there '()
	*here* = there
	(before)
      }
    }
  }

  ;; NB redefine call/cc while we're here so that it can call reroot!
  ;; with {here} (whatever value it actually has by then) and
  ;; ultimately call {after} before calling the continuation.

  call/cc = function (k-proc) "
This is the dynamic-wind call/cc variant which calls:

" {
	      here := *here*
	      original-call/cc (function (k) {
				  k-proc (function results {
					    reroot! here
					    apply k results
				  })
	      })
  }

  %set-property! call/cc :docstr-raw (string-append (%property call/cc :docstr-raw) (%property original-call/cc :docstr-raw))

  dynamic-wind = function (before during after) {
		   here := *here*
		   reroot! (pair (pair before after) here)
		   call-with-values during (function results {
					      reroot! here
					      apply values results
		   })
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;call-with-current-continuation := call/cc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Now we have a dynamic-wind, unwind-protect is a specialisation

define-syntax unwind-protect (syntax-rules ()
    ((_ body cleanup ...)
     (dynamic-wind
       (function () #f)
       (function () body)
       (function () cleanup ...))))

;; {with-condition-handler} will invoke {handler} and then
;; automatically invoke the continuation of {with-condition-handler}
;; with the result.
;;
;; The continuation is in scope of both {handler} and {body} as
;; {return/handler}.
define-macro (with-condition-handler condition handler & body) {
  #T{
    return/handler := #n

    trap $condition (function (c) {
		       return/handler ($handler c)
    }) {
      call/cc (function (k) {
		 return/handler = k
		 $@body
      })
    }
  }
}

;; {trap*} is similar to {with-condition-handler} but allows the user
;; to determine if they should return a result from {handler} or
;; invoke the continuation, {return/trap}, inside either {handler} or
;; {body}.
define-macro (trap* condition handler & body) {
  #T{
    return/trap := #n

    trap $condition $handler {
      call/cc (function (k) {
		 return/trap = k
		 $@body
      })
    }
  }
}
