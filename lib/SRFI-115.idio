#*

Copyright (c) 2020 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SRFI-115.idio

A port of SRFI-115 Scheme Regular Expressions.  In particular
https://github.com/ashinn/chibi-scheme/blob/master/lib/chibi/regexp.scm.

*#

module SRFI-115
export (regexp regexp? valid-sre? rx regexp->sre char-set->sre
						 regexp-matches regexp-matches? regexp-search
						 regexp-replace regexp-replace-all
						 regexp-fold regexp-extract regexp-split regexp-partition
						 regexp-match? regexp-match-count
						 regexp-match-submatch regexp-match-submatch/list
						 regexp-match-submatch-start regexp-match-submatch-end
						 regexp-match->list regexp-match->sexp)

import SRFI-14
import unicode

;; regexp.scm -- simple non-bactracking NFA implementation
;; Copyright (c) 2013-2016 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;; An rx represents a start state and meta-info such as the number
;;; and names of submatches.
define-struct Rx start-state num-matches num-save-indexes non-greedy-indexes match-rules match-names sre
define regexp? Rx?
define regexp->sre Rx-sre

define (Rx-as-string rx seen-rxs) {
  if (Rx? rx) {
    r := (open-output-string)
    hprintf r "#<SI Rx"
    hprintf r " ss=%s" (state-as-string rx.start-state #n)
    hprintf r " n-m=%s" rx.num-matches
    hprintf r " n-si=%s" rx.num-save-indexes
    hprintf r " n-gi=%s" rx.non-greedy-indexes
    hprintf r " m-r=%s" rx.match-rules
    hprintf r " m-n=%s" rx.match-names
    hprintf r " sre=%s" rx.sre
    hprintf r ">"
    get-output-string r
  } #n
}

%%add-as-string Rx Rx-as-string

;; Syntactic sugar.
define-syntax rx \
	      (syntax-rules ()
			    ((rx sre ...)
			     (regexp #T{ (: sre ...) })))

;;; A state is a single nfa state with transition rules.
define-struct state accept? chars match match-rule next1 next2 id

make-state = {
  orig-make-state := make-state

  function (accept? chars match match-rule next1 next2 id) {
    if (and next1 (not (state? next1))) (error 'make-state "expected a state" next1)
    if (and next2 (not (state? next2))) (error 'make-state "expected a state" next2)
    orig-make-state accept? chars match match-rule next1 next2 id
  }
}

~none		:= #B{ 3 }
~ci?		:= #B{ 3 1 }
~ascii?		:= #B{ 3 01 }
~nocapture?	:= #B{ 3 001 }

define (flag-set? flags i)	(equal-bitset? i (and-bitset flags i))
define (flag-join a b)		(ior-bitset a b)
define (flag-clear a b)		(and-bitset a (not-bitset b))

define (char-set-ci cset) {
  cased := (char-set)
  char-set-for-each-set cset (function (ch) {
				cond ((char-set-ref char-set:lower-case ch) {
				  uc := hash-ref char-set:simple-upper-case-map ch #f
				  if uc (char-set-set! cased uc)
				}) \
				     ((char-set-ref char-set:upper-case ch) {
				       lc := hash-ref char-set:simple-lower-case-map ch #f
				       if lc (char-set-set! cased lc)
				     })
  })
  ior-char-set cset cased
}

define (make-char-state ch flags next id) {
  if (flag-set? flags ~ci?) {
    cset := cond ((unicode? ch) (char-set-ci (char-set ch))) \
		 ((char-set? ch) (char-set-ci ch)) \
		 (else ch)
    make-state #f cset #f #f next #f id
  } {
    make-state #f ch #f #f next #f id
  }
}
define (make-fork-state next1 next2 id) {
  make-state #f #f #f #f next1 next2 id
}
define (make-epsilon-state next id) {
  make-fork-state next #f id
}
define (make-accept-state id) {
  make-state #t #f #f #f #f #f id
}

;; A record holding the current match data - essentially a wrapper
;; around an array, plus a reference to the RX for meta-info.
define-struct regexp-match matches rx string

define (regexp-match-rules md) {
  Rx-match-rules (regexp-match-rx md)
}
define (regexp-match-names md) {
  Rx-match-names (regexp-match-rx md)
}
define (make-regexp-match+ len rx str) {
  make-regexp-match (make-array len #f) rx str
}
define (make-regexp-match-for-rx rx str) {
  make-regexp-match+ (Rx-num-save-indexes rx) rx str
}
define (regexp-match-count md) {
  (quotient (array-length (regexp-match-matches md)) 2) - 1
}

define (regexp-match-name-offset md name) {
  lp :+ function (ls first) {
	  cond ((null? ls) (or first (error 'regexp-match-name-offset "unknown match name" md name))) \
	       ((eq? name (phh ls))
		(if (regexp-match-submatch-start+end md (pth ls))
		    (pth ls)
		    (lp (pt ls) (or first (pth ls))))) \
	       (else (lp (pt ls) first))
  }

  lp (regexp-match-names md) #f
}

define (regexp-match-ref md n) {
  array-ref (regexp-match-matches md) \
	    (if (integer? n)
		n
		(regexp-match-name-offset md n))
}

define (regexp-match-set! md n val) {
  array-set! (regexp-match-matches md) n val
}

define (copy-regexp-match md) {
  src := regexp-match-matches md
  len := array-length src
  dst := make-array len #f

  do ((i 0 (i + 1))) \
     ((== i len)
      (make-regexp-match dst (regexp-match-rx md) (regexp-match-string md))) {
       array-set! dst i (array-ref src i)
     }
}

;;> Returns the matching result for the given named or indexed
;;> submatch \var{n}, possibly as a list for a submatch-list, or
;;> \scheme{#f} if not matched.

define (regexp-match-submatch/list md n) {
  n := if (integer? n) n (regexp-match-name-offset md n)

  cond ((ge n (array-length (regexp-match-rules md)))
	#f) \
       (else {
	 rule := array-ref (regexp-match-rules md) n

	 cond ((pair? rule) {
	   start := regexp-match-ref md (ph rule)
	   end := regexp-match-ref md (pt rule)
	   str := regexp-match-string md

	   and start end (substring str start end)
	 }) \
	      (else {
		res := regexp-match-ref md rule

		if (pair? res) (reverse res) res
	      })
       })
}

;;> Returns the matching substring for the given named or indexed
;;> submatch \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch md n) {
  res := regexp-match-submatch/list md n

  if (pair? res) (ph res) res
}

define (regexp-match-submatch-start+end md n) {
  n := if (integer? n) n (regexp-match-name-offset md n)

  and (lt n (array-length (regexp-match-rules md))) {
    rule := array-ref (regexp-match-rules md) n
    if (pair? rule) {
      start := regexp-match-ref md (ph rule)
      end := regexp-match-ref md (pt rule)
      str := regexp-match-string md
      and start end (pair start end)
      } #f
  }
}

;;> Returns the start index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch-start md n) {
  cond ((regexp-match-submatch-start+end md n) => ph) \
       (else #f)
}

;;> Returns the end index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch-end md n) {
  cond ((regexp-match-submatch-start+end md n) => pt) \
       (else #f)
}

define (regexp-match-convert recurse? md str) {
  cond ((array? md) {
    lp :+ function (i res) {
	    cond ((ge i (array-length md))
		  (reverse res)) \
		 ((integer? (array-ref md i))
		  (lp (i + 2)
		      (pair (substring str (array-ref md i)
					   (array-ref md (i + 1)))
		       res))) \
		 (else
		  (lp (i + 1)
		      (pair (regexp-match-convert recurse? (array-ref md i) str)
			    res)))
    }

    lp 0 #n
  }) \
       ((list? md)
	(if recurse?
	    (map (function (x) (regexp-match-convert recurse? x str)) (reverse md))
	    (regexp-match-convert recurse? (ph md) str))) \
       ((and (pair? md) (integer? (ph md)) (integer? (pt md)))
	(substring str (ph md) (pt md))) \
       ((regexp-match? md)
	(regexp-match-convert
	 recurse? (regexp-match-matches md) (regexp-match-string md))) \
       (else
	md)
}

;;> Convert an regexp-match result to a list of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

define (regexp-match->list md) {
  regexp-match-convert #f md #f
}

;;> Convert an regexp-match result to a forest of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

define (regexp-match->sexp md) {
  regexp-match-convert #t md #f
}

;; Collect results from a list match.
define (match-collect md spec) {
  define (match-extract md n) {
    vec := regexp-match-matches md
    rules := regexp-match-rules md
    n-rule := array-ref rules n
    rule := array-ref rules n-rule

    if (pair? rule) {
      start := regexp-match-ref md (ph rule)
      end := regexp-match-ref md (pt rule)
      and start end (pair start end)
    } (regexp-match-ref md rule)
  }

  end := pht spec
  vec := regexp-match-matches md
  lp :+ function (i ls) {
	  if (ge i end) \
	     (reverse ls) \
	     (lp (i + 1) (pair (match-extract md i) ls))
  }

  lp (1 + (ph spec)) #n
}

;; A searcher represents a single rx state and match information.
define-struct searcher state matches

;; Merge two regexp-matches, preferring the leftmost-longest of their
;; matches, or shortest for non-greedy matches.
define (regexp-match>=? m1 m2) {
  non-greedy-indexes := Rx-non-greedy-indexes (regexp-match-rx m1)
  end := (array-length (regexp-match-matches m1)) - 1

  lp :+ function (i) {
	  cond ((ge i end)
		#t) \
	       ((and (eqv? (regexp-match-ref m1 i)
			   (regexp-match-ref m2 i))
		 (eqv? (regexp-match-ref m1 (i + 1))
		       (regexp-match-ref m2 (i + 1))))
		 (lp (i + 2))) \
	       (else
		(not 
		 (and (integer? (regexp-match-ref m2 i))
		      (or (not (integer? (regexp-match-ref m1 i)))
			  (lt (regexp-match-ref m2 i)
			      (regexp-match-ref m1 i))
			  ;; sanity check for incompletely advanced epsilons
			  (and (integer? (regexp-match-ref m1 (i + 1)))
			       (lt (regexp-match-ref m1 (i + 1))
				   (regexp-match-ref m1 i))) 
			  ((if (memq (i + 1) non-greedy-indexes) not values)
			   (and
			    (== (regexp-match-ref m2 i)
				(regexp-match-ref m1 i))
			    (or (not (integer? (regexp-match-ref m2 (i + 1))))
				(and (integer? (regexp-match-ref m1 (i + 1)))
				     (gt
				      (regexp-match-ref m2 (i + 1))
				      (regexp-match-ref m1 (i + 1)))))))))))
  }

  lp 0
}

define (regexp-match-max m1 m2) {
  if (regexp-match>=? m1 m2) m1 m2
}

;; Merge match data from sr2 into sr1, preferring the leftmost-longest
;; match in the event of a conflict.
define (searcher-merge! sr1 sr2) {
  m := regexp-match-max (searcher-matches sr1) (searcher-matches sr2)
  if (not (eq? m (searcher-matches sr1))) {
    set-searcher-matches! sr1 (copy-regexp-match m)
  }
}

define (searcher-max sr1 sr2) {
  if (or (not (searcher? sr2))
	 (regexp-match>=? (searcher-matches sr1) (searcher-matches sr2))) \
     sr1 \
     sr2
}

define (searcher-start-match sr) {
  regexp-match-ref (searcher-matches sr) 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A posse is a group of searchers.

define (make-posse & o) {
  make-hash 'eq?
}

define posse? hash?
define (posse-empty? posse) (zero? (hash-size posse))

define (posse-ref posse sr) {
  hash-ref posse (searcher-state sr) #f
}
define (posse-add! posse sr) {
  hash-set! posse (searcher-state sr) sr
}
define (posse-clear! posse) {
  hash-walk posse (function (key val) (hash-delete! posse key))
}
define (posse-for-each proc posse) {
  #*
  skeys := sort (hash-keys posse) (function (a b) {
				     lt a.id b.id
  })
  for-each (function (key) {
	      val := hash-ref posse key
	      proc val
  }) skeys
  *#
  hash-walk posse (function (key val) (proc val))
}
define (posse-every pred posse) {
  hash-fold posse (function (key val acc) (and acc (pred val))) #t
}

define (posse->list posse) {
  hash-values posse
}
define (list->posse ls) {
  searchers := (make-posse)
  for-each (function (sr) (posse-add! searchers sr)) ls
  searchers
}
define (posse & args) {
  list->posse args
}

define (make-start-searcher rx str) {
  make-searcher (Rx-start-state rx) (make-regexp-match-for-rx rx str)
}

define (state-as-string st seen-ids) {
  if (state? st) {
    r := (open-output-string)
    hprintf r "#<SI state "
    seen := assq st.id seen-ids
    if seen {
      hprintf r "@%s" (ph seen)
    } {
      seen-ids = pair (list st.id) seen-ids
      hprintf r "id=%2d ch=%2s a?=%s sm=%2s" st.id st.chars st.accept? st.match
      if st.next1 {
	seen = assq st.next1.id seen-ids
	if seen {
	  hprintf r " n1=@%s" (ph seen)
	} {
	  hprintf r " n1=%s" (state-as-string st.next1 seen-ids)
	}
      } {
	hprintf r " n1=%s" st.next1
      }
      if st.next2 {
	seen = assq st.next2.id seen-ids
	if seen {
	  hprintf r " n2=@%s" (ph seen)
	} {
	  hprintf r " n2=%s" (state-as-string st.next2 seen-ids)
	}
      } {
	hprintf r " n2=%s" st.next2
      }
    }
    hprintf r ">"
    get-output-string r
  } #n
}

%%add-as-string state state-as-string

define (searcher-as-string sr seen-searchers & o) {
  if (searcher? sr) {
    r := (open-output-string)
    hprintf r "#<SI searcher "
    if (not (null? o)) {
      hprintf r (ph o)
    }
    hprintf r "st=<%s>" (state-as-string (searcher-state sr) #n)
    hprintf r " ms=<%s>" (regexp-match-as-string sr.matches #n)
    hprintf r ">"
    get-output-string r
  } #n
}

%%add-as-string searcher searcher-as-string

define (psrs srs & o) {
  r := (open-output-string)
  skeys := sort (hash-keys srs) (function (a b) {
				   lt a.id b.id
  })
  for-each (function (k) {
	      v := hash-ref srs k
	      if (not (null? o)) {
		hprintf r (ph o)
	      }
	      hprintf r "st=<%s>" (state-as-string k)
	      hprintf r " v.m=<%s>;" (regexp-match-as-string v.matches)
  }) skeys
  get-output-string r
}

define (regexp-match-as-string rm seen-rms & o) {
  if (regexp-match? rm) {
    r := (open-output-string)
    hprintf r "#<SI regexp-match "
    if (not (null? o)) {
      hprintf r (ph o)
    }
    rx := regexp-match-rx rm
    hprintf r "ms=%-16s ss=%s ngi=%s" rm.matches (state-as-string (Rx-start-state rx) #n) (Rx-non-greedy-indexes rx)
    hprintf r ">"
    get-output-string r
  } #n
}

%%add-as-string regexp-match regexp-match-as-string

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Execution

;; A transition which doesn't advance the index.

define (epsilon-state? st) {
  or (not (state-chars st)) \
     (function? (state-chars st))
}

;; Match the state against a char and index.

define (state-matches? st str i ch start end matches) {
  matcher := state-chars st
  cond ((unicode? matcher)
	(eqv? matcher ch)) \
       ((char-set? matcher)
	(char-set-contains? matcher ch)) \
       ((pair? matcher)
	(and (char<=? (ph matcher) ch) (char<=? ch (pt matcher)))) \
       ((function? matcher)
	(matcher str i ch start end matches)) \
       ((not matcher)) \
       (else
	(error 'state-matches? "unknown state matcher" (state-chars st)))
}

;; Advance epsilons together - if the State is newly added to the
;; group and is an epsilon state, recursively add the transition.

define (posse-advance! new seen accept sr str i start end) {
  advance! :+ function (sr) {
		st := searcher-state sr
		;; Update match data.
		cond ((state-match st) {
		  index := state-match st
		  matches := searcher-matches sr
		  before := copy-regexp-match matches
		  cond ((pair? index) {
		    ;; Submatch list, accumulate and push.
		    prev := regexp-match-ref matches (ph index)
		    new := pair (match-collect matches (pt index)) \
				(if (pair? prev) prev #n)
		    regexp-match-set! matches (ph index) new
		  }) \
		       ((not (and (eq? 'non-greedy-left (state-match-rule st))
				  (regexp-match-ref matches index)
				  (ge (regexp-match-ref matches index)
				      (regexp-match-ref matches (index - 1)))))
			 (regexp-match-set! matches index i))
		})
		;; Follow transitions.
		cond ((state-accept? st)
		      (set-pt! accept (searcher-max sr (pt accept)))) \
		     ((posse-ref seen sr)
		      => (function (sr-prev) (searcher-merge! sr-prev sr))) \
		     ((epsilon-state? st) {
		       ch := and (lt i end) (string-ref str i)
		       cond ((state-matches? st str i ch start end (searcher-matches sr)) {
			 posse-add! seen sr
			 next1 := state-next1 st
			 next2 := state-next2 st
			 matches := and next2 (searcher-matches sr)
			 cond (next1 {
			   set-searcher-state! sr next1
			   advance! (make-searcher next1 (copy-regexp-match (searcher-matches sr)))
			 })
			 cond (next2 {
			   sr2 := make-searcher next2 (copy-regexp-match matches)
			   advance! sr2
			 })
		       })
		     }) \
		     ((posse-ref new sr) ; Non-special, non-epsilon searcher, add to posse.
		      ;; Merge regexp-match for existing searcher.
		      => (function (sr-prev) (searcher-merge! sr-prev sr))) \
		     (else
		      ;; Add new searcher.
		      (posse-add! new sr))
  }

  advance! sr
}

;; Run so long as there is more to match.

define (regexp-run-offsets search? rx str start end) {
  rx := regexp rx
  epsilons := (posse)
  accept := list #f

  lp :+ function (i searchers1 searchers2) {
	  ;; Advance initial epsilons once from the first index, or
	  ;; every time when searching.
	  cond ((or search? (== i start)) {
	    posse-advance! searchers1 epsilons accept (make-start-searcher rx str) \
						      str i start end
	    posse-clear! epsilons
	  })
	  cond ((or (ge i end)
		    (and search?
			 (searcher? (pt accept)) {
			   accept-start := searcher-start-match (pt accept)
			   posse-every (function (searcher)
					  (gt (searcher-start-match searcher)
					      accept-start)) \
				       searchers1
			 })
		    (and (not search?)
			 (posse-empty? searchers1)))
		 ;; Terminate when the string is done or there are no
		 ;; more searchers.  If we terminate prematurely and
		 ;; are not searching, return false.
		 (and (searcher? (pt accept)) {
		   matches := searcher-matches (pt accept)
		   and (or search? (ge (regexp-match-ref matches 1)
				       end)) \
		       (searcher-matches (pt accept))
		 })) \
	       (else {
		 ;; Otherwise advance normally.
		 ch := string-ref str i
		 i2 := i + 1
		 ;; NOTE: non-deterministic from hash order
		 posse-for-each (function (sr)
				   (cond
				    ((state-matches? (searcher-state sr)
						     str i ch
						     start end (searcher-matches sr)) {
						       set-searcher-state! sr (state-next1 (searcher-state sr))
						       ;; Epsilons are considered at the next position.
						       posse-advance! searchers2 epsilons accept sr str i2 start end
						       posse-clear! epsilons
						     }))) \
				searchers1
		 posse-clear! searchers1
		 lp i2 searchers2 searchers1
	       })
  }

  lp start (posse) (posse)
}

;; Wrapper to determine start and end offsets.

define (regexp-run search? rx str & o) {
  start := string-start-arg str o
  end := string-end-arg str (if (pair? o) (pt o) o)

  regexp-run-offsets search? rx str start end
}

;;> Match the given regexp or SRE against the entire string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

define (regexp-matches rx str & o) {
  apply regexp-run #f rx str o
}

;;> Match the given regexp or SRE against the entire string and return
;;> the \scheme{#t} on success.  Returns \scheme{#f} on failure.

define (regexp-matches? rx str & o) {
  and (apply regexp-matches rx str o) #t
}

;;> Search for the given regexp or SRE within string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

define (regexp-search rx str & o) {
  apply regexp-run #t rx str o
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiling

define (parse-flags ls) {
  define (symbol->flag s) {
    case s ((i ci case-insensitive) ~ci?) (else ~none)
  }
  lp :+ function (ls res) {
	  if (not (pair? ls)) \
	     res \
	     (lp (pt ls) (flag-join res (symbol->flag (ph ls))))
  }

  lp ls ~none
}

; unicode.idio defines:
; char-set:nonl
; char-set:control
; char-set:word-constituent
; %char-set:word-constituent
; char-set:cased rather than (get-char-set:cased)
define (char-word-constituent? ch) {
  char-set-contains? char-set:word-constituent ch
}

define (match/bos str i ch start end matches) {
  == i start
}
define (match/eos str i ch start end matches) {
  ge i end
}
define (match/bol str i ch start end matches) {
  or (== i start) \
     (eqv? #\{newline} (string-ref str (i - 1)))
}
define (match/eol str i ch start end matches) {
  or (ge i end) \
     (eqv? #\{newline} (string-ref str i))
}
define (match/bow str i ch start end matches) {
  and (lt i end) \
      (or (== i start)
	  (not (char-word-constituent?
		(string-ref str (i - 1))))) \
      (char-word-constituent? ch)
}
define (match/eow str i ch start end matches) {
  and (or (ge i end)
	  (not (char-word-constituent? ch))) \
      (gt i start) \
      (char-word-constituent?
       (string-ref str (i - 1)))
}
define (match/nwb str i ch start end matches) {
  and (not (match/bow str i ch start end matches)) \
      (not (match/eow str i ch start end matches))
}
define (match/bog str i ch start end matches) {
  and (lt i end) \
      (or (== i start)
	  (match/eog str (i - 1) ch start end matches))
}
define (match/eog str i ch start end matches) {
  and (gt i start) \
      (or (ge i end) {
	sci := string-cursor->index str i
	sce := string-cursor->index str end
	m := regexp-search re:grapheme str sci sce
	and m (le (regexp-match-submatch-end m 0) sci)
      })
}

define (lookup-char-set name flags) {
  cond ((flag-set? flags ~ascii?)
	(case name
	      ((any) char-set:full)
	      ((nonl) char-set:nonl)
	      ((lower-case lower)
	       (if (flag-set? flags ~ci?) %char-set:letter %char-set:lower-case))
	      ((upper-case upper)
	       (if (flag-set? flags ~ci?) %char-set:letter %char-set:upper-case))
	      ((title-case title)
	       (if (flag-set? flags ~ci?) %char-set:letter (char-set)))
	      ((alphabetic alpha) %char-set:letter)
	      ((numeric num digit) %char-set:digit)
	      ((alphanumeric alphanum alnum) %char-set:letter+digit)
	      ((punctuation punct) %char-set:punctuation)
	      ((symbol) %char-set:symbol)
	      ((graphic graph) %char-set:graphic)
	      ((word-constituent) %char-set:word-constituent)
	      ((whitespace white space) %char-set:whitespace)
	      ((printing print) %char-set:printing)
	      ((control cntrl) %char-set:iso-control)
	      ((hex-digit xdigit hex) char-set:hex-digit)
	      ((ascii) char-set:ascii)
	      (else #f))) \
       (else
	(case name
	      ((any) char-set:full)
	      ((nonl) char-set:nonl)
	      ((lower-case lower)
	       (if (flag-set? flags ~ci?) char-set:cased char-set:lower-case))
	      ((upper-case upper)
	       (if (flag-set? flags ~ci?) char-set:cased char-set:upper-case))
	      ((title-case title)
	       (if (flag-set? flags ~ci?) char-set:cased char-set:title-case))
	      ((alphabetic alpha) char-set:letter)
	      ((numeric num digit) char-set:digit)
	      ((alphanumeric alphanum alnum) char-set:letter+digit)
	      ((punctuation punct) char-set:punctuation)
	      ((symbol) char-set:symbol)
	      ((graphic graph) char-set:graphic)
	      ((word-constituent) char-set:word-constituent)
	      ((whitespace white space) char-set:whitespace)
	      ((printing print) char-set:printing)
	      ((control cntrl) char-set:control)
	      ((hex-digit xdigit hex) char-set:hex-digit)
	      ((ascii) char-set:ascii)
	      (else #f)))
}

define (sre-flatten-ranges orig-ls) {
  lp :+ function (ls res) {
	  cond ((null? ls)
		(reverse res)) \
	       ((string? (ph ls))
		(lp (append (string->list (ph ls)) (pt ls)) res)) \
	       ((null? (pt ls))
		(error 'sre-flatten-ranges "unbalanced cset / range" orig-ls)) \
	       ((string? (pht ls))
		(lp (pair (ph ls) (append (string->list (pht ls)) (ptt ls))) res)) \
	       (else
		(lp (ptt ls) (pair (pair (ph ls) (pht ls)) res)))
  }

  lp orig-ls #n
}

; any is from Chibi's lib/init-7.scm
define (any pred ls & lol) {
  define (any1 pred ls) {
    (if (pair? (pt ls))
        ((function (x) (if x x (any1 pred (pt ls)))) (pred (ph ls)))
        (pred (ph ls)))
  }
  define (anyn pred lol) {
    (if (every pair? lol)
        ((function (x) (if x x (anyn pred (map pt lol))))
         (apply pred (map ph lol)))
        #f)
  }
  if (null? lol) (if (pair? ls) (any1 pred ls) #f) (anyn pred (pair ls lol))
}

define (every pred ls) {
  or (null? ls) (and (pred (ph ls)) (every pred (pt ls)))
}

define (char-set-sre? sre) {
  or (unicode? sre) \
     (and (string? sre) (== 1 (string-length sre))) \
     (lookup-char-set sre ~none) \
     (and (pair? sre)
	  (or (string? (ph sre))
	      (memq (ph sre)
		    '(char-set / char-range \& \and ~ complement \- difference))
	      (and (memq (ph sre)
			 '(\| \or w/case w/nocase w/unicode w/ascii))
	       (every char-set-sre? (pt sre)))))
}

define (non-greedy-sre? sre) {
  and (pair? sre) \
      (or (memq (ph sre) '(?? *? **? non-greedy-optional
				     non-greedy-zero-or-more non-greedy-repeated))
       (and (memq (ph sre) '(: seq w/case w/nocase w/unicode w/ascii))
	    (non-greedy-sre? (ph (reverse sre))))
       (and (eq? (ph sre) 'or)
	    (any non-greedy-sre? (pt sre))))
}

define (valid-sre? x) {
  trap ^idio-error (function (c) #f) {
    regexp x
    #t
  }
}

define (sre->char-set sre & o) {
  flags := if (pair? o) (ph o) ~none
  define (->cs sre) (sre->char-set sre flags)
  define (maybe-ci sre) {
    if (flag-set? flags ~ci?) (char-set-ci sre) sre
  }
  cond ((lookup-char-set sre flags)) \
       ((char-set? sre) (maybe-ci sre)) \
       ((unicode? sre) (maybe-ci (char-set sre))) \
       ((string? sre)
	(if (== 1 (string-length sre))
	    (maybe-ci (string->char-set sre))
	    (error 'sre-char-set "only single char strings can be char-sets"))) \
       ((pair? sre)
	(if (string? (ph sre))
	    (maybe-ci (string->char-set (ph sre)))
	    (case (ph sre)
		  ((char-set) (if (null? (ptt sre))
				  (maybe-ci (string->char-set (pht sre)))
				  (error 'sre->char-set "(char-set) takes only one char-set" sre)))
		  ((/ char-range)
		   (->cs
		    #T{
		      or $@(map (function (x) (ucs-range->char-set
					       (unicode->integer (ph x))
					       (1 + (unicode->integer (pt x)))))
			    (sre-flatten-ranges (pt sre)))
		    }))
		  ((\& \and) (apply intersection-char-set (map ->cs (pt sre))))
		  ((\| \or) (apply union-char-set (map ->cs (pt sre))))
		  ((~ complement) (complement-char-set (->cs #T{ or $@(pt sre) })))
		  ((- difference) (difference-char-set (->cs (pht sre))
						       (->cs #T{ (or $@(ptt sre)) })))
		  ((w/case) (if (null? (ptt sre))
				(sre->char-set (pht sre) (flag-clear flags ~ci?))
				(error 'sre-char-set "w/case takes only one char-set" sre)))
		  ((w/nocase) (if (null? (ptt sre))
				  (sre->char-set (pht sre) (flag-join flags ~ci?))
				  (error 'sre-char-set "w/nocase takes only one char-set" sre)))
		  ((w/ascii) (if (null? (ptt sre))
				 (sre->char-set (pht sre) (flag-join flags ~ascii?))
				 (error 'sre-char-set "w/ascii takes only one char-set" sre)))
		  ((w/unicode) (if (null? (ptt sre))
				   (sre->char-set (pht sre) (flag-clear flags ~ascii?))
				   (error 'sre-char-set "w/unicode takes only one char-set" sre)))
		  (else (error 'sre-char-set "invalid sre char-set" sre))))) \
       (else (error 'sre-char-set "invalid sre char-set" sre))
}

define (char-set->sre cset) {
  list (char-set->string cset)
}

define (strip-submatches sre) {
  if (pair? sre) \
      (case (ph sre)
	    (($ submatch) (strip-submatches (pair ': (pt sre))))
	    ((-> => submatch-named) (strip-submatches (pair ': (ptt sre))))
	    (else (pair (strip-submatches (ph sre))
			(strip-submatches (pt sre))))) \
      sre
}

define (sre-expand-reps from to sre) {
  sre0 := strip-submatches sre
  lp :+ function (i res) {
	  if (== i from) \
	     (cond
	      ((not to)
	       (reverse (pair #T{ (* $sre) } res)))
	      ((== from to)
	       (reverse (pair sre (pt res))))
	      (else {
		lp :+ function (i res) {
			if (ge i to) \
			   (reverse (pair #T{ (? $sre) } res)) \
			   (lp (i + 1) (pair #T{ (? $sre0) } res))
		}

		lp (i + 1) res
	      })) \
	     (lp (i + 1) (pair sre0 res))
  }

  lp 0 '(:)
}

;;> Compile an \var{sre} into a regexp.

define (regexp sre & o) {
  current-index := 2
  current-match := 0
  current-id := 0
  match-names := #n
  match-rules := list (pair 0 1)
  non-greedy-indexes := #n
  define (next-id) {
    res := current-id
    current-id = current-id + 1
    res
  }
  define (make-submatch-state sre flags next index) {
    n3 := make-epsilon-state next (next-id)
    n2 := ->rx sre flags n3
    n1 := make-epsilon-state n2 (next-id)
    non-greedy? := non-greedy-sre? sre

    set-state-match! n1 index
    set-state-match-rule! n1 'left
    set-state-match! n3 (index + 1)
    set-state-match-rule! n3 (if non-greedy? 'non-greedy-left 'right)
    if non-greedy? {
      non-greedy-indexes = pair (index + 1) non-greedy-indexes
    }
    n1
  }
  define (->rx sre flags next) {
    ;; The base cases chars and strings match literally.
    cond ((unicode? sre)
	  (make-char-state sre flags next (next-id))) \
	 ((char-set? sre)
	  (make-char-state sre flags next (next-id))) \
	 ((string? sre)
	  (->rx (pair 'seq (string->list sre)) flags next)) \
	 ((and (symbol? sre) (lookup-char-set sre flags))
	  => (lambda (cset) (make-char-state cset ~none next (next-id)))) \
	 ((symbol? sre)
	  (case sre
		((epsilon) next)
		((bos) (make-char-state match/bos flags next (next-id)))
		((eos) (make-char-state match/eos flags next (next-id)))
		((bol) (make-char-state match/bol flags next (next-id)))
		((eol) (make-char-state match/eol flags next (next-id)))
		((bow) (make-char-state match/bow flags next (next-id)))
		((eow) (make-char-state match/eow flags next (next-id)))
		((nwb) (make-char-state match/nwb flags next (next-id)))
		((bog) (make-char-state match/bog flags next (next-id)))
		((eog) (make-char-state match/eog flags next (next-id)))
		((grapheme)
		 (->rx
		  #T{
		    (or
		     (: (* $char-set:hangul-l) (+ $char-set:hangul-v)
					       (* $char-set:hangul-t))
		     (: (* $char-set:hangul-l) $char-set:hangul-v
					       (* $char-set:hangul-v) (* $char-set:hangul-t))
		     (: (* $char-set:hangul-l) $char-set:hangul-lvt
					       (* $char-set:hangul-t))
		     (+ $char-set:hangul-l)
		     (+ $char-set:hangul-t)
		     (+ $char-set:regional-indicator)
		     (: "\r\n")
		     (: (~ control ("\r\n"))
			(* $char-set:extend-or-spacing-mark))
		     control)
		  }
		  flags
		  next))
		((word) (->rx '(word+ any) flags next))
		(else (error '->rx "unknown sre symbol" sre)))) \
	 ((pair? sre)
	  (case (ph sre)
		((seq :)
		 ;; Sequencing.  An empty sequence jumps directly to next,
		 ;; otherwise we join the first element to the sequence formed
		 ;; of the remaining elements followed by next.
		 (if (null? (pt sre))
		     next {
		       ;; Make a dummy intermediate to join the states so that
		       ;; we can generate n1 first, preserving the submatch order.
		       n2 := make-epsilon-state #f (next-id)
		       n1 := ->rx (pht sre) flags n2
		       n3 := ->rx (pair 'seq (ptt sre)) flags next

		       set-state-next1! n2 n3
		       n1
		     }))
		((or \|)
		 ;; Alternation.  An empty alternation always fails.
		 ;; Otherwise we fork between any of the alternations, each
		 ;; continuing to next.
		 (cond
		  ((null? (pt sre))
		   #f)
		  ((char-set-sre? sre)
		   (make-char-state (sre->char-set sre) flags next (next-id)))
		  ((null? (ptt sre))
		   (->rx (pht sre) flags next))
		  (else {
		    n1 := ->rx (pht sre) flags next
		    n2 := ->rx (pair 'or (ptt sre)) flags next


		    make-fork-state n1 n2 (next-id)
		  })))
		((? optional ?? non-greedy-optional)
		 ;; Optionality.  Either match the body or fork to the next
		 ;; state directly.
		 (make-fork-state (->rx (pair 'seq (pt sre)) flags next)
				  next (next-id)))
		((* zero-or-more *? non-greedy-zero-or-more)
		 ;; Repetition.  Introduce two fork states which can jump from
		 ;; the end of the loop to the beginning and from the
		 ;; beginning to the end (to skip the first iteration).
		 {
		   n2 := make-fork-state next #f (next-id)
		   n1 := make-fork-state (->rx (pair 'seq (pt sre)) flags n2) n2 (next-id)

		   set-state-next2! n2 n1
		   n1
		 })
		((+ one-or-more)
		 ;; One-or-more repetition.  Same as above but the first
		 ;; transition is required so the rx is simpler - we only
		 ;; need one fork from the end of the loop to the beginning.
		 {
		   n2 := make-fork-state next #f (next-id)
		   n1 := ->rx (pair 'seq (pt sre)) flags n2

		   set-state-next2! n2 n1
		   n1
		 })
		((= exactly)
		 ;; Exact repetition.
		 (->rx (sre-expand-reps (pht sre) (pht sre) (pair 'seq (ptt sre)))
		       flags next))
		((>= at-least)
		 ;; n-or-more repetition.
		 (->rx (sre-expand-reps (pht sre) #f (pair 'seq (ptt sre)))
		       flags next))
		((** repeated **? non-greedy-repeated)
		 ;; n-to-m repetition.
		 (->rx (sre-expand-reps (pht sre) (ph (ptt sre))
						  (pair 'seq (pt (ptt sre))))
		  flags next))
		((-> => submatch-named)
		 ;; Named submatches just record the name for the current
		 ;; match and rewrite as a non-named submatch.
		 (cond
		  ((flag-set? flags ~nocapture?)
		   (->rx (pair 'seq (ptt sre)) flags next))
		  (else
		   (set! match-names
			 (pair (pair (pht sre) (1 + current-match)) match-names))
		   (->rx (pair 'submatch (ptt sre)) flags next))))
		((*-> *=> submatch-named-list)
		 (cond
		  ((flag-set? flags ~nocapture?)
		   (->rx (pair 'seq (ptt sre)) flags next))
		  (else
		   (set! match-names (pair (pair (pht sre) current-match) match-names))
		   (->rx (pair 'submatch-list (ptt sre)) flags next))))
		(($ submatch)
		 ;; A submatch wraps next with an epsilon transition before
		 ;; next, setting the start and end index on the result and
		 ;; wrapped next respectively.
		 (cond
		  ((flag-set? flags ~nocapture?)
		   (->rx (pair 'seq (pt sre)) flags next))
		  (else {
		    num := current-match
		    index := current-index

		    current-match = current-match + 1
		    current-index = current-index + 2
		    match-rules = #T{ (($index & $(index + 1)) $@match-rules) }
		    make-submatch-state (pair 'seq (pt sre)) flags next index
		  })))
		((*$ submatch-list)
		 ;; A submatch-list wraps a range of submatch results into a
		 ;; single match value.
		 (cond
		  ((flag-set? flags ~nocapture?)
		   (->rx (pair 'seq (pt sre)) flags next))
		  (else {
		    num := current-match
		    index := current-index

		    current-match = current-match + 1
		    current-index = current-index + 1
		    match-rules = #T{ ($index $@match-rules) }

		    n2 := make-epsilon-state next (next-id)
		    n1 := ->rx (pair 'submatch (pt sre)) flags n2

		    set-state-match! n2 (list index num current-match)
		    set-state-match-rule! n2 'list
		    n1
		  })))
		((~ \- \& \/ complement difference \and char-range char-set)
		 (make-char-state (sre->char-set sre flags) ~none next (next-id)))
		((word)
		 (->rx #T{ (: bow $@(pt sre) eow) } flags next))
		((word+)
		 (->rx #T{ (word (+ $(if (equal? '(any) (pt sre))
				      'word-constituent
				      (intersection-char-set
				       char-set:word-constituent
				       (sre->char-set #T{ (or $@(pt sre)) } flags))))) }
		  flags
		  next))
		((w/case)
		 (->rx #T{ (: $@(pt sre)) } (flag-clear flags ~ci?) next))
		((w/nocase)
		 (->rx #T{ (: $@(pt sre)) } (flag-join flags ~ci?) next))
		((w/unicode)
		 (->rx #T{ (: $@(pt sre)) } (flag-clear flags ~ascii?) next))
		((w/ascii)
		 (->rx #T{ (: $@(pt sre)) } (flag-join flags ~ascii?) next))
		((w/nocapture)
		 (->rx #T{ (: $@(pt sre)) } (flag-join flags ~nocapture?) next))
		(else
		 (if (string? (ph sre))
		     (make-char-state (sre->char-set sre flags) ~none next (next-id))
		     (error '->rx "unknown sre pair" sre)))))
  }

  flags := parse-flags (and (pair? o) (ph o))

  if (regexp? sre) \
     sre {
       start := make-submatch-state sre flags (make-accept-state (next-id)) 0
       ;; (define (state->list st)
       ;;   (let ((seen (make-hash-table eq?))
       ;;         (count 0))
       ;;     (reverse
       ;;      (let lp ((st st) (res '()))
       ;;        (cond
       ;;         ((not (state? st)) res)
       ;;         ((hash-table-ref/default seen st #f) res)
       ;;         (else
       ;;          (hash-table-set! seen st count)
       ;;          (let ((orig-count count))
       ;;            (set! count (count + 1))
       ;;            (let* ((next1 (lp (state-next1 st) '()))
       ;;                   (next2 (lp (state-next2 st) '()))
       ;;                   (this (append
       ;;                          (list (state-id st) ;;orig-count
       ;;                                (cond
       ;;                                 ((epsilon-state? st)
       ;;                                  (if (state-chars st) '? '-))
       ;;                                 ((and (char-set? (state-chars st))
       ;;                                       (< (char-set-size (state-chars st)) 5))
       ;;                                  (char-set->string (state-chars st)))
       ;;                                 ((unicode? (state-chars st))
       ;;                                  (string (state-chars st)))
       ;;                                 (else '+))
       ;;                                (cond
       ;;                                 ((state-next1 st) => state-id)
       ;;                                 (else #f)))
       ;;                          (if (state-next2 st)
       ;;                              (list (state-id (state-next2 st)))
       ;;                              '())
       ;;                          (if (state-match st)
       ;;                              (list (list 'm (state-match st)))
       ;;                              '()))))
       ;;              (append next2 next1 (cons this res))))))))))
       ;;(for-each (lambda (x) (write x) (newline)) (state->list start))
       make-Rx start current-match current-index non-greedy-indexes (list->array (reverse match-rules)) match-names sre
     }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

;;> The fundamental regexp matching iterator.  Repeatedly searches
;;> \var{str} for the regexp \var{re} so long as a match can be found.
;;> On each successful match, applies \scheme{(\var{kons} \var{i}
;;> \var{regexp-match} \var{str} \var{acc})} where \var{i} is the
;;> index since the last match (beginning with
;;> \var{start}),\var{regexp-match} is the resulting match, and
;;> \var{acc} is the result of the previous \var{kons} application,
;;> beginning with \var{knil}.  When no more matches can be found,
;;> calls \var{finish} with the same arguments, except that
;;> \var{regexp-match} is \scheme{#f}.
;;>
;;> By default \var{finish} just returns \var{acc}.

define (regexp-fold rx kons knil str & o) {
  rx := regexp rx
  finish := if (pair? o) (ph o) (function (from md str acc) acc)
  o := if (pair? o) (pt o) o
  start := string-start-arg str o
  end := string-end-arg str (if (pair? o) (pt o) o)

  lp :+ function (i from acc) {
	  cond ((and (lt i end) (regexp-run-offsets #t rx str i end))
		=> (function (md) {
		      j := regexp-match-ref md 1

		      lp (if (and (== i j) (lt j end))
			     (string-cursor-next str j)
			     j) \
			 j \
			 (kons (string-cursor->index str from) md str acc)
		})) \
	       (else
		(finish (string-cursor->index str from) #f str acc))
  }

  lp start start knil
}

;;> Extracts all non-empty substrings of \var{str} which match
;;> \var{re} between \var{start} and \var{end} as a list of strings.

define (regexp-extract rx str & o) {
  apply regexp-fold \
	rx \
	(function (from md str a) {
	   s := regexp-match-submatch md 0

	   if (equal? s "") a (pair s a)
	}) \
	#n \
	str \
	(function (from md str a) (reverse a)) \
	o
}

;;> Splits \var{str} into a list of strings separated by matches of
;;> \var{re}.

define (regexp-split rx str & o) {
  ;; start and end in indices passed to regexp-fold
  start := if (pair? o) (ph o) 0
  end := if (and (pair? o) (pair? (pt o))) (pht o) (string-length str)

  regexp-fold rx \
	      (function (from md str a) {
		 i := regexp-match-submatch-start md 0
		 j := regexp-match-submatch-end md 0

		 if (eqv? i j) \
		    a \
		    (pair j (pair (substring str (ph a) i) (pt a)))
	      }) \
	      (pair start #n) \
	      str \
	      (function (from md str a)
		 (reverse (pair (substring str (ph a) end) (pt a)))) \
	      start \
	      end
}

;;> Partitions \var{str} into a list of non-empty strings
;;> matching \var{re}, interspersed with the unmatched portions
;;> of the string.  The first and every odd element is an unmatched
;;> substring, which will be the empty string if \var{re} matches
;;> at the beginning of the string or end of the previous match.  The
;;> second and every even element will be a substring matching
;;> \var{re}.  If the final match ends at the end of the string,
;;> no trailing empty string will be included.  Thus, in the
;;> degenerate case where \var{str} is the empty string, the
;;> result is \scheme{("")}.

define (regexp-partition rx str & o) {
  start := if (pair? o) (ph o) 0
  end := if (and (pair? o) (pair? (pt o))) (pht o) (string-length str)

  define (kons from md str a) {
    i := regexp-match-submatch-start md 0
    j := regexp-match-submatch-end md 0

    if (eqv? i j) \
       a {
	 left := substring str (ph a) i

	 pair j \
	      (pair (regexp-match-submatch md 0)
		    (pair left (pt a)))
       }
  }
  define (final from md str a) {
    if (or (lt from end) (null? (pt a))) \
       (pair (substring str (ph a) end) (pt a)) \
       (pt a)
  }

  reverse (regexp-fold rx kons (pair start #n) str final start end)
}

;;> Returns a new string replacing the \var{count}th match of \var{re}
;;> in \var{str} the \var{subst}, where the zero-indexed \var{count}
;;> defaults to zero (i.e. the first match).  If there are not
;;> \var{count} matches, returns the selected substring unmodified.

;;> \var{subst} can be a string, an integer or symbol indicating the
;;> contents of a numbered or named submatch of \var{re},\scheme{'pre}
;;> for the substring to the left of the match, or \scheme{'post} for
;;> the substring to the right of the match.

;;> The optional parameters \var{start} and \var{end} restrict both
;;> the matching and the substitution, to the given indices, such that
;;> the result is equivalent to omitting these parameters and
;;> replacing on \scheme{(substring str start end)}. As a convenience,
;;> a value of \scheme{#f} for \var{end} is equivalent to
;;> \scheme{(string-length str)}.

define (regexp-replace rx str subst & o) {
  start := if (and (pair? o) (ph o)) (ph o) 0
  o := if (pair? o) (pt o) #n
  end := if (and (pair? o) (ph o)) (ph o) (string-length str)
  o := if (pair? o) (pt o) #n
  count := if (pair? o) (ph o) 0

  lp :+ function (i count) {
	  m := regexp-search rx str i end

	  cond ((not m) str) \
	       ((positive? count)
		(lp (regexp-match-submatch-end m 0) (count - 1))) \
	       (else
		(concatenate-string
		 (pair
		  (substring str start (regexp-match-submatch-start m 0))
		  (append
		   (reverse (regexp-apply-match m str subst start end))
		   (list (substring str (regexp-match-submatch-end m 0) end))))))
  }

  lp start count
}

;;> Equivalent to \var{regexp-replace}, but replaces all occurrences
;;> of \var{re} in \var{str}.

define (regexp-replace-all rx str subst & o) {
  start := if (and (pair? o) (ph o)) (ph o) 0
  o := if (pair? o) (pt o) #n
  end := if (and (pair? o) (ph o)) (ph o) (string-length str)

  regexp-fold rx \
	      (function (i m str acc) {
		 m-start := regexp-match-submatch-start m 0

		 append (regexp-apply-match m str subst start end) \
			(if (ge i m-start)
			    acc
			    (pair (substring str i m-start) acc))
	      }) \
	      #n \
	      str \
	      (function (i m str acc) {
		 end := string-length str

		 concatenate-string (reverse (if (ge i end)
						 acc
						 (pair (substring str i end) acc)))
	      }) \
	      start end
}

define (regexp-apply-match m str ls start end) {
  lp :+ function (ls res) {
	  cond ((null? ls)
		res) \
	       ((not (pair? ls))
		(lp (list ls) res)) \
	       ((integer? (ph ls))
		(lp (pt ls) (pair (or (regexp-match-submatch m (ph ls)) "") res))) \
	       ((function? (ph ls))
		(lp (pt ls) (pair ((ph ls) m) res))) \
	       ((symbol? (ph ls))
		(case (ph ls)
		      ((pre)
		       (lp (pt ls)
			   (pair (substring str start (regexp-match-submatch-start m 0))
				 res)))
		      ((post)
		       (lp (pt ls)
			   (pair (substring str (regexp-match-submatch-end m 0) end)
				 res)))
		      (else
		       (cond
			((assq (ph ls) (regexp-match-names m))
			 => (lambda (x) (lp (pair (pt x) (pt ls)) res)))
			(else
			 (error 'regexp-apply-match "unknown match replacement" (ph ls))))))) \
	       (else
		(lp (pt ls) (pair (ph ls) res)))
  }

  lp ls #n
}

; chibi defines a number of utility functions in the .sld
define (string-start-arg s o) {
  if (pair? o) (string-index->cursor s (ph o)) (string-cursor-start s)
}
define (string-end-arg s o) {
  if (pair? o) (string-index->cursor s (ph o)) (string-cursor-end s)
}
define (string-cursor-next s i) (+ i 1)
define (string-cursor-prev s i) (- i 1)
define (string-cursor->index str off) off
define (string-index->cursor str i) i

; and
define (string-cursor-start s) 0
define (string-cursor-end s) (string-length s)

define re:grapheme (regexp 'grapheme)

(provide 'SRFI-115)
