#*

Copyright (c) 2020, 2021 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SRFI-115.idio

A port of SRFI-115 Scheme Regular Expressions.  In particular
https://github.com/ashinn/chibi-scheme/blob/master/lib/chibi/regexp.scm.

*#

module SRFI-115
export (regexp regexp? valid-sre? rx regexp->sre char-set->sre
	regexp-matches regexp-matches? regexp-search
	regexp-replace regexp-replace-all
	regexp-fold regexp-extract regexp-split regexp-partition
	regexp-match? regexp-match-count
	regexp-match-submatch regexp-match-submatch/list
	regexp-match-submatch-start regexp-match-submatch-end
	regexp-match->list regexp-match->sexp)

import SRFI-14
import unicode

; chibi defines a number of utility functions in the .sld
define (string-cursor-start s) 0
define (string-cursor-end s) (string-length s)
define (string-cursor->index str off) off
define (string-index->cursor str i) i
define (string-start-arg s o) {
  if (pair? o) (string-index->cursor s (ph o)) (string-cursor-start s)
}
define (string-end-arg s o) {
  if (pair? o) (string-index->cursor s (ph o)) (string-cursor-end s)
}
define (string-cursor-next s i) (+ i 1)
define (string-cursor-prev s i) (- i 1)

;; regexp.scm -- simple non-bactracking NFA implementation
;; Copyright (c) 2013-2016 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;; An rx represents a start state and meta-info such as the number
;;; and names of submatches.
define-struct Rx start-state num-matches num-save-indexes non-greedy-indexes match-rules match-names sre
define regexp? Rx?
define regexp->sre Rx-sre

define (Rx-as-string rx seen-rxs) {
  if (Rx? rx) {
    r := (open-output-string)
    hprintf r "#<SI Rx"
    hprintf r " ss=%s" (state-as-string (Rx-start-state rx) #n)
    hprintf r " n-m=%d" (Rx-num-matches rx)
    hprintf r " n-si=%d" (Rx-num-save-indexes rx)
    hprintf r " n-gi=%s" (Rx-non-greedy-indexes rx)
    hprintf r " m-r=%s" (Rx-match-rules rx)
    hprintf r " m-n=%s" (Rx-match-names rx)
    hprintf r " sre=%s" (Rx-sre rx)
    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string Rx Rx-as-string

;; Syntactic sugar.
define-syntax rx (syntax-rules ()
  ((rx sre ...)
   (regexp #T{ (: sre ...) })))

;;; A state is a single nfa state with transition rules.
define-struct state accept? chars match match-rule next1 next2 id

define (state-as-string st seen-ids) {
  if (state? st) {
    r := (open-output-string)
    hprintf r "#<SI state "
    seen := assq (state-id st) seen-ids
    if seen {
      hprintf r "@%d" (ph seen)
    } {
      seen-ids = pair (list (state-id st)) seen-ids
      hprintf r "id=%2d ch=%2s a?=%s sm=%2d" (state-id st) (state-chars st) (state-accept? st) (state-match st)
      if (state-next1 st) {
	seen = assq (state-id (state-next1 st)) seen-ids
	if seen {
	  hprintf r " n1=@%d" (ph seen)
	} {
	  hprintf r " n1=%s" (state-as-string (state-next1 st) seen-ids)
	}
      } {
	hprintf r " n1=%s" (state-next1 st)
      }
      if (state-next2 st) {
	seen = assq (state-id (state-next2 st)) seen-ids
	if seen {
	  hprintf r " n2=@%d" (ph seen)
	} {
	  hprintf r " n2=%s" (state-as-string (state-next2 st) seen-ids)
	}
      } {
	hprintf r " n2=%s" (state-next2 st)
      }
    }
    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string state state-as-string

make-state = {
  orig-make-state := make-state

  function (accept? chars match match-rule next1 next2 id) {
    if (and next1 (not (state? next1))) (error/type ^rt-parameter-type-error 'make-state "expected next1 to be a state" next1)
    if (and next2 (not (state? next2))) (error/type ^rt-parameter-type-error 'make-state "expected next2 to be a state" next2)
    orig-make-state accept? chars match match-rule next1 next2 id
  }
}

~none		:= #B{ 3 }
~ci?		:= #B{ 3 1 }
~ascii?		:= #B{ 3 01 }
~nocapture?	:= #B{ 3 001 }

define (flag-set? flags i)	(equal-bitset? i (and-bitset flags i))
define (flag-join a b)		(ior-bitset a b)
define (flag-clear a b)		(and-bitset a (not-bitset b))

define (char-set-ci cset) {
  cased := (char-set)
  char-set-for-each-set cset (function (ch) {
    uc := integer->unicode ch
    (cond
     ((Lowercase? uc) {
       char-set-set! cased (->Uppercase uc)
     })
     ((Uppercase? uc) {
       char-set-set! cased (->Lowercase uc)
     }))
  })
  ior-char-set cset cased
}

define (make-char-state ch flags next id) {
  if (flag-set? flags ~ci?) {
    cset := (cond
	     ((unicode? ch) (char-set-ci (char-set ch)))
	     ((char-set? ch) (char-set-ci ch))
	     (else ch))
    make-state #f cset #f #f next #f id
  } {
    make-state #f ch #f #f next #f id
  }
}
define (make-fork-state next1 next2 id) {
  make-state #f #f #f #f next1 next2 id
}
define (make-epsilon-state next id) {
  make-fork-state next #f id
}
define (make-accept-state id) {
  make-state #t #f #f #f #f #f id
}

;; A record holding the current match data - essentially a wrapper
;; around an array, plus a reference to the RX for meta-info.
define-struct regexp-match matches rx string

define (regexp-match-as-string rm seen-rms & o) {
  if (regexp-match? rm) {
    r := (open-output-string)
    hprintf r "#<SI regexp-match "
    if (not (null? o)) {
      hprintf r (ph o)
    }
    rx := regexp-match-rx rm
    hprintf r "ms=%-16s ss=%s ngi=%s" (regexp-match-matches rm) (state-as-string (Rx-start-state rx) #n) (Rx-non-greedy-indexes rx)
    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string regexp-match regexp-match-as-string

define (regexp-match-rules md) {
  Rx-match-rules (regexp-match-rx md)
}
define (regexp-match-names md) {
  Rx-match-names (regexp-match-rx md)
}
define (make-regexp-match+ len rx str) {
  make-regexp-match (make-array len #f) rx str
}
define (make-regexp-match-for-rx rx str) {
  make-regexp-match+ (Rx-num-save-indexes rx) rx str
}
define (regexp-match-count md) "

Returns the number of submatches of `regexp-match`, regardless of
whether they matched or not.  Does not include the implicit zero full
match in the count.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:return: number of submatches
:rtype: integer

" {
  (quotient (array-length (regexp-match-matches md)) 2) - 1
}

define (regexp-match-name-offset md name) {
  loop :+ function (ls first) {
    (cond
     ((null? ls) (or first (error/type ^rt-parameter-value-error 'regexp-match-name-offset "unknown match name" md name)))
     ((eq? name (phh ls))
      (if (regexp-match-submatch-start+end md (pth ls))
       (pth ls)
       (loop (pt ls) (or first (pth ls)))))
     (else (loop (pt ls) first)))
  }

  loop (regexp-match-names md) #f
}

define (regexp-match-ref md n) {
  (array-ref (regexp-match-matches md)
	     (if (integer? n)
	      n
	      (regexp-match-name-offset md n)))
}

define (regexp-match-set! md n val) {
  array-set! (regexp-match-matches md) n val
}

define (copy-regexp-match md) {
  src := regexp-match-matches md
  len := array-length src
  dst := make-array len #f

  (do ((i 0 (i + 1)))
   ((i eq len)
    (make-regexp-match dst (regexp-match-rx md) (regexp-match-string md))) {
    array-set! dst i (array-ref src i)
  })
}

;;> Returns the matching result for the given named or indexed
;;> submatch \var{n}, possibly as a list for a submatch-list, or
;;> \scheme{#f} if not matched.

define (regexp-match-submatch/list md n) "

As per :ref:`regexp-match-submatch <SRFI-115/regexp-match-submatch>`
except returns the full list of matches, if any.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:param field: field identifier
:type field: integer or symbol
:return: submatches or ``#f``
:rtype: list or ``#f``

" {
  n := if (integer? n) n (regexp-match-name-offset md n)

  (cond
   ((n ge (array-length (regexp-match-rules md)))
    #f)
   (else {
     rule := array-ref (regexp-match-rules md) n

     (cond
      ((pair? rule) {
	start := regexp-match-ref md (ph rule)
	end := regexp-match-ref md (pt rule)
	str := regexp-match-string md

	and start end (substring str start end)
      })
      (else {
	res := regexp-match-ref md rule

	if (pair? res) (reverse res) res
      }))
   }))
}

;;> Returns the matching substring for the given named or indexed
;;> submatch \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch md n) "

Returns the substring matched in `regexp-match` corresponding to
`field`, either an integer or a symbol for a named submatch.  Index 0
refers to the entire match, index 1 to the first lexicographic
submatch, and so on.  If there are multiple submatches with the same
name, the first which matched is returned.  If passed an integer
outside the range of matches, or a symbol which does not correspond to
a named submatch of the pattern, it is an error.  If the corresponding
submatch did not match, returns false.

The result of extracting a submatch after the original matched string
has been mutated is unspecified.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:param field: field identifier
:type field: integer or symbol
:return: submatch string or ``#f``
:rtype: string or ``#f``

" {
  res := regexp-match-submatch/list md n

  if (pair? res) (ph res) res
}

define (regexp-match-submatch-start+end md n) {
  n := if (integer? n) n (regexp-match-name-offset md n)

  and (n lt (array-length (regexp-match-rules md))) {
    rule := array-ref (regexp-match-rules md) n
    if (pair? rule) {
      start := regexp-match-ref md (ph rule)
      end := regexp-match-ref md (pt rule)
      str := regexp-match-string md
      and start end (pair start end)
    } #f
  }
}

;;> Returns the start index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch-start md n) "

Returns the start index for `regexp-match` corresponding to `field` as
per :ref:`regexp-match-submatch <SRFI-115/regexp-match-submatch>`.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:param field: field identifier
:type field: integer or symbol
:return: submatch starting index
:rtype: integer

" {
  (cond
   ((regexp-match-submatch-start+end md n) => ph)
   (else #f))
}

;;> Returns the end index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

define (regexp-match-submatch-end md n) "

Returns the end index for `regexp-match` corresponding to `field` as
per :ref:`regexp-match-submatch <SRFI-115/regexp-match-submatch>`.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:param field: field identifier
:type field: integer or symbol
:return: submatch ending index
:rtype: integer

" {
  (cond
   ((regexp-match-submatch-start+end md n) => pt)
   (else #f))
}

define (regexp-match-convert recurse? md str) {
  (cond
   ((array? md) {
     loop :+ function (i res) {
       (cond
	((i ge (array-length md))
	 (reverse res))
	((integer? (array-ref md i))
	 (loop (i + 2)
	       (pair (substring str (array-ref md i)
				    (array-ref md (i + 1)))
		res)))
	(else
	 (loop (i + 1)
	       (pair (regexp-match-convert recurse? (array-ref md i) str)
		     res))))
     }

     loop 0 #n
   })
   ((list? md)
    (if recurse?
     (map (function (x) (regexp-match-convert recurse? x str)) (reverse md))
     (regexp-match-convert recurse? (ph md) str)))
   ((and (pair? md) (integer? (ph md)) (integer? (pt md)))
    (substring str (ph md) (pt md)))
   ((regexp-match? md)
    (regexp-match-convert
     recurse? (regexp-match-matches md) (regexp-match-string md)))
   (else
    md))
}

;;> Convert an regexp-match result to a list of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

define (regexp-match->list md) "

Returns a list of all submatches in `regexp-match` as string or false,
beginning with the entire match 0.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:return: list of submatches
:rtype: list

" {
  regexp-match-convert #f md #f
}

;;> Convert an regexp-match result to a forest of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

define (regexp-match->sexp md) "

Convert `regexp-match` to a forest of submatches, beginning with the
full match, using ``#f`` for unmatched submatches.

:param regexp-match: regexp-match
:type regexp-match: struct-instance
:return: sexp
:rtype: list

" {
  regexp-match-convert #t md #f
}

;; Collect results from a list match.
define (match-collect md spec) {
  define (match-extract md n) {
    vec := regexp-match-matches md
    rules := regexp-match-rules md
    n-rule := array-ref rules n
    rule := array-ref rules n-rule

    if (pair? rule) {
      start := regexp-match-ref md (ph rule)
      end := regexp-match-ref md (pt rule)
      and start end (pair start end)
    } (regexp-match-ref md rule)
  }

  end := pht spec
  vec := regexp-match-matches md
  loop :+ function (i ls) {
    (if (i ge end)
     (reverse ls)
     (loop (i + 1) (pair (match-extract md i) ls)))
  }

  loop (1 + (ph spec)) #n
}

;; A searcher represents a single rx state and match information.
define-struct searcher state matches

define (searcher-as-string sr seen-searchers & o) {
  if (searcher? sr) {
    r := (open-output-string)
    hprintf r "#<SI searcher "
    if (not (null? o)) {
      hprintf r (ph o)
    }
    hprintf r "st=<%s>" (state-as-string (searcher-state sr) #n)
    hprintf r " ms=<%s>" (regexp-match-as-string (searcher-matches sr) #n)
    hprintf r ">"
    get-output-string r
  } #n
}

add-as-string searcher searcher-as-string

;; Merge two regexp-matches, preferring the leftmost-longest of their
;; matches, or shortest for non-greedy matches.
define (regexp-match>=? m1 m2) {
  non-greedy-indexes := Rx-non-greedy-indexes (regexp-match-rx m1)
  end := (array-length (regexp-match-matches m1)) - 1

  loop :+ function (i) {
    (cond
     ((i ge end)
      #t)
     ((and (eqv? (regexp-match-ref m1 i)
		 (regexp-match-ref m2 i))
       (eqv? (regexp-match-ref m1 (i + 1))
	     (regexp-match-ref m2 (i + 1))))
       (loop (i + 2)))
     (else
      (not
       (and (integer? (regexp-match-ref m2 i))
	    (or (not (integer? (regexp-match-ref m1 i)))
		((regexp-match-ref m2 i) lt (regexp-match-ref m1 i))
		;; sanity check for incompletely advanced epsilons
		(and (integer? (regexp-match-ref m1 (i + 1)))
		     ((regexp-match-ref m1 (i + 1)) lt (regexp-match-ref m1 i)))
		((if (memq (i + 1) non-greedy-indexes) not/function values)
		 (and
		  ((regexp-match-ref m2 i) eq (regexp-match-ref m1 i))
		  (or (not (integer? (regexp-match-ref m2 (i + 1))))
		      (and (integer? (regexp-match-ref m1 (i + 1)))
			   ((regexp-match-ref m2 (i + 1)) gt (regexp-match-ref m1 (i + 1))))))))))))
  }

  loop 0
}

define (regexp-match-max m1 m2) {
  if (regexp-match>=? m1 m2) m1 m2
}

;; Merge match data from sr2 into sr1, preferring the leftmost-longest
;; match in the event of a conflict.
define (searcher-merge! sr1 sr2) {
  m := regexp-match-max (searcher-matches sr1) (searcher-matches sr2)
  if (not (eq? m (searcher-matches sr1))) {
    set-searcher-matches! sr1 (copy-regexp-match m)
  }
}

define (searcher-max sr1 sr2) {
  (if (or (not (searcher? sr2))
	  (regexp-match>=? (searcher-matches sr1) (searcher-matches sr2)))
   sr1
   sr2)
}

define (searcher-start-match sr) {
  regexp-match-ref (searcher-matches sr) 0
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A posse is a group of searchers.

define (make-posse & o) {
  make-hash 'eq?
}

define posse? hash?
define (posse-empty? posse) (zero? (hash-size posse))

define (posse-ref posse sr) {
  hash-ref posse (searcher-state sr) #f
}
define (posse-add! posse sr) {
  hash-set! posse (searcher-state sr) sr
}
define (posse-clear! posse) {
  hash-walk posse (function (key val) (hash-delete! posse key))
}
define (posse-for-each proc posse) {
  #*
  skeys := sort (hash-keys posse) (function (a b) {
    lt a.id b.id
  })
  for-each (function (key) {
    val := hash-ref posse key
    proc val
  }) skeys
  *#
  hash-walk posse (function (key val) (proc val))
}
define (posse-every pred posse) {
  fold-hash posse (function (key val acc) (and acc (pred val))) #t
}

define (posse->list posse) {
  hash-values posse
}
define (list->posse ls) {
  searchers := (make-posse)
  for-each (function (sr) (posse-add! searchers sr)) ls
  searchers
}
define (posse & args) {
  list->posse args
}

define (make-start-searcher rx str) {
  make-searcher (Rx-start-state rx) (make-regexp-match-for-rx rx str)
}

define (psrs srs & o) {
  r := (open-output-string)
  skeys := sort (hash-keys srs) (function (a b) {
    lt (state-id a) (state-id b)
  })
  for-each (function (k) {
    v := hash-ref srs k
    if (not (null? o)) {
      hprintf r (ph o)
    }
    hprintf r "st=<%s>" (state-as-string k)
    hprintf r " v.m=<%s>;" (regexp-match-as-string (regexp-match v))
  }) skeys
  get-output-string r
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Execution

;; A transition which doesn't advance the index.

define (epsilon-state? st) {
  (or (not (state-chars st))
      (function? (state-chars st)))
}

;; Match the state against a char and index.

define (state-matches? st str i ch start end matches) {
  matcher := state-chars st
  (cond
   ((unicode? matcher)
    (eqv? matcher ch))
   ((char-set? matcher)
    (char-set-contains? matcher ch))
   ((pair? matcher)
    (and (char<=? (ph matcher) ch) (char<=? ch (pt matcher))))
   ((function? matcher)
    (matcher str i ch start end matches))
   ((not matcher))
   (else
    (error/type ^rt-parameter-type-error 'state-matches? "unknown state matcher" (state-chars st))))
}

;; Advance epsilons together - if the State is newly added to the
;; group and is an epsilon state, recursively add the transition.

define (posse-advance! new seen accept sr str i start end) {
  advance! :+ function (sr) {
    st := searcher-state sr
    ;; Update match data.
    (cond
     ((state-match st) {
       index := state-match st
       matches := searcher-matches sr
       before := copy-regexp-match matches
       (cond
	((pair? index) {
	  ;; Submatch list, accumulate and push.
	  prev := regexp-match-ref matches (ph index)
	  new := (pair (match-collect matches (pt index))
		       (if (pair? prev) prev #n))
	  regexp-match-set! matches (ph index) new
	})
	((not (and (eq? 'non-greedy-left (state-match-rule st))
		   (regexp-match-ref matches index)
		   ((regexp-match-ref matches index) ge (regexp-match-ref matches (index - 1)))))
	  (regexp-match-set! matches index i)))
     }))
    ;; Follow transitions.
    (cond
     ((state-accept? st)
      (set-pt! accept (searcher-max sr (pt accept))))
     ((posse-ref seen sr)
      => (function (sr-prev) (searcher-merge! sr-prev sr)))
     ((epsilon-state? st) {
       ch := and (i lt end) (string-ref str i)
       (cond
	((state-matches? st str i ch start end (searcher-matches sr)) {
	  posse-add! seen sr
	  next1 := state-next1 st
	  next2 := state-next2 st
	  matches := and next2 (searcher-matches sr)
	  (cond
	   (next1 {
	     set-searcher-state! sr next1
	     advance! (make-searcher next1 (copy-regexp-match (searcher-matches sr)))
	   }))
	  (cond
	   (next2 {
	     sr2 := make-searcher next2 (copy-regexp-match matches)
	     advance! sr2
	   }))
	}))
     })
     ((posse-ref new sr) ; Non-special, non-epsilon searcher, add to posse.
      ;; Merge regexp-match for existing searcher.
      => (function (sr-prev) (searcher-merge! sr-prev sr)))
     (else
      ;; Add new searcher.
      (posse-add! new sr)))
  }

  advance! sr
}

;; Run so long as there is more to match.

define (regexp-run-offsets search? rx str start end) {
  rx := regexp rx
  epsilons := (posse)
  accept := list #f

  loop :+ function (i searchers1 searchers2) {
    ;; Advance initial epsilons once from the first index, or every
    ;; time when searching.
    (cond
     ((or search? (i eq start)) {
       posse-advance! searchers1 epsilons accept (make-start-searcher rx str) \
						 str i start end
       posse-clear! epsilons
     }))
    (cond
     ((or (i ge end)
	  (and search?
	       (searcher? (pt accept)) {
		 accept-start := searcher-start-match (pt accept)
		 posse-every (function (searcher)
		  ((searcher-start-match searcher) gt accept-start)) \
			     searchers1
	  })
	  (and (not search?)
	       (posse-empty? searchers1)))
       ;; Terminate when the string is done or there are no more
       ;; searchers.  If we terminate prematurely and are not
       ;; searching, return false.
       (and (searcher? (pt accept)) {
	 matches := searcher-matches (pt accept)
	 (and (or search? ((regexp-match-ref matches 1) ge end))
	      (searcher-matches (pt accept)))
       }))
     (else {
       ;; Otherwise advance normally.
       ch := string-ref str i
       i2 := i + 1
       ;; NOTE: non-deterministic from hash order
       posse-for-each (function (sr)
	(cond
	 ((state-matches? (searcher-state sr)
			  str i ch
			  start end (searcher-matches sr)) {
	   set-searcher-state! sr (state-next1 (searcher-state sr))
	   ;; Epsilons are considered at the next position.
	   posse-advance! searchers2 epsilons accept sr str i2 start end
	   posse-clear! epsilons
	 }))) \
		      searchers1
       posse-clear! searchers1
       loop i2 searchers2 searchers1
     }))
  }

  loop start (posse) (posse)
}

;; Wrapper to determine start and end offsets.

define (regexp-run search? rx str & o) {
  start := string-start-arg str o
  end := string-end-arg str (if (pair? o) (pt o) o)

  regexp-run-offsets search? rx str start end
}

;;> Match the given regexp or SRE against the entire string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

define (regexp-matches rx str & o) "

Returns an regexp-match object if `re` successfully matches the entire
string `str` from `start` (inclusive) to `end` (exclusive), or ``#f``
if the match fails.  The regexp-match object will contain information
needed to extract any submatches.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer, optional
:return: regexp-match object
:rtype: struct-instance

" {
  apply regexp-run #f rx str o
}

;;> Match the given regexp or SRE against the entire string and return
;;> the \scheme{#t} on success.  Returns \scheme{#f} on failure.

define (regexp-matches? rx str & o) "

Returns ``#t`` if `re` matches `str` as in :ref:`regexp-matches
<SRFI-115/regexp-matches>`, or ``#f`` otherwise.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:return: boolean

" {
  and (apply regexp-matches rx str o) #t
}

;;> Search for the given regexp or SRE within string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

define (regexp-search rx str & o) "

Returns an regexp-match object if `re` successfully matches a
substring of `str` from `start` (inclusive) to `end` (exclusive), or
``#f`` if the match fails.  The regexp-match object will contain
information needed to extract any submatches.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer, optional
:return: regexp-match object
:rtype: struct-instance

" {
  apply regexp-run #t rx str o
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiling

define (parse-flags ls) {
  define (symbol->flag s) {
    case s ((i ci case-insensitive) ~ci?) (else ~none)
  }
  loop :+ function (ls res) {
    (if (not (pair? ls))
     res
     (loop (pt ls) (flag-join res (symbol->flag (ph ls)))))
  }

  loop ls ~none
}

; SRFI-14.idio (actually, usi-wrap.c) defines:
; char-set:nonl
; char-set:control
; char-set:word-constituent
; %char-set:word-constituent
; char-set:cased rather than (get-char-set:cased)
define (char-word-constituent? ch) {
  char-set-contains? char-set:word-constituent ch
}

define (match/bos str i ch start end matches) {
  i eq start
}
define (match/eos str i ch start end matches) {
  i ge end
}
define (match/bol str i ch start end matches) {
  (or (i eq start)
      (eqv? #\{newline} (string-ref str (i - 1))))
}
define (match/eol str i ch start end matches) {
  (or (i ge end)
      (eqv? #\{newline} (string-ref str i)))
}
define (match/bow str i ch start end matches) {
  (and (i lt end)
       (or (i eq start)
	   (not (char-word-constituent?
		 (string-ref str (i - 1)))))
       (char-word-constituent? ch))
}
define (match/eow str i ch start end matches) {
  (and (or (i ge end)
	   (not (char-word-constituent? ch)))
   (i gt start)
   (char-word-constituent?
    (string-ref str (i - 1))))
}
define (match/nwb str i ch start end matches) {
  (and (not (match/bow str i ch start end matches))
       (not (match/eow str i ch start end matches)))
}
define (match/bog str i ch start end matches) {
  (and (i lt end)
       (or (i eq start)
	   (match/eog str (i - 1) ch start end matches)))
}
define (match/eog str i ch start end matches) {
  (and (i gt start)
       (or (i ge end) {
	 sci := string-cursor->index str i
	 sce := string-cursor->index str end
	 m := regexp-search re:grapheme str sci sce
	 and m ((regexp-match-submatch-end m 0) le sci)
       }))
}

define (lookup-char-set name flags) {
  (cond
   ((flag-set? flags ~ascii?)
    (case name
     ((any) char-set:full)
     ((nonl) char-set:nonl)
     ((lower-case lower)
      (if (flag-set? flags ~ci?) %char-set:letter %char-set:lower-case))
     ((upper-case upper)
      (if (flag-set? flags ~ci?) %char-set:letter %char-set:upper-case))
     ((title-case title)
      (if (flag-set? flags ~ci?) %char-set:letter (char-set)))
     ((alphabetic alpha) %char-set:letter)
     ((numeric num digit) %char-set:digit)
     ((alphanumeric alphanum alnum) %char-set:letter+digit)
     ((punctuation punct) %char-set:punctuation)
     ((symbol) %char-set:symbol)
     ((graphic graph) %char-set:graphic)
     ((word-constituent) %char-set:word-constituent)
     ((whitespace white space) %char-set:whitespace)
     ((printing print) %char-set:printing)
     ((control cntrl) %char-set:iso-control)
     ((hex-digit xdigit hex) char-set:hex-digit)
     ((ascii) char-set:ascii)
     (else #f)))
   (else
    (case name
     ((any) char-set:full)
     ((nonl) char-set:nonl)
     ((lower-case lower)
      (if (flag-set? flags ~ci?) char-set:cased char-set:lower-case))
     ((upper-case upper)
      (if (flag-set? flags ~ci?) char-set:cased char-set:upper-case))
     ((title-case title)
      (if (flag-set? flags ~ci?) char-set:cased char-set:title-case))
     ((alphabetic alpha) char-set:letter)
     ((numeric num digit) char-set:digit)
     ((alphanumeric alphanum alnum) char-set:letter+digit)
     ((punctuation punct) char-set:punctuation)
     ((symbol) char-set:symbol)
     ((graphic graph) char-set:graphic)
     ((word-constituent) char-set:word-constituent)
     ((whitespace white space) char-set:whitespace)
     ((printing print) char-set:printing)
     ((control cntrl) char-set:control)
     ((hex-digit xdigit hex) char-set:hex-digit)
     ((ascii) char-set:ascii)
     (else #f))))
}

define (sre-flatten-ranges orig-ls) {
  loop :+ function (ls res) {
    (cond
     ((null? ls)
      (reverse res))
     ((string? (ph ls))
      (loop (append (string->list (ph ls)) (pt ls)) res))
     ((null? (pt ls))
      (error/type ^rt-parameter-value-error 'sre-flatten-ranges "unbalanced cset / range" orig-ls))
     ((string? (pht ls))
      (loop (pair (ph ls) (append (string->list (pht ls)) (ptt ls))) res))
     (else
      (loop (ptt ls) (pair (pair (ph ls) (pht ls)) res))))
  }

  loop orig-ls #n
}

define (every pred ls) {
  (or (null? ls)
      (and (pred (ph ls))
	   (every pred (pt ls))))
}

; any is from Chibi's lib/init-7.scm
define (any pred ls & lol) {
  define (any1 pred ls) {
    (if (pair? (pt ls))
     ((function (x) (if x x (any1 pred (pt ls)))) (pred (ph ls)))
     (pred (ph ls)))
  }
  define (anyn pred lol) {
    (if (every pair? lol)
     ((function (x) (if x x (anyn pred (map pt lol))))
      (apply pred (map ph lol)))
     #f)
  }
  if (null? lol) (if (pair? ls) (any1 pred ls) #f) (anyn pred (pair ls lol))
}

define (char-set-sre? sre) {
  (or (unicode? sre)
      (and (string? sre) (1 eq (string-length sre)))
      (lookup-char-set sre ~none)
      (and (pair? sre)
	   (or (string? (ph sre))
	       (memq (ph sre)
		     '(char-set / char-range \& \and ~ complement \- difference))
	       (and (memq (ph sre)
			  '(\| \or w/case w/nocase w/unicode w/ascii))
		(every char-set-sre? (pt sre))))))
}

define (non-greedy-sre? sre) {
  (and (pair? sre)
       (or (memq (ph sre) '(?? *? **? non-greedy-optional
				      non-greedy-zero-or-more non-greedy-repeated))
	(and (memq (ph sre) '(: seq w/case w/nocase w/unicode w/ascii))
	     (non-greedy-sre? (ph (reverse sre))))
	(and (eq? (ph sre) 'or)
	     (any non-greedy-sre? (pt sre)))))
}

define (valid-sre? x) "
Is `x` a valid SRE?

:param x: value to test
:type x: any
:return: boolean
" {
  trap ^idio-error (function (c) #f) {
    regexp x
    #t
  }
}

define (sre->char-set sre & o) {
  flags := if (pair? o) (ph o) ~none
  define (->cs sre) (sre->char-set sre flags)
  define (maybe-ci sre) {
    if (flag-set? flags ~ci?) (char-set-ci sre) sre
  }
  (cond
   ((lookup-char-set sre flags))
   ((char-set? sre) (maybe-ci sre))
   ((unicode? sre) (maybe-ci (char-set sre)))
   ((string? sre)
    (if (1 eq (string-length sre))
     (maybe-ci (string->char-set sre))
     (error/type ^rt-parameter-value-error 'sre-char-set "only single char strings can be char-sets")))
   ((pair? sre)
    (if (string? (ph sre))
     (maybe-ci (string->char-set (ph sre)))
     (case (ph sre)
      ((char-set) (if (null? (ptt sre))
       (maybe-ci (string->char-set (pht sre)))
       (error/type ^rt-parameter-value-error 'sre->char-set "(char-set) takes only one char-set" sre)))
      ((/ char-range)
       (->cs
	#T{
	  or $@(map (function (x) (ucs-range->char-set
				   (unicode->integer (ph x))
				   (1 + (unicode->integer (pt x)))))
		(sre-flatten-ranges (pt sre)))
       }))
      ((\& \and) (apply intersection-char-set (map ->cs (pt sre))))
      ((\| \or) (apply union-char-set (map ->cs (pt sre))))
      ((~ complement) (complement-char-set (->cs #T{ or $@(pt sre) })))
      ((- difference) (difference-char-set (->cs (pht sre))
					   (->cs #T{ (or $@(ptt sre)) })))
      ((w/case) (if (null? (ptt sre))
       (sre->char-set (pht sre) (flag-clear flags ~ci?))
       (error/type ^rt-parameter-value-error 'sre-char-set "w/case takes only one char-set" sre)))
      ((w/nocase) (if (null? (ptt sre))
       (sre->char-set (pht sre) (flag-join flags ~ci?))
       (error/type ^rt-parameter-value-error 'sre-char-set "w/nocase takes only one char-set" sre)))
      ((w/ascii) (if (null? (ptt sre))
       (sre->char-set (pht sre) (flag-join flags ~ascii?))
       (error/type ^rt-parameter-value-error 'sre-char-set "w/ascii takes only one char-set" sre)))
      ((w/unicode) (if (null? (ptt sre))
       (sre->char-set (pht sre) (flag-clear flags ~ascii?))
       (error/type ^rt-parameter-value-error 'sre-char-set "w/unicode takes only one char-set" sre)))
      (else (error/type ^rt-parameter-type-error 'sre-char-set "invalid sre char-set" sre)))))
   (else (error/type ^rt-parameter-type-error 'sre-char-set "invalid sre char-set" sre)))
}

define (char-set->sre cset) "

Returns an SRE corresponding to the given SRFI 14 character set
`cset`.

:param cset: SRFI-14 character set
:type cset: struct-instance
:return: SRE
:type cset: list

" {
  list (char-set->string cset)
}

define (strip-submatches sre) {
  (if (pair? sre)
   (case (ph sre)
    (($ submatch) (strip-submatches (pair ': (pt sre))))
    ((-> => submatch-named) (strip-submatches (pair ': (ptt sre))))
    (else (pair (strip-submatches (ph sre))
		(strip-submatches (pt sre)))))
   sre)
}

define (sre-expand-reps from to sre) {
  sre0 := strip-submatches sre
  loop :+ function (i res) {
    (if (i eq from)
     (cond
      ((not to)
       (reverse (pair #T{ (* $sre) } res)))
      ((from eq to)
       (reverse (pair sre (pt res))))
      (else {
	loop :+ function (i res) {
	  (if (i ge to)
	   (reverse (pair #T{ (? $sre) } res))
	   (loop (i + 1) (pair #T{ (? $sre0) } res)))
	}

	loop (i + 1) res
      }))
     (loop (i + 1) (pair sre0 res)))
  }

  loop 0 '(:)
}

;;> Compile an \var{sre} into a regexp.

define (regexp sre & o) "
Compiles a regexp if given an object whose structure matches the SRE syntax.

Returns `sre` unmodified if it is already a regexp.

:param sre: SRE
:param sre: list
:param flags: flags
:param flags: list
:return: regexp
:rtype: struct-instance
:raises ^rt-parameter-value-error:

" {
  current-index := 2
  current-match := 0
  current-id := 0
  match-names := #n
  match-rules := list (pair 0 1)
  non-greedy-indexes := #n
  define (next-id) {
    res := current-id
    current-id = current-id + 1
    res
  }
  define (make-submatch-state sre flags next index) {
    n3 := make-epsilon-state next (next-id)
    n2 := ->rx sre flags n3
    n1 := make-epsilon-state n2 (next-id)
    non-greedy? := non-greedy-sre? sre

    set-state-match! n1 index
    set-state-match-rule! n1 'left
    set-state-match! n3 (index + 1)
    set-state-match-rule! n3 (if non-greedy? 'non-greedy-left 'right)
    if non-greedy? {
      non-greedy-indexes = pair (index + 1) non-greedy-indexes
    }
    n1
  }
  define (->rx sre flags next) {
    ;; The base cases chars and strings match literally.
    (cond
     ((unicode? sre)
      (make-char-state sre flags next (next-id)))
     ((char-set? sre)
      (make-char-state sre flags next (next-id)))
     ((string? sre)
      (->rx (pair 'seq (string->list sre)) flags next))
     ((and (symbol? sre) (lookup-char-set sre flags))
      => (function (cset) (make-char-state cset ~none next (next-id))))
     ((symbol? sre)
      (case sre
       ((epsilon) next)
       ((bos) (make-char-state match/bos flags next (next-id)))
       ((eos) (make-char-state match/eos flags next (next-id)))
       ((bol) (make-char-state match/bol flags next (next-id)))
       ((eol) (make-char-state match/eol flags next (next-id)))
       ((bow) (make-char-state match/bow flags next (next-id)))
       ((eow) (make-char-state match/eow flags next (next-id)))
       ((nwb) (make-char-state match/nwb flags next (next-id)))
       ((bog) (make-char-state match/bog flags next (next-id)))
       ((eog) (make-char-state match/eog flags next (next-id)))
       ((grapheme)
	(->rx
	 #T{
	   (or
	    (: (* $char-set:hangul-l) (+ $char-set:hangul-v)
				      (* $char-set:hangul-t))
	    (: (* $char-set:hangul-l) $char-set:hangul-v
				      (* $char-set:hangul-v) (* $char-set:hangul-t))
	    (: (* $char-set:hangul-l) $char-set:hangul-lvt
				      (* $char-set:hangul-t))
	    (+ $char-set:hangul-l)
	    (+ $char-set:hangul-t)
	    (+ $char-set:regional-indicator)
	    (: "\r\n")
	    (: (~ control ("\r\n"))
	       (* $char-set:extend-or-spacing-mark))
	    control)
	}
	 flags
	 next))
       ((word) (->rx '(word+ any) flags next))
       (else (error/type ^rt-parameter-value-error '->rx "unknown sre symbol" sre))))
     ((pair? sre)
      (case (ph sre)
       ((seq :)
	;; Sequencing.  An empty sequence jumps directly to next,
	;; otherwise we join the first element to the sequence formed
	;; of the remaining elements followed by next.
	(if (null? (pt sre))
	 next {
	  ;; Make a dummy intermediate to join the states so that we
	  ;; can generate n1 first, preserving the submatch order.
	  n2 := make-epsilon-state #f (next-id)
	  n1 := ->rx (pht sre) flags n2
	  n3 := ->rx (pair 'seq (ptt sre)) flags next

	  set-state-next1! n2 n3
	  n1
	}))
       ((or \|)
	;; Alternation.  An empty alternation always fails.  Otherwise
	;; we fork between any of the alternations, each continuing to
	;; next.
	(cond
	 ((null? (pt sre))
	  #f)
	 ((char-set-sre? sre)
	  (make-char-state (sre->char-set sre) flags next (next-id)))
	 ((null? (ptt sre))
	  (->rx (pht sre) flags next))
	 (else {
	   n1 := ->rx (pht sre) flags next
	   n2 := ->rx (pair 'or (ptt sre)) flags next


	   make-fork-state n1 n2 (next-id)
	 })))
       ((? optional ?? non-greedy-optional)
	;; Optionality.  Either match the body or fork to the next
	;; state directly.
	(make-fork-state (->rx (pair 'seq (pt sre)) flags next)
			 next (next-id)))
       ((* zero-or-more *? non-greedy-zero-or-more)
	;; Repetition.  Introduce two fork states which can jump from
	;; the end of the loop to the beginning and from the beginning
	;; to the end (to skip the first iteration).
	{
	  n2 := make-fork-state next #f (next-id)
	  n1 := make-fork-state (->rx (pair 'seq (pt sre)) flags n2) n2 (next-id)

	  set-state-next2! n2 n1
	  n1
       })
       ((+ one-or-more)
	;; One-or-more repetition.  Same as above but the first
	;; transition is required so the rx is simpler - we only need
	;; one fork from the end of the loop to the beginning.
	{
	  n2 := make-fork-state next #f (next-id)
	  n1 := ->rx (pair 'seq (pt sre)) flags n2

	  set-state-next2! n2 n1
	  n1
       })
       ((= exactly)
	;; Exact repetition.
	(->rx (sre-expand-reps (pht sre) (pht sre) (pair 'seq (ptt sre)))
	      flags next))
       ((>= at-least)
	;; n-or-more repetition.
	(->rx (sre-expand-reps (pht sre) #f (pair 'seq (ptt sre)))
	      flags next))
       ((** repeated **? non-greedy-repeated)
	;; n-to-m repetition.
	(->rx (sre-expand-reps (pht sre) (ph (ptt sre))
					 (pair 'seq (pt (ptt sre))))
	 flags next))
       ((-> => submatch-named)
	;; Named submatches just record the name for the current match
	;; and rewrite as a non-named submatch.
	(cond
	 ((flag-set? flags ~nocapture?)
	  (->rx (pair 'seq (ptt sre)) flags next))
	 (else
	  (set! match-names
		(pair (pair (pht sre) (1 + current-match)) match-names))
	  (->rx (pair 'submatch (ptt sre)) flags next))))
       ((*-> *=> submatch-named-list)
	(cond
	 ((flag-set? flags ~nocapture?)
	  (->rx (pair 'seq (ptt sre)) flags next))
	 (else
	  (set! match-names (pair (pair (pht sre) current-match) match-names))
	  (->rx (pair 'submatch-list (ptt sre)) flags next))))
       (($ submatch)
	;; A submatch wraps next with an epsilon transition before
	;; next, setting the start and end index on the result and
	;; wrapped next respectively.
	(cond
	 ((flag-set? flags ~nocapture?)
	  (->rx (pair 'seq (pt sre)) flags next))
	 (else {
	   num := current-match
	   index := current-index

	   current-match = current-match + 1
	   current-index = current-index + 2
	   match-rules = #T{ (($index & $(index + 1)) $@match-rules) }
	   make-submatch-state (pair 'seq (pt sre)) flags next index
	 })))
       ((*$ submatch-list)
	;; A submatch-list wraps a range of submatch results into a
	;; single match value.
	(cond
	 ((flag-set? flags ~nocapture?)
	  (->rx (pair 'seq (pt sre)) flags next))
	 (else {
	   num := current-match
	   index := current-index

	   current-match = current-match + 1
	   current-index = current-index + 1
	   match-rules = #T{ ($index $@match-rules) }

	   n2 := make-epsilon-state next (next-id)
	   n1 := ->rx (pair 'submatch (pt sre)) flags n2

	   set-state-match! n2 (list index num current-match)
	   set-state-match-rule! n2 'list
	   n1
	 })))
       ((~ \- \& \/ complement difference \and char-range char-set)
	(make-char-state (sre->char-set sre flags) ~none next (next-id)))
       ((word)
	(->rx #T{ (: bow $@(pt sre) eow) } flags next))
       ((word+)
	(->rx #T{ (word (+ $(if (equal? '(any) (pt sre))
	 'word-constituent
	 (intersection-char-set
	  char-set:word-constituent
	  (sre->char-set #T{ (or $@(pt sre)) } flags))))) }
	      flags
	      next))
       ((w/case)
	(->rx #T{ (: $@(pt sre)) } (flag-clear flags ~ci?) next))
       ((w/nocase)
	(->rx #T{ (: $@(pt sre)) } (flag-join flags ~ci?) next))
       ((w/unicode)
	(->rx #T{ (: $@(pt sre)) } (flag-clear flags ~ascii?) next))
       ((w/ascii)
	(->rx #T{ (: $@(pt sre)) } (flag-join flags ~ascii?) next))
       ((w/nocapture)
	(->rx #T{ (: $@(pt sre)) } (flag-join flags ~nocapture?) next))
       (else
	(if (string? (ph sre))
	 (make-char-state (sre->char-set sre flags) ~none next (next-id))
	 (error/type ^rt-parameter-value-error '->rx "unknown sre pair" sre))))))
  }

  flags := parse-flags (and (pair? o) (ph o))

  (if (regexp? sre)
   sre
   {
     start := make-submatch-state sre flags (make-accept-state (next-id)) 0
     ;; (define (state->list st)
     ;;   (let ((seen (make-hash-table eq?))
     ;;         (count 0))
     ;;     (reverse
     ;;      (let lp ((st st) (res '()))
     ;;        (cond
     ;;         ((not (state? st)) res)
     ;;         ((hash-table-ref/default seen st #f) res)
     ;;         (else
     ;;          (hash-table-set! seen st count)
     ;;          (let ((orig-count count))
     ;;            (set! count (count + 1))
     ;;            (let* ((next1 (lp (state-next1 st) '()))
     ;;                   (next2 (lp (state-next2 st) '()))
     ;;                   (this (append
     ;;                          (list (state-id st) ;;orig-count
     ;;                                (cond
     ;;                                 ((epsilon-state? st)
     ;;                                  (if (state-chars st) '? '-))
     ;;                                 ((and (char-set? (state-chars st))
     ;;                                       (< (char-set-size (state-chars st)) 5))
     ;;                                  (char-set->string (state-chars st)))
     ;;                                 ((unicode? (state-chars st))
     ;;                                  (string (state-chars st)))
     ;;                                 (else '+))
     ;;                                (cond
     ;;                                 ((state-next1 st) => state-id)
     ;;                                 (else #f)))
     ;;                          (if (state-next2 st)
     ;;                              (list (state-id (state-next2 st)))
     ;;                              '())
     ;;                          (if (state-match st)
     ;;                              (list (list 'm (state-match st)))
     ;;                              '()))))
     ;;              (append next2 next1 (cons this res))))))))))
     ;;(for-each (lambda (x) (write x) (newline)) (state->list start))
     make-Rx start current-match current-index non-greedy-indexes (list->array (reverse match-rules)) match-names sre
  })
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

;;> The fundamental regexp matching iterator.  Repeatedly searches
;;> \var{str} for the regexp \var{re} so long as a match can be found.
;;> On each successful match, applies \scheme{(\var{kons} \var{i}
;;> \var{regexp-match} \var{str} \var{acc})} where \var{i} is the
;;> index since the last match (beginning with
;;> \var{start}),\var{regexp-match} is the resulting match, and
;;> \var{acc} is the result of the previous \var{kons} application,
;;> beginning with \var{knil}.  When no more matches can be found,
;;> calls \var{finish} with the same arguments, except that
;;> \var{regexp-match} is \scheme{#f}.
;;>
;;> By default \var{finish} just returns \var{acc}.

define (regexp-fold rx kons knil str & o) "

The fundamental regexp matching iterator.

Repeatedly searches `str` for the regexp `re` so long as a match can
be found.  On each successful match, applies :samp:`({kons} {i}
{regexp-match} {str} {acc})` where `i` is the index since the last
match (beginning with `start`), `regexp-match` is the resulting match,
and `acc` is the result of the previous `kons` application, beginning
with `knil`.  When no more matches can be found, calls `finish` with
the same arguments, except that `regexp-match` is ``#f``.

By default `finish` just returns `acc`.

:param re: SRE or regexp
:type re: list or struct-instance
:param kons: accumulation function
:type kons: function
:param knil: accumlated result
:type knil: any
:param str: string to match
:type str: string
:param finish: result function, defaults to a function returning `acc`
:type finish: function, optional
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer or ``#f``, optional
:return: according to `finish`
:rtype: any

" {
  rx := regexp rx
  finish := if (pair? o) (ph o) (function (from md str acc) acc)
  o := if (pair? o) (pt o) o
  start := string-start-arg str o
  end := string-end-arg str (if (pair? o) (pt o) o)

  loop :+ function (i from acc) {
    (cond
     ((and (i lt end) (regexp-run-offsets #t rx str i end))
      => (function (md) {
	j := regexp-match-ref md 1

	(loop
	 (if (and (i eq j) (j lt end))
	  (string-cursor-next str j)
	  j)
	 j
	 (kons (string-cursor->index str from) md str acc))
      }))
     (else
      (finish (string-cursor->index str from) #f str acc)))
  }

  loop start start knil
}

;;> Extracts all non-empty substrings of \var{str} which match
;;> \var{re} between \var{start} and \var{end} as a list of strings.

define (regexp-extract rx str & o) "

Extracts all non-empty substrings of `str` which match `re` between
`start` and `end` as a list of strings.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer, optional
:return: list of matching strings
:rtype: list

" {
  (apply regexp-fold
	 rx
	 (function (from md str a) {
	   s := regexp-match-submatch md 0

	   if (equal? s "") a (pair s a)
	 })
	 #n
	 str
	 (function (from md str a) (reverse a))
	 o)
}

;;> Splits \var{str} into a list of strings separated by matches of
;;> \var{re}.

define (regexp-split rx str & o) "

Splits `str` into a list of (possibly empty) strings separated by
non-empty matches of `re`.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer, optional
:return: list of matching strings
:rtype: list

" {
  ;; start and end in indices passed to regexp-fold
  start := if (pair? o) (ph o) 0
  end := if (and (pair? o) (pair? (pt o))) (pht o) (string-length str)

  (regexp-fold rx
	       (function (from md str a) {
		 i := regexp-match-submatch-start md 0
		 j := regexp-match-submatch-end md 0

		 (if (eqv? i j)
		  a
		  (pair j (pair (substring str (ph a) i) (pt a))))
	       })
	       (pair start #n)
	       str
	       (function (from md str a)
		(reverse (pair (substring str (ph a) end) (pt a))))
	       start
	       end)
}

;;> Partitions \var{str} into a list of non-empty strings
;;> matching \var{re}, interspersed with the unmatched portions
;;> of the string.  The first and every odd element is an unmatched
;;> substring, which will be the empty string if \var{re} matches
;;> at the beginning of the string or end of the previous match.  The
;;> second and every even element will be a substring matching
;;> \var{re}.  If the final match ends at the end of the string,
;;> no trailing empty string will be included.  Thus, in the
;;> degenerate case where \var{str} is the empty string, the
;;> result is \scheme{("")}.

define (regexp-partition rx str & o) "

Partitions `str` into a list of non-empty strings matching `re`,
interspersed with the unmatched portions of the string.  The first and
every odd element is an unmatched substring, which will be the empty
string if `re` matches at the beginning of the string or end of the
previous match.  The second and every even element will be a substring
matching `re`.  If the final match ends at the end of the string, no
trailing empty string will be included.  Thus, in the degenerate case
where `str` is the empty string, the result is ``(\"\")`` .

Note that ``regexp-partition`` is equivalent to interleaving the
results of :ref:`regexp-split <SRFI-115/regexp-split>` and
:ref:`regexp-extract <SRFI-115/regexp-extract>`, starting with the
former.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer, optional
:return: list of matching strings
:rtype: list

" {
  start := if (pair? o) (ph o) 0
  end := if (and (pair? o) (pair? (pt o))) (pht o) (string-length str)

  define (kons from md str a) {
    i := regexp-match-submatch-start md 0
    j := regexp-match-submatch-end md 0

    (if (eqv? i j)
     a
     {
       left := substring str (ph a) i
       
       pair j (pair (regexp-match-submatch md 0)
		    (pair left (pt a)))
    })
  }

  define (final from md str a) {
    (if (or (from lt end) (null? (pt a)))
     (pair (substring str (ph a) end) (pt a))
     (pt a))
  }

  reverse (regexp-fold rx kons (pair start #n) str final start end)
}

;;> Returns a new string replacing the \var{count}th match of \var{re}
;;> in \var{str} the \var{subst}, where the zero-indexed \var{count}
;;> defaults to zero (i.e. the first match).  If there are not
;;> \var{count} matches, returns the selected substring unmodified.

;;> \var{subst} can be a string, an integer or symbol indicating the
;;> contents of a numbered or named submatch of \var{re},\scheme{'pre}
;;> for the substring to the left of the match, or \scheme{'post} for
;;> the substring to the right of the match.

;;> The optional parameters \var{start} and \var{end} restrict both
;;> the matching and the substitution, to the given indices, such that
;;> the result is equivalent to omitting these parameters and
;;> replacing on \scheme{(substring str start end)}. As a convenience,
;;> a value of \scheme{#f} for \var{end} is equivalent to
;;> \scheme{(string-length str)}.

define (regexp-replace rx str subst & o) "

Returns a new string replacing the `count`\ :sup:`th` match of `re` in
`str` the `subst`, where the zero-indexed `count` defaults to
zero (i.e. the first match).  If there are not `count` matches,
returns the selected substring unmodified.

`subst` can be a string, an integer or symbol indicating the contents
of a numbered or named submatch of `re`, ``'pre`` for the substring to
the left of the match, or ``'post`` for the substring to the right of
the match.

The optional parameters `start` and `end` restrict both the matching
and the substitution, to the given indices, such that the result is
equivalent to omitting these parameters and replacing on
:samp:`(substring {str} {start} {end})`.  As a convenience, a value of
``#f`` for `end` is equivalent to :samp:`(string-length {str})`.

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param subst: replacement
:type subst: see above
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer or ``#f``, optional
:param count: replacement index count, defaults to zero
:type count: integer, optional
:return: (possibly) modified string
:rtype: string

" {
  start := if (and (pair? o) (ph o)) (ph o) 0
  o := if (pair? o) (pt o) #n
  end := if (and (pair? o) (ph o)) (ph o) (string-length str)
  o := if (pair? o) (pt o) #n
  count := if (pair? o) (ph o) 0

  loop :+ function (i count) {
    m := regexp-search rx str i end

    (cond
     ((not m) str)
     ((positive? count)
      (loop (regexp-match-submatch-end m 0) (count - 1)))
     (else
      (concatenate-string
       (pair
	(substring str start (regexp-match-submatch-start m 0))
	(append
	 (reverse (regexp-apply-match m str subst start end))
	 (list (substring str (regexp-match-submatch-end m 0) end)))))))
  }

  loop start count
}

;;> Equivalent to \var{regexp-replace}, but replaces all occurrences
;;> of \var{re} in \var{str}.

define (regexp-replace-all rx str subst & o) "

Equivalent to :ref:`regexp-replace <SRFI-115/regexp-replace>` but
replaces all occurrences of `re` in `str`

:param re: SRE or regexp
:type re: list or struct-instance
:param str: string to match
:type str: string
:param subst: replacement
:type subst: see above
:param start: starting index, defaults to 0
:type start: integer, optional
:param end: ending index, defaults to string length
:type end: integer or ``#f``, optional
:return: (possibly) modified string
:rtype: string

" {
  start := if (and (pair? o) (ph o)) (ph o) 0
  o := if (pair? o) (pt o) #n
  end := if (and (pair? o) (ph o)) (ph o) (string-length str)

  (regexp-fold rx
	       (function (i m str acc) {
		 m-start := regexp-match-submatch-start m 0

		 (append (regexp-apply-match m str subst start end)
			 (if (i ge m-start)
			  acc
			  (pair (substring str i m-start) acc)))
	       })
	       #n
	       str
	       (function (i m str acc) {
		 end := string-length str

		 concatenate-string (reverse (if (i ge end)
		  acc
		  (pair (substring str i end) acc)))
	       })
	       start end)
}

define (regexp-apply-match m str ls start end) {
  loop :+ function (ls res) {
    (cond
     ((null? ls)
      res)
     ((not (pair? ls))
      (loop (list ls) res))
     ((integer? (ph ls))
      (loop (pt ls) (pair (or (regexp-match-submatch m (ph ls)) "") res)))
     ((function? (ph ls))
      (loop (pt ls) (pair ((ph ls) m) res)))
     ((symbol? (ph ls))
      (case (ph ls)
       ((pre)
	(loop (pt ls)
	      (pair (substring str start (regexp-match-submatch-start m 0))
		    res)))
       ((post)
	(loop (pt ls)
	      (pair (substring str (regexp-match-submatch-end m 0) end)
		    res)))
       (else
	(cond
	 ((assq (ph ls) (regexp-match-names m))
	  => (function (x) (loop (pair (pt x) (pt ls)) res)))
	 (else
	  (error/type ^rt-parameter-value-error 'regexp-apply-match "unknown match replacement" (ph ls)))))))
     (else
      (loop (pt ls) (pair (ph ls) res))))
  }

  loop ls #n
}

define re:grapheme (regexp 'grapheme)

provide SRFI-115
