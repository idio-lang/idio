;;
;; Copyright (c) 2015, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; libc-wrap.idio
;;

module libc

export (make-tmp-file-handle
	make-tmp-dir
	stdin-fileno
	stdout-fileno
	stderr-fileno)

;; define structure accessors
export-struct-accessors-only struct-sigaction		sa-handler sa-sigaction sa-mask sa-flags
export-struct-accessors-only struct-utsname		sysname nodename release version machine
export-struct-accessors-only struct-rlimit		rlim_cur rlim_max
export-struct-accessors-only struct-tms			tms_rtime tms_utime tms_stime tms_cutime tms_cstime

;; stdin/stdout
;;
;; Idio doesn't make any particular handle stdin or stdout directly.
;; Rather, each Idio *thread* simply has stdin and stdout attributes
;; which reference an existing handle.  All of the output directives,
;; say, look up the current output handle and write their output
;; there.
;;
;; *nix make file descriptors 0, 1 and 2 special -- STDIN_FILENO,
;; STDOUT_FILENO and STDERR_FILENO to be precise.  Programs
;; (blindly) write to file descriptor 1 (or the FILE* {stdout}) for
;; output.
;;
;; How do we make them align?  Especially if we want to use exotic
;; types such as string-handles for stdin or stdout.
;;
;; The problem is acute when we want to run a pipeline or an external
;; process.  To prepare the external process, nominally, we start
;; referencing STDIN_FILENO etc..  Rather than that, call a function
;; to look at what Idio's thread thinks the current input or output is
;; and then make a decision then.
;;
;; For a file-handle the decision is easy: call file-handle-fd (or,
;; rather, fileno as we want a C "int" type).
;;
;; For a string-handle we can use temporary files.  For input, this is
;; like using a "here-string" in Bash, ie. we create a temporary file,
;; write the string into it then open the file and use it as stdin.
;;
;; We can't quite do the same for output as sematically it's
;; different: ``ls -l > sym'' is saying that when we subsequently use
;; {sym} in Idio its value should be the output of "ls -l".  That
;; means we can't be in a subshell or anything, the parent Idio must
;; set things up so that "ls -l" sends its output to a temporary file,
;; the parent then reads the contents of the file back in to be the
;; value of {sym}, creating {sym} (if necessary) in the process.
;;
;; Remembering to delete any temporary files, of course!
;;
;; That requires a slew of supporting functions.


;; File Permissions
define (%file-access file mode) {
  eprintf "%file-access %s %s: not implemented\n" file mode
}

;; Temporary Files

;; We can call the mkstemp(3) interface but we need a suitable
;; directory and then a template.

;; We'll follow the style of Bash .../lib/sh/tmpfile.c

;; "." is not the ideal fallback!
%sys-tmpdirs := '("/tmp" "var/tmp" "usr/tmp" ".")

%sys-tmpdir := #f
%default-tmpname-prefix := "idio-tmp-"
%%mkstemp-template := "XXXXXX"

define (%get-sys-tmpdir) {
  loop :+ function (dirs) {
	    if (null? dirs) (error '%get-sys-tmpdir "no remaining %sys-tmpdirs" %sys-tmpdirs) {
	      dir := ph dirs
	      if (access dir W_OK) dir {
		loop (pt dirs)
	      }
	    }
  }

  if %sys-tmpdir %sys-tmpdir {
    %sys-tmpdir = loop %sys-tmpdirs
  }
}

define (%get-tmpdir) {
  tmpdir := #f

  if ((environ? 'TMPDIR) and
      (access TMPDIR W_OK)) {
	tmpdir = TMPDIR
      } {
	tmpdir = (%get-sys-tmpdir)
      }
}

define (%make-tmp-fd & args) {
  tmpdir := (%get-tmpdir)
  prefix := %default-tmpname-prefix
  if (not (null? args)) {
    prefix = ph args
  }

  tmpfilename := append-string tmpdir "/" prefix %%mkstemp-template

  ;; NB mkstemp returns a tuple of (fd, filename)
  mkstemp tmpfilename
}

define (make-tmp-file-handle & prefix) {
  fd-name := apply %make-tmp-fd prefix

  ;; mkstemp opens the file for reading and writing and we should
  ;; set close-on-exec
  open-file-from-fd (ph fd-name) (pht fd-name) "rwe"
}

define (make-tmp-dir & args) {
  tmpdir := (%get-tmpdir)
  prefix := %default-tmpname-prefix
  if (not (null? args)) {
    prefix = ph args
  }

  tmpdirname := append-string tmpdir "/" prefix %%mkstemp-template
  mkdtemp tmpdirname
}

;; stdin-fileno
;;
;; This is used where we need to know the file descriptor for stdin --
;; nominally, for when we are about to launch a *nix process.
;;
;; What does Idio think the current input handle is and if the current
;; input handle is a string then we need to convert that to a file we
;; can have the impending *nix process read from.
;;
;; The temporary file code is derived from Bash's here document code
;; (lib/sh/tmpfile.c).
define (stdin-fileno) {
  ih := (current-input-handle)
  cond ((input-file-handle? ih) (fileno ih)) \
       ((file-handle? ih) (error 'stdin-fileno "not an input-file-handle" ih)) \
       ((input-string-handle? ih) {
	 ;; 1. create and open a temporary file
	 fd+name := %make-tmp-fd "idio-ish"
	 handle := open-input-file-from-fd (ph fd+name) (pht fd+name) "r+"
	 ;; 2. write the string to it
	 display (get-output-string ih) handle
	 ;; 3. *before* we unlink or close the original fd, open as
	 ;; the input file
	 fd := fileno (open-input-file (pht fd+name))
	 ;; 4. unlink and close the original -- this flushes any
	 ;; output!
	 unlink (pht fd+name)
	 close-handle handle
	 ;; 5. set the close-on-exec flag
	 fcntl fd F_SETFD FD_CLOEXEC
	 ;; 6. return the fd of "stdin" -- as a list to mark it
	 ;; special
	 list fd
       }) \
       (else (error 'stdin-fileno "unexpected current-input-handle" ih))
}

;;
define (stdout-fileno) {
  oh := (current-output-handle)
  cond ((output-file-handle? oh) (fileno oh)) \
       ((file-handle? oh) (error 'stdout-fileno "not an output-file-handle" oh)) \
       ((output-string-handle? oh) {
	 ;; 1. create a temporary file
	 fd+name := %make-tmp-fd "idio-osh"
	 ;; 2. unlink the tmpfile
	 unlink (pht fd+name)
	 ;; 3. set the close-on-exec flag
	 fcntl (ph fd+name) F_SETFD FD_CLOEXEC
	 ;; 4. return the tuple {fd,oh} of "stdout" -- as a list to
	 ;; mark it special
	 list (ph fd+name) oh
       }) \
       (else (error 'stdout-fileno "unexpected current-output-handle" oh))
}

;;
define (stderr-fileno) {
  oh := (current-error-handle)
  cond ((output-file-handle? oh) (fileno oh)) \
       ((file-handle? oh) (error 'stderr-fileno "not an output-file-handle" oh)) \
       ((output-string-handle? oh) {
	 ;; 1. create a temporary file
	 fd+name := %make-tmp-fd "idio-esh"
	 ;; 2. unlink the tmpfile
	 unlink (pht fd+name)
	 ;; 3. set the close-on-exec flag
	 fcntl (ph fd+name) F_SETFD FD_CLOEXEC
	 ;; 4. return the tuple {fd,oh} of "stderr" -- as a list to
	 ;; mark it special
	 list (ph fd+name) oh
       }) \
       (else (error 'stderr-fileno "unexpected current-error-handle" oh))
}


;; define more convenient getrlimit/setrlimit which can use any of the
;; libc/RLIMIT_* symbols, the C/int values or a :nickname keyword,
;; eg. :NOFILE for libc/RLIMIT_NOFILE

getrlimit = {
  orig-getrlimit := getrlimit

  function (res) "define a more convenient `getrlimit` which can use a :nickname
keyword, eg. ``:NOFILE`` for ``libc/RLIMIT_NOFILE``

:param res: either the ``libc/RLIMIT_*`` symbol or C/int or :* keyword
:rtype: struct-rlimit

:return: 
  " {
    resource := #n
    cond ((C/int? res) (resource = res)) \
         ((symbol? res) (resource = res)) \
	 ((keyword? res) {

	   ;; each OS has a different set of (valid) RLIMIT_* macros so our
	   ;; set of :nickname tests has to be dynamic

	   map (function (np) "map over `libc/rlimit-names`" {
	     ln := pt np
	     n := pht (split-string ln "_")
	     k := make-keyword n
	     s := string->symbol ln

	     if (eq? res k) {
	       resource = symbol-value s 'libc
	     }
	   }) (libc/rlimit-names)

	   if (null? resource) (error 'getrlimit "bad resource" resource "from" res)
	 })

    orig-getrlimit resource
  }
}

setrlimit = {
  orig-setrlimit := setrlimit

  function (res rlim) "define a more convenient `setrlimit` which can use a :nickname
keyword, eg. ``:NOFILE`` for ``libc/RLIMIT_NOFILE``

:param res: either the ``libc/RLIMIT_*`` symbol or C/int or :* keyword
:param rlim: struct-rlimit
:rtype: #unspec

:return: #unspec
  " {
    resource := #n
    cond ((C/int? res) (resource = res)) \
         ((symbol? res) (resource = res)) \
	 ((keyword? res) {

	   ;; each OS has a different set of (valid) RLIMIT_* macros so our
	   ;; set of :nickname tests has to be dynamic

	   map (function (np) "map over `libc/rlimit-names`" {
	     ln := pt np
	     n := pht (split-string ln "_")
	     k := make-keyword n
	     s := string->symbol ln

	     if (eq? res k) {
	       resource = symbol-value s 'libc
	     }
	   }) (libc/rlimit-names)

	   if (null? resource) (error 'setrlimit "bad resource" resource "from" res)
	 })

    orig-setrlimit resource rlim
  }
}

%%add-as-string struct-timeval struct-timeval-as-string

provide libc
