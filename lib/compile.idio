#*

Copyright (c) 2022 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

compile.idio

*#

module compile
export (
	 compile-file
	 compile-file-reader
)
import evaluate codegen vm job-control

define (compile-file-writer file eenv pc) {
  printf "compile-file-writer: %s\n" file

  dn := dirname-pathname file
  cdn := append-string dn "/" *idio-cache-dir*
  if (not (d? cdn)) {
    mkdir cdn
  }

  ;; massage dir/foo.idio into dir/__idio__/foo.{asm_commit} where
  ;; {asm_commit} tracks changes in src/vm-asm.h and keeps any of
  ;; {REDACTED}'s casual behaviour from breaking things
  bn := basename-pathname file
  (regex-case
   bn
   ("(.*)\\.idio" {
     bn = r.1
   }))
  cn := append-string cdn "/" bn "." IDIO_BUILD_ASM_COMMIT

  with-output-to-file cn (function #n {
    desc := %eenv-desc eenv

    puts #S{
; This is the execution environment for ${desc}
}
    if (not (equal? desc file)) {
      puts #S{; found as ${file}
}
    }

     puts #S{
; The lib/compiler.idio commit used to create this file
}

    write IDIO_BUILD_COMPILER_COMMIT
    puts "\n"

    ;; An approximately RFC3339 timestamp
    now := libc/strftime "%Y-%m-%dT%H:%M:%SZ%z" (libc/localtime)

    puts #S{
; This file was generated at
}
    write now
    puts "\n"

    puts #S{
; The src/vm-asm.h commit used to create the byte code
}

    write IDIO_BUILD_ASM_COMMIT
    puts "\n"

    puts #S{
; The checksum for the source file
}

    write (%eenv-chksum eenv)
    puts "\n"

    vs := %eenv-values eenv
    vslen := (ph vs) + 1
    alen := vslen
    st := %eenv-symbols eenv
    stlen := length st
    if (stlen gt alen) {
      alen = stlen
    }

    puts #S{
; The symbol/value table sizes
${alen}
}

    puts #S{
; The symbol table entries
( }

    for sym-si in (reverse st) {
      si := pt sym-si
      write (pair (si-si si) (si-ci si))
      puts " "
    }

    puts #S{)
}

    cs := %eenv-constants eenv
    puts #S{
; The ${array-length cs} constants
#\[ }

    for c in cs {
      write c
      puts " "
    }
    puts #S{\]
}

    puts #S{
; The initial program counter
${pc}
}

    bc := %eenv-byte-code eenv
    bs := idio-ia->string bc

    puts #S{
; The xenv byte code (${string-length bs} bytes)
}

    write bs
    puts "\n\n"

    ses := %eenv-src-exprs eenv
    puts #S{
; The ${array-length ses} source expressions
#\[
}

    for se in ses {
      write se
      puts "\n"
    }
    puts #S{
\]
}

    sps := %eenv-src-props eenv
    puts #S{
; The ${array-length sps} source expression properties
#\[ }

    for sp in sps {
      write sp
      puts " "
    }
    puts #S{\]
}

    puts #S{
; done
}
  })
}

define (compile-file-reader file) {
  printf "compile-file-reader: %s\n" file

  ;; /path/to/__idio__/{mod}.{ASM_COMMIT} where we shouldn't be here
  ;; unless {ASM_COMMIT} in the file name matches
  ;; IDIO_BUILD_ASM_COMMIT.  Although some intrepid user might call us
  ;; direct.
  chksum := #f
  idio-file := file
  (regex-case file
	      (#S{(.*)/${*idio-cache-dir*}/(.+)\\.([^.]+)} {
		idio-file = append-string r.1 "/" r.2 ".idio"
		if (f? idio-file) {
		  chksum = append-string "SHA256:" (ph (split-string (collect-output sha256sum idio-file)))
		} {
		  eprintf "cannot verify expected .idio source %s\n" idio-file
		}
	      }))



  fh := open-input-file file

  r := #t

  idio-build-compiler-commit := read fh

  if (not (equal? idio-build-compiler-commit IDIO_BUILD_COMPILER_COMMIT)) {
    eprintf "compiler-commit %s != %s\n" idio-build-compiler-commit IDIO_BUILD_COMPILER_COMMIT
    r = #f
  }

  if r {
    now := read fh

    if (not (string? now)) {
      eprintf "now %s is not a string\n" now
      r = #f
    }
  }

  if r {
    idio-build-asm-commit := read fh

    if (not (equal? idio-build-asm-commit IDIO_BUILD_ASM_COMMIT)) {
      eprintf "asm-commit %s != %s\n" idio-build-asm-commit IDIO_BUILD_ASM_COMMIT
      r = #f
    }
  }

  if r {
    pc-chksum := read fh

    if chksum {
      if (not (equal? chksum pc-chksum)) {
	eprintf "chksum %s != %s\n" pc-chksum chksum
	r = #f
      }
    }
  }

  alen := #f
  if r {
    alen = read fh

    if (not (integer? alen)) {
      eprintf "alen %s is not an integer\n" alen
      r = #f
    }
  }

  ste := #f
  if r {
    ste = read fh

    if (not (list? ste)) {
      eprintf "symbol table entries is not a list\n" ste
      r = #f
    }
  }

  max-ci := 0
  st := #f
  if r {
    st = make-array alen
    for si-ci in ste {
      ci := pt si-ci
      array-set! st (ph si-ci) ci
      if (ci gt max-ci) {
	max-ci = ci
      }
    }
  }

  cs := #f
  if r {
    cs = read fh

    if (not (array? cs)) {
      eprintf "constants is not an array\n" cs
      r = #f
    } {
      if (max-ci gt (array-length cs)) {
	eprintf "constants is smaller (%d) than the largest symbol index (%d)\n" (array-length cs) max-ci
	r = #f
      }
    }
  }

  pc := #f
  if r {
    pc = read fh

    if (not (integer? pc)) {
      eprintf "pc %s is not an integer\n" pc
      r = #f
    }
  }

  bs := #f
  if r {
    bs = read fh

    if (not (octet-string? bs)) {
      eprintf "byte code %s is not an octet string\n" pc
      r = #f
    } {
      if (pc ge (string-length bs)) {
	eprintf "pc is greater (%d) than the length of the byte code (%d)\n" pc (string-length bs)
	r = #f
      }
    }
  }

  ses := #f
  if r {
    ses = read fh

    if (not (array? ses)) {
      eprintf "source code expressions %s is not an array\n" ses
      r = #f
    }
  }

  sps := #f
  if r {
    sps = read fh

    if (not (array? sps)) {
      eprintf "source code properties %s is not an array\n" ses
      r = #f
    } {
      if ((array-length ses) ne (array-length sps)) {
	eprintf "number ofsource code expressions (%d) does not match the number of source code properties (%d)\n" (array-length ses) (array-length sps)
	r = #f
      }
    }
  }

  if r {
    ;; phew!

    vs := make-array alen 0
    %vm-add-xenv idio-file st cs vs ses sps bs pc
  }

  r
}

; we want to subvert evaluate/meaning-include, which calls {load},
; such that we continue processing.  We'll use compile-file-load for
; that.
compile-file-load := #f

define (compile-file file & args) "
" {
  eenv := #n

  printf "compile-file: %s\n" file

  if (pair? args) {
    eenv = ph args
    printf "compile-file: eenv %s\n" eenv
  } {
    eenv = %evaluation-environment file #t
  }

  fn := file
  if (not (f? fn)) {
    fn = find-lib fn
    printf "compile-file: %s\n" fn
  }

  set-%eenv-chksum! eenv (append-string "SHA256:" (ph (split-string (collect-output sha256sum fn))))

  fh := open-input-file fn

  orig-load := load
  load = compile-file-load

  all-m := #n
  pc := #f

  loop :+ function #n {
    e := read fh
    if (eof-object? e) #n {
      ;;printf "compile-file: e %s\n" e
      m := #f
      trap (^rt-parameter-error
	    ^rt-function-error) (function (c) {
	      condition-report "compile" c
	      printf "...\n\n"
	      sleep 2
	      m = list I-NOP
	      trap-return #f
	    }) {
	      m = evaluate e eenv
      }
      ;printf "compile-file: m #%s\n" (length (phth m))
      ;printf "compile-file: eenv %s\n" eenv

      if m {
	all-m = pair m all-m
      }
      pc0 := codegen m eenv
      if (not pc) {
	pc = pc0
	;printf "compile-file: use  %4s / %4s\n" pc0 (idio-ia-length (%eenv-byte-code eenv))
      } {
	;printf "compile-file: skip %4s / %4s\n" pc0 (idio-ia-length (%eenv-byte-code eenv))
	#t
      }

      (loop)
    }
  }

  (loop)

  load = orig-load

  close-handle fh

  printf "\n"

  ;printf "compile-file: eenv %s\n" eenv

  compile-file-writer fn eenv pc

  ;; return all-m to any recursive calls via evaluate/meaning-include
  ;; which calls {load} which we renamed to be compile-file-load,
  ;; below
  all-m
}

define (compile-file-load file) {
  printf "compile-file-load: %s\n" file
  compile-file file
}

provide compile
