#*

Copyright (c) 2022 Ian Fitchet <idf(at)idio-lang.org>

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License.  You
may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

compile.idio

*#

module compile
export (
	 compile-file
)
import evaluate codegen vm job-control

define (compile-file-writer file eenv pc) {
  ;printf "compile-file-writer: %s\n" file

  dn := dirname-pathname file
  cdn := append-string dn "/" *idio-cache-dir*
  if (not (d? cdn)) {
    mkdir cdn
  }

  ;; massage dir/foo.idio into dir/__idio__/foo.{asm_commit} where
  ;; {asm_commit} tracks changes in src/vm-asm.h and keeps any of
  ;; {REDACTED}'s casual behaviour from breaking things
  bn := basename-pathname file
  (regex-case
   bn
   ("(.*)\\.idio" {
     bn = r.1
   }))
  cn := append-string cdn "/" bn "." IDIO_BUILD_ASM_COMMIT

  with-output-to-file cn (function #n {
    desc := %eenv-desc eenv

    puts #S{
; This is the execution environment for ${desc}
}
    if (not (equal? desc file)) {
      puts #S{; found as ${file}
}
    }

     puts #S{
; The compiler commit used to create this file
}

    write IDIO_BUILD_COMPILER_COMMIT
    puts "\n"

    ;; An approximately RFC3339 timestamp
    now := libc/strftime "%Y-%m-%dT%H:%M:%SZ%z" (libc/localtime)

    puts #S{
; This file was generated at
}
    write now
    puts "\n"

    puts #S{
; The src/vm-asm.h commit used to create the byte code
}

    write IDIO_BUILD_ASM_COMMIT
    puts "\n"

    puts #S{
; The checksum for the source file
}

    write (%eenv-chksum eenv)
    puts "\n"

    alen := array-length (%eenv-vt eenv)

    puts #S{
; The symbol/value table sizes
${alen}
}

    st := %eenv-symbols eenv

    puts #S{
; The symbol table entries (si & ci)
( }

    for sym-si in (reverse st) {
      si := pt sym-si
      if (and (fixnum? (si-si si))
	      (fixnum? (si-ci si))) {
	write (pair (si-si si) (si-ci si))
	puts " "
      }
    }

    puts #S{)
}

    ;; It's hard to avoid the (future) reader getting angsty about &
    ;; in constants, notably, SRFI-115 and its use of & as a term (as
    ;; a shorthand for the combining verb "and" -- which itself needs
    ;; escaping in SRFI-115...).
    ;;
    ;; Here we substitute an escaped & for the future reader of the
    ;; pre-compiled code's constants -- which requires some
    ;; legerdemain for the current reader to be able to write out an
    ;; escaped &.
    esc-amp := string->symbol "\\&"
    define (escaped-constant c) {
      (cond
       ((pair? c) (map escaped-constant c))
       (else {
	 (case c
	  ((\&) esc-amp)
	  (else c))
       }))
    }

    cs := %eenv-cs eenv
    puts #S{
; The ${array-length cs} constants
#\[ }

    i := 0
    for c in cs {
      write (escaped-constant c)
      puts " ; "
      display* i
      i = i + 1
    }
    puts #S{\]
}

    puts #S{
; The initial program counter
${pc}
}

    bc := %eenv-byte-code eenv
    bs := idio-ia->string bc

    puts #S{
; The xenv byte code (${string-length bs} bytes)
}

    write bs
    puts "\n\n"

    puts #S{
; The 0 source expression properties
#\[ \]
}

    sps := %eenv-sps eenv
    puts #S{
; The ${array-length sps} source expression properties (ci line)
#\[ }

    for sp in sps {
      write sp
      puts " "
    }

    puts #S{\]
}

    puts #S{
; done
}
  })
}

; we want to subvert evaluate/meaning-include, which calls {load},
; such that we continue processing.  We'll use compile-file-load for
; that.
compile-file-load := #f
compile-file-load-eenv := #f

define (compile-file file & args) "
" {
  eenv := #n

  ;printf "compile-file: %s\n" file

  if (pair? args) {
    eenv = ph args
    printf "compile-file: re-using eenv for %s\n" (%eenv-desc eenv)
  } {
    eenv = %evaluation-environment file
    set-%eenv-aot?! eenv #t
  }

  fn := file
  if (not (f? fn)) {
    fn = find-lib fn
    printf "compile-file: find-lib %s\n" fn
  }

  ;; Careful, anything that includes something else doesn't want the
  ;; something elses to overwrite the original's chksum
  ;;
  ;; The downside of this is that we don't guarantee the chksum for
  ;; the included files...
  if (not (string? (%eenv-chksum eenv))) {
    set-%eenv-chksum! eenv (append-string "SHA256:" (shasum-file fn))
  }

  fh := open-input-file fn

  orig-load := load
  load = compile-file-load
  orig-cfl-eenv := compile-file-load-eenv
  compile-file-load-eenv = eenv

  all-m := #n

  ;; this should be 10 (until the prologue is changed)
  pc0 := string-length (idio-ia->string (%eenv-byte-code eenv))

  loop :+ function #n {
    e := read fh
    if (eof-object? e) #n {
      ;;printf "compile-file: e %s\n" e
      m := #f
      trap (^rt-parameter-error
	    ^idio-error
	    ^rt-function-error) (function (c) {
	      printf "In %s\n" fh
	      condition-report "compile" c
	      printf "sleep (2) ...\n\n"
	      sleep 2
	      m = list I-NOP
	      trap-return #f
	    }) {
	      m = evaluate e eenv
      }
      ;printf "compile-file: m #%s\n" (length (phth m))
      ;printf "compile-file: eenv %s\n" eenv

      if m {
	all-m = pair m all-m
      }

      pc := codegen m eenv

      (loop)
    }
  }

  (loop)

  load = orig-load
  compile-file-load-eenv = orig-cfl-eenv

  close-handle fh

  ;dump-eenv eenv (append-string (basename-pathname file) ".st")
  ;printf "compile-file: eenv %s\n" eenv

  if (not (pair? args)) {
    compile-file-writer fn eenv pc0
  }

  ;; return all-m to any recursive calls via evaluate/meaning-include
  ;; which calls {load} which we renamed to be compile-file-load,
  ;; below
  all-m
}

define (compile-file-load file) {
  printf "compile-file-load: %s\n" file
  compile-file file compile-file-load-eenv
}

provide compile
