;;
;; Copyright (c) 2015, 2017, 2020 Ian Fitchet <idf(at)idio-lang.org>
;;
;; Licensed under the Apache License, Version 2.0 (the "License"); you
;; may not use this file except in compliance with the License.  You
;; may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;
;;

;;
;; SRFI-95.idio -- a port thereof
;;

;; Copyright (C) Aubrey Jaffer 2006. All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;;; "sort.scm" Defines: sorted?, merge, merge!, sort, sort!
;;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;;;
;;; This code is in the public domain.

;;; Updated: 11 June 1991
;;; Modified for scheme library: Aubrey Jaffer 19 Sept. 1991
;;; Updated: 19 June 1995
;;; (sort, sort!, sorted?): Generalized to strings by jaffer: 2003-09-09
;;; (sort, sort!, sorted?): Generalized to arrays by jaffer: 2003-10-04
;;; jaffer: 2006-10-08:
;;; (sort, sort!, sorted?, merge, merge!): Added optional KEY argument.
;;; jaffer: 2006-11-05:
;;; (sorted?, merge, merge!, sort, sort!): Call KEY arg at most once
;;; per element.
;;; jaffer: 2007-01-29: Final SRFI-95.

;;; (sorted? sequence less?)
;;; is true when sequence is a list (x0 x1 ... xm) or a vector #(x0 ... xm)
;;; such that for all 1 <= i <= m,
;;;	(not (less? (list-ref list i) (list-ref list (- i 1)))).
;@
define (sorted? seq less? & opt-key) {
  key := if (null? opt-key) identity (ph opt-key)

  cond ((null? seq) #t) \
       ((array? seq) {
	 dimax := (array-length seq) - 1

	 (dimax le 1) or {
	   loop :+ function (idx last) {
	     (negative? idx) or {
		nxt := key (array-ref seq idx)

		(less? nxt last) and
		  (loop (idx - 1) nxt)
             }
	   }

	   loop (dimax - 1) (key (array-ref seq dimax))
	 }
       }) \
       ((null? (pt seq)) #t) \
       (else {
	 loop :+ function (last next) {
	   (null? next) or {
	      nxt := key (ph next)

	      (not (less? nxt last)) and
	        (loop nxt (pt next))
	   }
	 }

	 loop (key ph seq) (pt seq)
       })
}

;;; (merge a b less?)
;;; takes two lists a and b such that (sorted? a less?) and (sorted? b less?)
;;; and returns a new list in which the elements of a and b have been stably
;;; interleaved so that (sorted? (merge a b less?) less?).
;;; Note:  this does _not_ accept arrays.  See below.
;@
define (merge a b less? & opt-key) {
  key := if (null? opt-key) identity (ph opt-key)

  cond ((null? a) b) \
       ((null? b) a) \
       (else {
	 loop :+ function (x kx a y ky b) {
	   ;; The loop handles the merging of non-empty lists.  It has
	   ;; been written this way to save testing and ph/pt-ing.
	   if (less? ky kx) {
	      if (null? b) {
		pair y (pair x a)
	      } {
		pair y (loop x kx a (ph b) (key (ph b)) (pt b))
	      }
	   } {
	      ;; x <= y
	      if (null? a) {
		pair x (pair y b)
	      } {
		pair x (loop (ph a) (key (ph a)) (pt a) y ky b)
	      }
	   }
	 }

	 loop (ph a) (key (ph a)) (pt a) (ph b) (key (ph b)) (pt b)
       })
}

define (sort:merge! a b less? key) {
  loop :+ function (r a kpha b kphb) {
    cond ((less? kphb kpha) {
	   set-pt! r b
	   if (null? (pt b)) {
	     set-pt! b a
	   } {
	     loop b a kpha (pt b) (key (pht b))
	   }
	 }) \
	 (else {			; (ph a) <= (ph b)
	   set-pt! r a
	   if (null? (pt a)) {
	     set-pt! a b
	   } {
	     loop a (pt a) (key (pht a)) b kphb
	   }
	 })
  }

  cond ((null? a) b) \
       ((null? b) a) \
       (else {
 	 kpha := key (ph a)
	 kphb := key (ph b)

	 cond ((less? kphb kpha) {
	   if (null? (pt b)) {
	     set-pt! b a
	   } {
	     loop b a kpha (pt b) (key (pht b))
	   }

	   b
         }) \
	     (else {			; (ph a) <= (ph b)
	       if (null? (pt a)) {
		 set-pt! a b
	       } {
		 loop a (pt a) (key (pht a)) b kphb
	       }

	       a
	     })
       })
}

;;; takes two sorted lists a and b and smashes their pt fields to form
;;; a single sorted list including the elements of both.  Note: this
;;; does _not_ accept arrays.
;@
define (merge! a b less? & opt-key) {
  sort:merge! a b less? (if (null? opt-key) identity (ph opt-key))
}

define (sort:sort-list! seq less? key) {
  keyer := if key ph identity

  define (step n) {
    cond ((n gt 2) {
	   j := quotient n 2
	   a := step j
	   k := n - j
	   b := step k

	   sort:merge! a b less? keyer
	 }) \
	 ((n eq 2) {
	   x := ph seq
	   y := pht seq
	   p := seq

	   seq = ptt seq

	   cond ((less? (keyer y) (keyer x)) {
	     set-ph! p y
	     set-ph! (pt p) x
	   })

	   set-pt! (pt p) #n
	   p
	 }) \
	 ((n eq 1) {
	   p := seq
	   seq = pt seq
	   set-pt! p #n
	   p
	 }) \
	 (else #n)
  }

  define (key-wrap! lst) {
   cond ((null? lst)) \
	 (else {
	   set-ph! lst (pair (key (ph lst)) (ph lst))
	   key-wrap! (pt lst)
	 })
  }

  define (key-unwrap! lst) {
   cond ((null? lst)) \
	 (else {
	   set-ph! lst (pth lst)
	   key-unwrap! (pt lst)
	 })
  }

 cond (key {
	key-wrap! seq
	seq = step (length seq)
	key-unwrap! seq
	seq
      }) \
      (else {
	step (length seq)
      })
}

define (rank-1-array->list array) {
  dimensions := array-length array

  do ((idx (dimensions - 1) (idx - 1))
      (lst #n		    (pair (array-ref array idx) lst))) \
     ((idx lt 0) lst)
}

;;; (sort! sequence less?)
;;; sorts the list, array, or string sequence destructively.  It uses
;;; a version of merge-sort invented, to the best of my knowledge, by
;;; David H. D. Warren, and first used in the DEC-10 Prolog system.
;;; R. A. O'Keefe adapted it to work destructively in Scheme.
;;; A. Jaffer modified to always return the original list.
;@
define (sort! seq less? & opt-key) {
  key := if (null? opt-key) #f (ph opt-key)

 cond ((array? seq) {
	do ((sorted (sort:sort-list! (rank-1-array->list seq) less? key) (pt sorted))
	     (i	    0							 (+ i 1))) \
	   ((null? sorted) seq) {
	  array-set! seq (ph sorted) i
	}
       }) \
       (else {			      ; otherwise, assume it is a list
	ret := sort:sort-list! seq less? key

        if (not (eq? ret seq)) {
	  do ((crt ret (pt crt))) \
	     ((eq? (pt crt) seq) {
	      set-pt! crt ret
	      sph := ph seq
	      spt := pt seq

	      set-ph! seq (ph ret)
	      set-pt! seq (pt ret)
	      set-ph! ret sph
	      set-pt! ret spt
	     })
	  } {
	    seq
	  }
	})
}

;;; (sort sequence less?)
;;; sorts a array, string, or list non-destructively.  It does this
;;; by sorting a copy of the sequence.  My understanding is that the
;;; Standard says that the result of append is always "newly
;;; allocated" except for sharing structure with "the last argument",
;;; so (append x #n) ought to be a standard way of copying a list x.
;@
define (sort seq less? & opt-key) {
  key := if (null? opt-key) #f (ph opt-key)

  ;;%%vm-trace 1
  cond ((array? seq) {
	newra := copy-array seq

	do ((sorted (sort:sort-list! (rank-1-array->list seq) less? key) (pt sorted))
	    (i 0 (+ i 1))) \
	   ((null? sorted) newra) {
	  array-set! newra (ph sorted) i
	}
       }) \
       (else {
	 sort:sort-list! (append seq #n) less? key
       })
}
