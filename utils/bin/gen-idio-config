#! /usr/bin/env bash

# Copyright (c) 2021-2022 Ian Fitchet <idf@idio-lang.org>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you
# may not use this file except in compliance with the License.  You
# may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#

#
# gen-idio-config -- create a system-specific header
#

# This is a poor man's autoconf.

handle_EXIT ()
{
    if [[ ${tmpdir:+X} = X ]] ; then
	cd /
	rm -rf ${tmpdir}
    fi
}

trap handle_EXIT EXIT

set -ue

note ()
{
    :
}

usage ()
{
    cat << EOF >&2

${0##*/} generates a system-specific header/makefile
  -M NAME	module [${opt_module}]

  -v		verbose
EOF
}

opt_module=idio
opt_verbose=

while getopts "hM:v" opt ; do
    case "${opt}" in
    h)
	usage
	exit 0
	;;
    M)
	opt_module=${OPTARG}
	;;
    v)
	opt_verbose=1
	;;
    *)
	usage
	exit 1
	;;
    esac
done

shift $(( OPTIND - 1 ))

######################################################################
#
# pseudo-autoconf

case "$(uname -s)" in
Darwin)
    tmpdir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
    ;;
*)
    tmpdir=$(mktemp -d)
    ;;
esac

names=()

##############################

# Mac OS 10.5.8 doesn't have strnlen(3)

names+=(IDIO_HAVE_STRNLEN)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>

int main (int argc, char **argv)
{
    size_t strnlen_r = strnlen ("hello", 2);
    return 0;
}
EOF

IDIO_HAVE_STRNLEN=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_STRNLEN=0
fi

##############################

# SunOS (OpenIndiana) and Mac OS don't have memrchr(3)

names+=(IDIO_HAVE_MEMRCHR)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>

int main (int argc, char **argv)
{
    char *memrchr_r = memrchr ("hello", 'h', 5);
    return 0;
}
EOF

IDIO_HAVE_MEMRCHR=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_MEMRCHR=0
fi

##############################

names+=(IDIO_HAVE_PTSNAME_R)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <stdlib.h>

int main (int argc, char **argv)
{
    char buf[512];
    ptsname_r (0, buf, 512);
    return 0;
}
EOF

IDIO_HAVE_PTSNAME_R=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_PTSNAME_R=0
fi

##############################

# Mac OS 10.5.8 reports POLLNVAL for (pseudo-terminal) devices.  Mac
# OS 10.15.7 doesn't (even if the manual page suggests that it
# should).

names+=(IDIO_CAN_POLL_DEVICE)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#if defined (__sun) && defined (__SVR4)
#include <stropts.h>
#endif


int main (int argc, char **argv)
{
    int mfd = posix_openpt (O_RDWR | O_NOCTTY);

    if (-1 == mfd) {
	perror ("posix_openpt");
	exit (1);
    }

    if (grantpt (mfd) == -1) {
	perror ("grantpt");
	exit (1);
    }

    if (unlockpt (mfd) == -1) {
	perror ("unlockpt");
	exit (1);
    }

    char *sn = ptsname (mfd);

    if (NULL == sn) {
	perror ("ptsname");
	exit (1);
    }

    int sfd = open (sn, O_RDWR | O_NOCTTY);

    if (-1 == sfd) {
	perror ("open");
	exit (1);
    }

#if defined (__sun) && defined (__SVR4)
    if (ioctl (sfd, I_PUSH, "ptem") == -1) {
	perror ("ioctl (I_PUSH, ptem)");
	exit (1);
    }

    if (ioctl (sfd, I_PUSH, "ldterm") == -1) {
	perror ("ioctl (I_PUSH, ldterm)");
	exit (1);
    }
#endif

    struct pollfd fds[1];

    fds[0].fd = sfd;
    fds[0].events = POLLIN;

    int poll_r = poll (fds, 1, 1);

    if (fds[0].revents & POLLNVAL) {
	exit (1);
    }

    close (sfd);
    close (mfd);

    return 0;
}
EOF

IDIO_CAN_POLL_DEVICE=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    echo "Failed to compile IDIO_CAN_POLL_DEVICE test" >&2
    exit 1
elif ! ${tmpdir}/a.out >/dev/null 2>&1 ; then
    IDIO_CAN_POLL_DEVICE=0
fi

if [[ ${IDIO_CAN_POLL_DEVICE} ]] ; then

    # WSL1 anomalous behaviour wants us to go a step further.
    #
    # Here, suppose a command running under a pty can have output
    # something and quit.  If everything is a bit slow then, assuming
    # we only now call poll(2) with both output and closed-output
    # pending, WSL1 only reports POLLHUP and does not report
    # POLLIN|POLLHUP.
    #
    # If you slow everything down some more (strace -f -e trace
    # write=all ...) then some gap appears where you'll get a POLLIN
    # and then a POLLHUP.
    #
    # It's somewhat annoying as, everywhere else, a POLLHUP on its own
    # means the other end of the pty has gone away.  If the other end
    # goes away with data pending you'll get POLLIN|POLLHUP for as
    # long as there is data pending and we (will have) handled the
    # POLLIN first.

    # We can't blindly ignore POLLHUP and rely on read(2) returning 0
    # because if nothing was output, perfectly valid for /bin/true,
    # and we have a POLLHUP then read(2) will return EIO.
    #
    # So we could look to capture EIO at every turn.  In the case of
    # the expect code in Idio-land by using trap -- hint: very
    # expensive.  Or we could have the read(2) wrapper code in
    # src/libc-api.c return some sentinel value for EIO which then
    # requires that every caller be aware that the sentinel value is
    # possible.  Or we could special-case WSL1 (and any others) at the
    # one-off cost of an extra clause in this script to identify the
    # issue.

    # Somewhat compounding the issue is that OpenBSD 6 and NetBSD 9
    # will both set IDIO_POLLHUP_OCCLUDES_POLLIN even though they pass
    # all the (problematic on WSL1) expect tests.

    # XXX We only want to say that IDIO_POLLHUP_OCCLUDES_POLLIN if it
    # really does occlude it in which case that's the only time that
    # we can exit (0).  Any other failure is, um, a success.

    names+=(IDIO_POLLHUP_OCCLUDES_POLLIN)
    cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <inttypes.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/wait.h>

#if defined (__sun) && defined (__SVR4)
#include <stropts.h>
#endif


int main (int argc, char **argv)
{
    int mfd = posix_openpt (O_RDWR | O_NOCTTY);

    if (-1 == mfd) {
	perror ("posix_openpt");
	exit (1);
    }

    if (grantpt (mfd) == -1) {
	perror ("grantpt");
	exit (1);
    }

    if (unlockpt (mfd) == -1) {
	perror ("unlockpt");
	exit (1);
    }

    char *sn = ptsname (mfd);

    if (NULL == sn) {
	perror ("ptsname");
	exit (1);
    }

    int sfd = open (sn, O_RDWR | O_NOCTTY);

    if (-1 == sfd) {
	perror ("open");
	exit (1);
    }

#if defined (__sun) && defined (__SVR4)
    if (ioctl (sfd, I_PUSH, "ptem") == -1) {
	perror ("ioctl (I_PUSH, ptem)");
	exit (1);
    }

    if (ioctl (sfd, I_PUSH, "ldterm") == -1) {
	perror ("ioctl (I_PUSH, ldterm)");
	exit (1);
    }
#endif

    pid_t pid = fork ();

    if (-1 == pid) {
	perror ("fork");
	exit (1);
    }

    if (0 == pid) {
	close (mfd);

	setsid ();

	dup2 (sfd, STDIN_FILENO);
	dup2 (sfd, STDOUT_FILENO);
	dup2 (sfd, STDERR_FILENO);

	if (sfd > STDERR_FILENO) {
	    close (sfd);
	}

	/* tty -> controlling tty */
	int ctty = open (sn, O_RDWR);

	if (-1 == ctty) {
	    /* "open (sn, O_RDWR)" */
	    size_t emlen = 6 + strlen (sn) + 9 + 1;
	    char em[emlen];
	    snprintf (em, emlen, "open (%s, O_RDWR)", sn);
	    perror (em);
	    exit (1);
	}
	close (ctty);

	char cmdstr[BUFSIZ];
	snprintf (cmdstr, BUFSIZ, "hello from %" PRIdMAX, (intmax_t) getpid ());

	execl ("/bin/echo", "/bin/echo", cmdstr, (char *) NULL);

	perror ("execl /bin/echo");
	exit (1);
    } else {
	close (sfd);

	/*
	 * exit (0) and only exit (0) is satisfactory
	 *
	 * XXX OpenBSD/NetBSD both get a 5s timeout here.
	 */
	int wstatus;
	pid_t waitpid_r = waitpid (pid, &wstatus, 0);

	if (-1 == waitpid_r) {
	    perror ("waitpid");
	    exit (1);
	}

	if (! WIFEXITED (wstatus)) {
	    fprintf (stderr, "/bin/echo: did not exit (killed/signalled/stopped)\n");
	    exit (1);
	}

	if (0 != WEXITSTATUS (wstatus)) {
	    fprintf (stderr, "/bin/echo: exit (%d)\n", WEXITSTATUS (wstatus));
	    exit (1);
	}

	/*
	 * Finally, we get to see if a process that output something
	 * (POLLIN) and has exited (POLLHUP) generates POLLIN|POLLHUP
	 * or just POLLHUP.
	 */
	struct pollfd fds[1];
	fds[0].fd = mfd;
	fds[0].events = POLLIN;

	/*
	 * 1ms timeout as the POLLIN|POLLHUP should be there as the
	 * process has been reaped.
	 */
	int poll_r = poll (fds, 1, 1);

	if (-1 == poll_r) {
	    perror ("poll mfd");
	    exit (1);
	}

	if (0 == poll_r) {
	    fprintf (stderr, "poll mfd: timeout\n");
	    exit (1);
	}

	if (fds[0].revents & POLLHUP) {
	    if (0 == (fds[0].revents & POLLIN)) {
		exit (0);
	    }
	}
    }

    close (sfd);
    close (mfd);

    return 1;
}
EOF

    # NB The logic of these tests are reversed with respect to similar
    # tests.  Only if we can definitively prove that POLLHUP occludes
    # POLLIN can we set the value.

    IDIO_POLLHUP_OCCLUDES_POLLIN=0
    if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
	echo "Failed to compile IDIO_POLLHUP_OCCLUDES_POLLIN test" >&2
	exit 1
    elif ${tmpdir}/a.out >/dev/null 2>&1 ; then
	IDIO_POLLHUP_OCCLUDES_POLLIN=1
    fi
fi

##############################

# Mac OS 10.5.8 doesn't have clock_gettime(2) but there is a
# workaround

names+=(IDIO_HAVE_CLOCK_GETTIME)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <time.h>

int main (int argc, char **argv)
{
    struct timespec ts;
    clock_gettime (CLOCK_MONOTONIC, &ts);
    return 0;
}
EOF

IDIO_HAVE_CLOCK_GETTIME=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_CLOCK_GETTIME=0
fi

##############################

# Oracle Solaris 11.4 doesn't have REG_STARTEND

names+=(IDIO_HAVE_REG_STARTEND)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <regex.h>

int main (int argc, char **argv)
{
    regex_t reg;
    regmatch_t matches[1];

    regexec (&reg, "", 1, &matches, REG_STARTEND);
    return 0;
}
EOF

IDIO_HAVE_REG_STARTEND=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_REG_STARTEND=0
fi

##############################

# SunOS never had the termios->c_[io]speed fields and Alpine/musl
# doesn't either

names+=(IDIO_HAVE_TERMIOS_SPEEDS)
cat <<EOF > ${tmpdir}/test.c
#define _GNU_SOURCE
#include <termios.h>
#include <unistd.h>

int main (int argc, char **argv)
{
    struct termios *termiosp;
    speed_t is = termiosp->c_ispeed;
    return 0;
}
EOF

IDIO_HAVE_TERMIOS_SPEEDS=1
if ! ${CC} -o ${tmpdir}/a.out ${tmpdir}/test.c >/dev/null 2>&1 ; then
    IDIO_HAVE_TERMIOS_SPEEDS=0
fi

######################################################################

var_MODULE=$( echo ${opt_module} | tr '[a-z]' '[A-Z]' )
var_header=${opt_module}-config.h

cat <<EOF > ${var_header}
/*
 * generated by ${0##*/} on $(date)
 */

/*
 * ${var_header}
 *
 */

#ifndef ${var_MODULE}_CONFIG_H
#define ${var_MODULE}_CONFIG_H

EOF

case "${opt_module}" in
idio)
    (
	for name in ${names[*]} ; do
	    case "${!name}" in
	    1)
		printf "#define %-30s 1\n" ${name}
		;;
	    *)
		printf "#undef  %s\n" ${name}
		;;
	    esac
	done
    ) >> ${var_header}
    ;;
esac

cat <<EOF >> ${var_header}

#endif
EOF
